<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom">
    <channel>
        <title>토스테크</title>
        <link>https://toss.tech</link>
        <description>토스의 개발과 디자인에 대한 이야기를 다룹니다.</description>
        <lastBuildDate>Sun, 02 Apr 2023 11:14:39 GMT</lastBuildDate>
        <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
        <generator>토스팀</generator>
        <language>ko</language>
        <copyright>Viva Republica, All rights reserved.</copyright>
        <atom:link href="https://toss.tech/rss.xml" rel="self" type="application/rss+xml"/>
        <item>
            <title><![CDATA[무지성으로 사용한 헬스 체크가 불러일으킬 수 있는 참사]]></title>
            <link>https://toss.tech/article/how-to-work-health-check-in-spring-boot-actuaotr</link>
            <guid>https://toss.tech/article/how-to-work-health-check-in-spring-boot-actuaotr</guid>
            <pubDate>Sat, 01 Apr 2023 06:38:57 GMT</pubDate>
            <description><![CDATA[서버의 상태를 알려주는 헬스 체크에 대해 알고 계시나요? 단순히 200 OK만 내려주겠거니 하고 별로 신경을 안 쓰고 계셨나요? 해당 포스트에서는 Spring Boot Actuaor가 제공해주는 헬스 체크는 어떤 식으로 서버의 상태를 점검하는지, 어떤 부분을 주의하며 사용해야하는지 알아봅니다.
]]></description>
            <content:encoded><![CDATA[
<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="1024" height="529" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-46-1024x529.png" alt="" class="wp-image-2138" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-46-1024x529.png 1024w, https://toss.tech/wp-content/uploads/2023/04/Untitled-46-300x155.png 300w, https://toss.tech/wp-content/uploads/2023/04/Untitled-46-768x397.png 768w, https://toss.tech/wp-content/uploads/2023/04/Untitled-46-1536x794.png 1536w, https://toss.tech/wp-content/uploads/2023/04/Untitled-46-1568x810.png 1568w, https://toss.tech/wp-content/uploads/2023/04/Untitled-46.png 1660w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure></div>



<p>뭐든 알고 쓰는 게 참 중요한 것 같습니다. 단순히 “<strong>지금은 잘 돌아가니까 문제 없다</strong>”는 접근은 문제가 발생하기 전까지는 문제를 방치하기 마련입니다.</p>



<p>사용하는 기술이나 구조에 대해 끊임없이 질문을 던지고 탐구하는 과정은 <a href="https://blog.toss.im/article/core-values-are-evolving">토스팀 코어밸류 3.0</a> 중 하나인 <strong>Question Every Assumption, 모든 기본 가정에 근원적 물음을 제기한다</strong>에도 부합하는 사례인것 같습니다. 이번 포스트에서는 제가 개발 과정에서 헬스 체크를 별다른 생각 없이 <a href="https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/actuator.html">Spring Boot Actuator</a>가 제공하는 기능을 사용하면서 겪은 이슈를 간략하게 설명해보겠습니다.</p>



<h2>들어가기에 앞서</h2>



<p>이 포스트는 작성 시점 기준에서 최신 Spring Boot GA(General Availability) 버전인 3.0.5 버전을 기준으로 설명합니다. 해당 버전의 하위/상위 버전에서는 기능이 미묘하게 다르게 동작할 수 있습니다. 2.x 버전에서도 큰 맥락에서는 동일한 동작을 보장하리라 추측되지만 본인이 사용하는 버전에 해당하는 자세한 내용을 찾아보시길 권장합니다.</p>



<h2>헬스 체크란?</h2>



<p>서비스의 고가용성(HA, High Availability), 고성능을 위한 부하 분산 등의 이유로 우리는 서버의 이중화(혹은 그 이상)를 하고, 앞에서 어떤 서버로 요청을 보낼지 라우팅 역할을 하는 로드 밸런서를 둡니다.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="321" height="212" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-47.png" alt="" class="wp-image-2139" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-47.png 321w, https://toss.tech/wp-content/uploads/2023/04/Untitled-47-300x198.png 300w" sizes="(max-width: 321px) 100vw, 321px" /><figcaption>로드 밸런서가 적절히 부하를 분산하여 A/B 서버 중 한 대에게 클라이언트의 요청을 보냅니다.</figcaption></figure></div>



<p>하지만 아래와 같이 서버 한 대가 서비스 불가 상태라면 어떻게 해야할까요? 해당 서버에 요청이 들어가야할까요?</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="321" height="212" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-48.png" alt="" class="wp-image-2140" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-48.png 321w, https://toss.tech/wp-content/uploads/2023/04/Untitled-48-300x198.png 300w" sizes="(max-width: 321px) 100vw, 321px" /></figure></div>



<p>혹은 대량의 트래픽이 들어올 것을 대비하는 등등의 이유로 서버를 증설해야 하는데 해당 서버가 관련된 소스코드를 로딩하고 있다면 어떻게 해야할까요? 이 때도 마찬가지로 해당 서버에 요청이 들어가야할까요?</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="321" height="342" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-49.png" alt="" class="wp-image-2141" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-49.png 321w, https://toss.tech/wp-content/uploads/2023/04/Untitled-49-282x300.png 282w" sizes="(max-width: 321px) 100vw, 321px" /></figure></div>



<p><strong>두 케이스 모두 해당 서버로 요청을 보내면 안 됩니다.</strong> 정상적인 서비스가 불가능해서 클라이언트의 요청을 수행할 수 없습니다. 장애를 유발하거나 해당 서버의 부하를 크게 증가시켜 오히려 장애를 더 심각하게 만들 수도 있습니다.</p>



<p>따라서 로드 밸런서에서는 각 서버의 헬스 체크 API를 호출해서 해당 서버가 현재 서비스 가능한 상태인지 아닌지 주기적으로 점검합니다.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="201" height="212" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-50.png" alt="" class="wp-image-2142"/><figcaption>헬스 체크 API 경로는 커스텀하게 설정 가능합니다.</figcaption></figure></div>



<p>헬스 체크에서 서버에 문제가 발견되면 로드 밸런서는 해당 서버로 요청을 보내지 않게 됩니다.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="321" height="212" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-51.png" alt="" class="wp-image-2143" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-51.png 321w, https://toss.tech/wp-content/uploads/2023/04/Untitled-51-300x198.png 300w" sizes="(max-width: 321px) 100vw, 321px" /></figure></div>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="321" height="322" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-52.png" alt="" class="wp-image-2144" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-52.png 321w, https://toss.tech/wp-content/uploads/2023/04/Untitled-52-300x300.png 300w, https://toss.tech/wp-content/uploads/2023/04/Untitled-52-150x150.png 150w" sizes="(max-width: 321px) 100vw, 321px" /></figure></div>



<p><strong>헬스 체크는 정상적으로 서비스가 가능한 서버에만 트래픽을 보내서 서비스의 고가용성을 확보</strong>하는 데 도움됩니다.</p>



<h2>Spring Boot Actuator의 헬스 체크</h2>



<p><a href="https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/actuator.html">Spring Boot Acutator</a>를 의존성으로 추가하면 기본적으로 헬스 체크 엔드포인트가 활성화됩니다.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="1024" height="189" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-54-1024x189.png" alt="" class="wp-image-2145" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-54-1024x189.png 1024w, https://toss.tech/wp-content/uploads/2023/04/Untitled-54-300x55.png 300w, https://toss.tech/wp-content/uploads/2023/04/Untitled-54-768x142.png 768w, https://toss.tech/wp-content/uploads/2023/04/Untitled-54-1536x283.png 1536w, https://toss.tech/wp-content/uploads/2023/04/Untitled-54-2048x378.png 2048w, https://toss.tech/wp-content/uploads/2023/04/Untitled-54-1568x289.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure></div>



<p>Spring Boot 3.x 기준으로 헬스 체크 엔드포인트는 <code>/actuator/health</code>이고, 설정을 바꾸지 않아도 해당 엔드포인트로 접속하면 HTTP 200 상태 코드와 해당 서버의 상태가 Response Body로 응답됩니다.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="1024" height="217" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-55-1024x217.png" alt="" class="wp-image-2146" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-55-1024x217.png 1024w, https://toss.tech/wp-content/uploads/2023/04/Untitled-55-300x63.png 300w, https://toss.tech/wp-content/uploads/2023/04/Untitled-55-768x162.png 768w, https://toss.tech/wp-content/uploads/2023/04/Untitled-55-1536x325.png 1536w, https://toss.tech/wp-content/uploads/2023/04/Untitled-55-1568x332.png 1568w, https://toss.tech/wp-content/uploads/2023/04/Untitled-55.png 2042w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>크롬 개발자 도구로 확인해본 Spring Boot Actuator의 헬스 체크 결과</figcaption></figure></div>



<p>Spring Boot Actuator는 어떠 기준으로 서버의 헬스 체크를 할까요? 확인하려면 <a href="https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/actuator.html#actuator.endpoints.health">Health Information 문서</a>를 살펴보면 됩니다. 해당 정보는 보안에 민감한 요소가 들어있을 수 있어서 퍼블릭하게 접근이 가능해서는 안 됩니다. 저는 로컬에서 간단하게 확인만 해보는 목적으로 <code>application.yml(application.properties)</code> 파일에 <code>management.endpoint.health.show-details: always</code>로 설정한 후에 다시 헬스 체크 결과를 확인했습니다.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="1024" height="859" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-56-1024x859.png" alt="" class="wp-image-2147" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-56-1024x859.png 1024w, https://toss.tech/wp-content/uploads/2023/04/Untitled-56-300x252.png 300w, https://toss.tech/wp-content/uploads/2023/04/Untitled-56-768x644.png 768w, https://toss.tech/wp-content/uploads/2023/04/Untitled-56-1536x1289.png 1536w, https://toss.tech/wp-content/uploads/2023/04/Untitled-56-2048x1718.png 2048w, https://toss.tech/wp-content/uploads/2023/04/Untitled-56-1568x1315.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure></div>



<p><a href="https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/actuator.html#actuator.endpoints.health.auto-configured-health-indicators">Auto-configured HealthIndicators</a>(<a href="https://docs.spring.io/spring-framework/docs/6.0.7/reference/html/web.html#mvc">WebMVC</a> 전용)와 <a href="https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/actuator.html#actuator.endpoints.health.auto-configured-reactive-health-indicators">Auto-configured ReactiveHealthIndicators</a>(<a href="https://docs.spring.io/spring-framework/docs/6.0.7/reference/html/web-reactive.html#spring-webflux">Webflux</a> 전용)에 나열된 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthIndicator.java">HealthIndicator</a>(혹은 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthIndicator.java">ReactiveHealthIndicator</a>)는 <a href="https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/using.html#using.auto-configuration">Spring Boot Auto Configuration</a>에 의해 자동으로 활성화되는데 관련된 의존성이 존재할 때만 활성화 되는 것들도 있습니다. 예를 들어, <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/jdbc/DataSourceHealthIndicator.java">DataSourceHealthIndicator</a>는 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator-autoconfigure/src/main/java/org/springframework/boot/actuate/autoconfigure/jdbc/DataSourceHealthContributorAutoConfiguration.java">DataSourceHealthContributorAutoConfiguration</a>에 의해 설정되는데 <a href="https://docs.spring.io/spring-data/jpa/docs/current/reference/html/">Spring Data JPA</a> 같이 DataSource를 사용하는 의존성을 추가했을 때 활성화됩니다.</p>



<p>그럼 코드레벨에서 각 (Reactive)<code>HealthIndicator</code>들이 어떻게 사용되는지 보겠습니다.</p>



<div class="wp-block-image"><figure class="aligncenter size-large"><img loading="lazy" width="1024" height="580" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-57-1024x580.png" alt="" class="wp-image-2148" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-57-1024x580.png 1024w, https://toss.tech/wp-content/uploads/2023/04/Untitled-57-300x170.png 300w, https://toss.tech/wp-content/uploads/2023/04/Untitled-57-768x435.png 768w, https://toss.tech/wp-content/uploads/2023/04/Untitled-57-1536x870.png 1536w, https://toss.tech/wp-content/uploads/2023/04/Untitled-57-2048x1160.png 2048w, https://toss.tech/wp-content/uploads/2023/04/Untitled-57-1568x888.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure></div>



<p>먼저 <code>/actuator/health</code>에 접속한 뒤에 브레이크 포인트를 걸고 디버그 모드로 살펴보면 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthEndpointSupport.java#L155-L161">HealthEndpointSupport 클래스의 getAggregateContribution 메서드</a>에서 각 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthContributor.java">HealthContributor</a>(혹은 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/ReactiveHealthContributor.java">ReactiveHealthContributor</a>)를 순회하면서 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthEndpointWebExtension.java#L92-L95">헬스 체크하는 코드</a>를 보실 수 있습니다. (헬스 체크하는 코드에 있는 HealthIndicator 인터페이스는HealthContributor 인터페이스를 상속받았습니다.)</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="457" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-58-1024x457.png" alt="" class="wp-image-2149" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-58-1024x457.png 1024w, https://toss.tech/wp-content/uploads/2023/04/Untitled-58-300x134.png 300w, https://toss.tech/wp-content/uploads/2023/04/Untitled-58-768x343.png 768w, https://toss.tech/wp-content/uploads/2023/04/Untitled-58-1536x686.png 1536w, https://toss.tech/wp-content/uploads/2023/04/Untitled-58-2048x914.png 2048w, https://toss.tech/wp-content/uploads/2023/04/Untitled-58-1568x700.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p><a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/HealthEndpointSupport.java#L193-L202">HealthEndpointSupport 클래스의 getCompositeHealth 메서드</a>에서는 각 HealthIndicator로부터 수집한 상태를 바탕으로 현재 서버의 상태를 진단합니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-1" data-shcb-language-name="CSS" data-shcb-language-slug="css"><link rel='stylesheet' id='syntax-highlighting-code-block-css'  href='https://toss.tech/wp-content/plugins/syntax-highlighting-code-block/vendor/scrivo/highlight-php/styles/default.css?ver=1.3.1' media='all' /><style>.wp-block-code {
	border: 0;
	padding: 0;
}

.wp-block-code > div {
	overflow: auto;
}

.shcb-language {
	border: 0;
	clip: rect(1px, 1px, 1px, 1px);
	-webkit-clip-path: inset(50%);
	clip-path: inset(50%);
	height: 1px;
	margin: -1px;
	overflow: hidden;
	padding: 0;
	position: absolute;
	width: 1px;
	word-wrap: normal;
	word-break: normal;
}

.hljs {
	box-sizing: border-box;
}

.hljs.shcb-code-table {
	display: table;
	width: 100%;
}

.hljs.shcb-code-table > .shcb-loc {
	color: inherit;
	display: table-row;
	width: 100%;
}

.hljs.shcb-code-table .shcb-loc > span {
	display: table-cell;
}

.wp-block-code code.hljs:not(.shcb-wrap-lines) {
	white-space: pre;
}

.wp-block-code code.hljs.shcb-wrap-lines {
	white-space: pre-wrap;
}

.hljs.shcb-line-numbers {
	border-spacing: 0;
	counter-reset: line;
}

.hljs.shcb-line-numbers > .shcb-loc {
	counter-increment: line;
}

.hljs.shcb-line-numbers .shcb-loc > span {
	padding-left: 0.75em;
}

.hljs.shcb-line-numbers .shcb-loc::before {
	border-right: 1px solid #ddd;
	content: counter(line);
	display: table-cell;
	padding: 0 0.75em;
	text-align: right;
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
	user-select: none;
	white-space: nowrap;
	width: 1%;
}
</style><div><code class="hljs language-css"><span class="hljs-keyword">@Override</span>
public Status getAggregateStatus(Set&lt;Status&gt; statuses) {
    <span class="hljs-selector-tag">return</span> <span class="hljs-selector-tag">statuses</span><span class="hljs-selector-class">.stream</span>()<span class="hljs-selector-class">.filter</span>(<span class="hljs-selector-tag">this</span><span class="hljs-selector-pseudo">::contains).min(this.comparator).orElse(Status.UNKNOWN)</span>;
}</code></div><small class="shcb-language" id="shcb-language-1"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">CSS</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">css</span><span class="shcb-language__paren">)</span></small></pre>

<pre class="wp-block-code" aria-describedby="shcb-language-2" data-shcb-language-name="PHP" data-shcb-language-slug="php"><div><code class="hljs language-php"><span class="hljs-comment">/**
 * {<span class="hljs-doctag">@link</span> Comparator} used to order {<span class="hljs-doctag">@link</span> Status}.
 */</span>
<span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StatusComparator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Status</span>&gt; </span>{

    @Override
    <span class="hljs-keyword">public</span> int compare(Status s1, Status s2) {
        <span class="hljs-keyword">List</span>&lt;String&gt; order = SimpleStatusAggregator.this.order;
        int i1 = order.indexOf(getUniformCode(s1.getCode()));
        int i2 = order.indexOf(getUniformCode(s2.getCode()));
        <span class="hljs-keyword">return</span> (i1 &lt; i2) ? <span class="hljs-number">-1</span> : (i1 != i2) ? <span class="hljs-number">1</span> : s1.getCode().compareTo(s2.getCode());
    }

}</code></div><small class="shcb-language" id="shcb-language-2"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">PHP</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">php</span><span class="shcb-language__paren">)</span></small></pre>


<p><a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/SimpleStatusAggregator.java#L73-L76">SimpleStatusAggregator의 getAggregateStatus 메서드</a>에서는 각 상태를 수집해서 하나의 Status로 반환하고 있는데 이 때 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/SimpleStatusAggregator.java#L100-L113">StatusComparator</a>가 사용됩니다.</p>


<pre class="wp-block-code"><div><code class="hljs">defaultOrder.add(Status.DOWN.getCode());
defaultOrder.add(Status.OUT_OF_SERVICE.getCode());
defaultOrder.add(Status.UP.getCode());
defaultOrder.add(Status.UNKNOWN.getCode());
DEFAULT_ORDER = Collections.unmodifiableList(getUniformCodes(defaultOrder.stream()));</code></div></pre>


<p>이 때 가장 중요한 것은 Status의 순서인데 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/SimpleStatusAggregator.java#L42-L50">SimpleStatusAggragtor의 static 생성자 블럭</a>을 보게되면 위와 같은 순서로 추가하고 있고,</p>


<pre class="wp-block-code" aria-describedby="shcb-language-3" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript">public SimpleStatusAggregator() {
    <span class="hljs-keyword">this</span>.order = DEFAULT_ORDER;
}</code></div><small class="shcb-language" id="shcb-language-3"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>별도의 순서를 주지 않은 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/health/SimpleStatusAggregator.java#L56-L58">기본 생성자</a>는 <code>defaultOrder</code>에 추가한 순서를 사용하는 것을 볼 수 있습니다.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="754" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-59-1024x754.png" alt="" class="wp-image-2150" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-59-1024x754.png 1024w, https://toss.tech/wp-content/uploads/2023/04/Untitled-59-300x221.png 300w, https://toss.tech/wp-content/uploads/2023/04/Untitled-59-768x565.png 768w, https://toss.tech/wp-content/uploads/2023/04/Untitled-59-1536x1131.png 1536w, https://toss.tech/wp-content/uploads/2023/04/Untitled-59-2048x1507.png 2048w, https://toss.tech/wp-content/uploads/2023/04/Untitled-59-1568x1154.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p><code>getAggregateStatus</code>는 <code>Status</code> 중에 가장 순서가 빠른(오름차순) 것 하나를 반환하게 되어있기 때문에 만약에 <code>Down</code>을 반환한 <code>HealthIndicator</code>가 하나라도 존재하면 서비스의 상태를 <code>Down</code>으로 생각해서 <code>503</code>을 반환하게 됩니다.</p>



<h2>헬스 체크에서 조심해야 하는 점</h2>



<p>Spring Boot Actuator 헬스 체크의 동작원리를 잘 모르고 사용하면 일어날 수 있는 문제를 설명하겠습니다.</p>



<h3>1. 의도치 않은 장애 발생</h3>



<figure class="wp-block-image size-large"><img loading="lazy" width="556" height="288" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-60.png" alt="" class="wp-image-2151" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-60.png 556w, https://toss.tech/wp-content/uploads/2023/04/Untitled-60-300x155.png 300w" sizes="(max-width: 556px) 100vw, 556px" /></figure>



<p>각 서버에서는 서비스를 제공하는 서비스 DB와 데이터를 분석하는 로그 DB가 있다고 가정하겠습니다. 그리고 로그 DB에 장애가 나면 로그 DB에 적재하는 작업은 별도의 스레드에서 비동기로 처리하도록 작업을 해놨다고 가정하겠습니다.로그 데이터 저장이 불가능하더라도 실시간 서비스에는 문제가 없도록 하기 위해서죠.</p>



<p>이 때 만약 로그 DB에 작업을 해야해서 순단이 발생하거나 접속에 문제가 생긴다면 어떻게 될까요? 아래 정답을 확인하기 전에 1분 동안 한 번 생각해보시길 바랍니다.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="556" height="288" src="https://wp.toss.tech/wp-content/uploads/2023/04/Untitled-61.png" alt="" class="wp-image-2152" srcset="https://toss.tech/wp-content/uploads/2023/04/Untitled-61.png 556w, https://toss.tech/wp-content/uploads/2023/04/Untitled-61-300x155.png 300w" sizes="(max-width: 556px) 100vw, 556px" /></figure>



<p>위에 Spring Boot Actuator의 헬스 체크는 여러 <code>HealthIndicator</code>가 수집한 상태를 토대로 서비스의 상태를 판단한다고 말씀드렸습니다. 그 순서를 차근차근 설명해보겠습니다.</p>



<ol><li><code>RoutingDataSourceHealthContributor</code>에 의해 여러 DataSource의 헬스를 체크합니다.<ol><li><code>DataSourceHealthIndicator</code>에 의해 서비스 DB의 상태를 체크했을 때는 <code>UP</code>이 반환됩니다.</li><li><code>DataSourceHealthIndicator</code>에 의해 로그 DB의 상태를 체크했을 때는 <code>DOWN</code>이 반환됩니다.</li></ol></li><li>수집한 상태들은 <code>SimpleStatusAggregator</code>에 의해 서비스 상태를 판단하게 되는데 아무런 순서 설정을 하지 않았으면 DOWN인 게 하나라도 있다면 <code>DOWN</code>이 반환됩니다.</li><li>서비스의 상태가 <code>DOWN</code>(<code>503</code>)으로 판단됐기 때문에 로드 밸런서에서는 서버로 트래픽을 보내지 않게 됩니다.</li><li>서비스 DB에 문제가 없음에도 불구하고 클라이언트의 요청은 처리되지 않고 장애가 발생합니다.</li></ol>



<p>우리는 분명 최대한 높은 가용성을 보장하기 위해 로그 DB의 장애가 전파되지 않도록 격리했음에도 불구하고 장애가 발생할 수 있습니다. 이를 해결하기 위해서는</p>



<ol><li>Spring Boot Actuator의 헬스 체크가 아닌 직접 헬스 체크 API를 구현할 수도 있습니다.</li><li><code>HealthIndicator</code> 중에 헬스 체크에 영향을 끼치지 않길 희망하는 것들은 비활성화 시킨다거나(DB를 예로 들자면 <code>management.health.db.enabled: false</code>(기본값 <code>true</code>)로 설정한다거나)</li><li>문제가 되는 <code>HealthIndicator</code> 빈을 직접 생성해서 Auto Configuration의 동작을 오버라이딩 하는 방법 등등이 있습니다.</li></ol>



<p>다만 헬스 체크에 이런 저런 로직들이 들어간다는 것은 일반적으로 예측 가능하지 못할 수 있으므로 팀 내에 꼭 공유가 잘 되어야할 것입니다.</p>



<h3>2. 트러블 슈팅의 지연</h3>



<blockquote class="wp-block-quote"><p>비슷한 상황으로, 예전에 API 서버에서 외부 의존성 중에 ES만 죽었는데, API 서버가 죽었다고 판단돼서 DOWN이 된적이 있었어요. 헬스 체크에서 detail 옵션을 키면, 상세하게 쭉 나오더라고요. 당시에 LB 통해서 접근이 안 됐는데, WAS는 개별로 접근했을 때는 문제가 없어 보여서 트러블 슈팅이 늦어졌었습니다.</p></blockquote>



<p>이는 실제 사내에서 비슷한 상황이 발생했을 때 트러블 슈팅이 지연된 사례입니다. Spring Boot Actuator 헬스체크의 동작원리를 정확히 이해했다면 ES(Elasticsearch) 서버가 죽었을 때 해당 서버의 헬스체크도 같이 죽게 된다는 걸 예측할 수 있습니다. (<a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/elasticsearch/ElasticsearchRestClientHealthIndicator.java">ElasticsearchRestClientHealthIndicator</a> 혹은 <a href="https://github.com/spring-projects/spring-boot/blob/v3.0.5/spring-boot-project/spring-boot-actuator/src/main/java/org/springframework/boot/actuate/data/elasticsearch/ElasticsearchReactiveHealthIndicator.java">ElasticsearchReactiveHealthIndicator</a>가 ES 서버의 헬스체크를 해서 헬스체크 API 응답에 전체적으로 영향을 끼치기 때문에)</p>



<p>하지만 헬스체크의 동작원리를 잘 모르면 우리가 장애를 격리했다고 생각한 시스템(위의 상황에서는 ES)에만 문제가 있는데 왜 장애가 발생하는지, 왜 도메인을 통해서 접근하면 접근이 안 되는지 상황 파악이 안 될 수 있습니다. 서버는 정상적으로 살아있고 부하도 없는 상황이라면 헬스 체크 API를 호출할 생각도 못 하고, 로드 밸런서의 버그인지부터 의심을 할 수도 있습니다. 이렇게 엉뚱한 포인트를 의심하게 되면 장애 상황은 계속 되고, 서버를 재시작해도 근본적인 문제를 해결(위 상황에서는 ES 서버의 복구)하기 전까지는 여전히 헬스 체크에 실패할테니 장시간 장애가 지속될 수도 있습니다.</p>



<p>결국 각 서버 인스턴스마다 직접 헬스 체크 API를 호출해서 정상 응답을 받는지 확인해봐야하는데 여기까지 사고의 흐름이 다다르는데 너무 많은 시간 소요와 불필요한 리소스 낭비들을 초래하게 됩니다.</p>



<h2>마치며</h2>



<p>평상시에는 헬스 체크하면 <strong>그냥 <code>200 OK</code>만 응답하는 정말 심플한 API</strong> 수준으로만 생각하고 큰 신경도 쓰지 않았습니다. 근데 사소한 것에 한 번 데인 뒤로부터는 개발자가 왜 호기심이 많아야하는지 한 번 더 깨닫게 되었습니다. 그냥 단순히 돌아만가는 코드가 아닌 이 코드가 왜 그렇게 돌아가는지, 우리가 왜 이 기술을 선택하게 된 것인지, 끊임없이 고민하고 탐구하기 위해서는 강력한 호기심이 동기부여가 되기 때문입니다. 이러한 고민을 미리했다면 장애 상황을 미연에 방지할 수 있고, 장애 발생 이후에라도 이슈 분석을 통해 트러블 슈팅 능력도 크게 향상된다는 것을 다시 한번 깨닫게 되는 소중한 경험이었습니다.</p>



<h2>참고 링크</h2>



<ul><li><a href="https://docs.spring.io/spring-boot/docs/3.0.5/reference/html/actuator.html#actuator">Spring Boot Actuator Docs</a></li><li><a href="http://forward.nhnent.com/hands-on-labs/java.spring-boot-actuator/06-health.html">NHN Forward spring-boot-actuator documentation</a></li></ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[ESLint와 AST로 코드 퀄리티 높이기]]></title>
            <link>https://toss.tech/article/improving-code-quality-via-eslint-and-ast</link>
            <guid>https://toss.tech/article/improving-code-quality-via-eslint-and-ast</guid>
            <pubDate>Fri, 31 Mar 2023 06:47:53 GMT</pubDate>
            <description><![CDATA[ESLint와 AST로 토스에서 코드 퀄리티를 높인 방법에 대해 소개드려요.
]]></description>
            <content:encoded><![CDATA[
<h2>코딩 컨벤션을 일관적으로 유지하기</h2>



<p>일관적인 코딩 컨벤션을 가지면 코드를 읽기 쉬워지고, 안티패턴을 방지할 수 있습니다. 결과로 버그도 줄고, 코드를 쉽게 유지보수할 수 있죠.</p>



<p>하지만 이것을 사람이 직접 적용하는 것은 한계가 있기 때문에, 여러 가지 정적 분석 도구를 활용하게 됩니다. JavaScript/TypeScript 코드베이스에서는 주로 ESLint를 통해 컨벤션과 맞지 않는 코드를 사전에 감지하게 되는데요. 이러한 정적 분석 도구를 이용하게 되면 코드 리뷰 등 사람이 직접 읽지 않아도 컨벤션과 다른 부분을 기계적으로 잡아낼 수 있습니다.</p>



<h2>이미 만들어진 규칙에서 오는 한계</h2>



<p>ESLint에서는 생태계 내 다양한 플러그인 등을 통해 많은 수의 자주 사용되는 코딩 컨벤션을 커버할 수 있습니다. 하지만 우리 회사의 컨벤션에 맞는 규칙이 없다면 어떨까요? 조직이 커지고 요구 사항이 변화하게 되면서 커뮤니티에서 만들어진 규칙만으로는 조직 내 사용례에 정확히 부합하지 않는 경우가 생깁니다. 사내 라이브러리 내 사용 방식에 대한 컨벤션을 정의하거나, 조직 내 컨벤션과 커뮤니티에서 통용되는 컨벤션이 다소 다를 수도 있죠.</p>



<p>예를 들어 토스에서는 SSR을 통해 서버 사이드에서 React 렌더링을 한 뒤 애플리케이션에 제공해서 로딩 속도를 높이고 있는데요, 이로 인해 브라우저 환경에서 작동하는 코드가 서버 사이드에서 실행되면서 의도치 않은 버그를 유발하는 케이스가 있습니다. 이러한 경우 미리 브라우저에서 호환되지 않는 코드를 감지하여 사전에 오류를 예방할 수 있다면 큰 도움이 되겠죠.</p>



<h3>린터는 어떻게 규칙을 적용할까?</h3>



<p>이러한 제약 사항을 해결하기 위해서는 우리만의 ESLint 규칙을 정의할 수 있어야 합니다. 그런데 ESLint는 어떻게 코드에 대한 규칙을 만들고 적용하고 있을까요?</p>



<p>예를 들어서, Production 환경에서 로그가 함부로 찍히지 않도록 console.log 사용을 제한하는 규칙을 만드는 상황을 생각합시다.</p>



<p>간단하게 정규식으로 구현해보면 이런 형식이 될 것입니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-4" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-keyword">if</span> (sourceCode.match(<span class="hljs-regexp">/console\\.log/</span>) != <span class="hljs-literal">null</span>) {
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"console.log를 사용하면 안 돼요!"</span>)
}</code></div><small class="shcb-language" id="shcb-language-4"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>하지만 이 방법은 생각했던 만큼 잘 작동하지 않습니다.</p>



<p>예를 들어서, 이 코드에서 console.log가 문자열 안에 있는지도 알 수 없습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-5" data-shcb-language-name="plaintext" data-shcb-language-slug="plaintext"><div><code class="hljs language-plaintext">const message = "console.log()를 쓰지 마세요.";

&lt;Button&gt;console.log 로그 활성화&lt;/Button&gt;</code></div><small class="shcb-language" id="shcb-language-5"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">plaintext</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">plaintext</span><span class="shcb-language__paren">)</span></small></pre>


<p>주석 안에 있는지도 알 수 없죠.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-6" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-comment">// console.log(…) 를 쓰지 마세요.</span></code></div><small class="shcb-language" id="shcb-language-6"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이러한 작은 케이스들을 하나하나 대응할 수도 있지만, ESLint는 좀 더 강력한 방법을 사용합니다.</p>



<h3>AST에서 원하는 정보 찾아내기</h3>



<p>ESLint는 Abstract Syntax Tree(AST)를 이용해서 규칙을 정의하고 적용합니다.</p>



<p>AST는 소스 코드를 읽어낸 뒤 각 코드에서 구문 정보를 정리하여 나타낸 트리 형태의 자료 구조입니다. 예를 들어서, <code>console.log</code> 함수 호출과, 문자열이나 주석 속의 <code>console.log</code> 를 구별할 수 있게 해 줍니다.</p>



<p>AST의 상세한 구조는 파서마다 약간의 차이가 있지만, <a href="https://astexplorer.net/">AST Explorer</a>라는 도구를 사용하면 소스 코드를 넣었을 때 어떤 AST가 나오는 지를 쉽게 확인할 수 있습니다. 일례로 <code>console.log()</code> 을 acorn이라고 하는 파서에서 파싱을 시도하면 이런 AST를 얻을 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-7" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript">{
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"ExpressionStatement"</span>,
  <span class="hljs-string">"expression"</span>: {
    <span class="hljs-string">"type"</span>: <span class="hljs-string">"CallExpression"</span>,
    <span class="hljs-string">"callee"</span>: {
      <span class="hljs-string">"type"</span>: <span class="hljs-string">"MemberExpression"</span>,
      <span class="hljs-string">"object"</span>: {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"Identifier"</span>,
        <span class="hljs-string">"name"</span>: <span class="hljs-string">"console"</span>
      },
      <span class="hljs-string">"property"</span>: {
        <span class="hljs-string">"type"</span>: <span class="hljs-string">"Identifier"</span>,
        <span class="hljs-string">"name"</span>: <span class="hljs-string">"log"</span>
      },
    },
    <span class="hljs-string">"arguments"</span>: []
  }
}
</code></div><small class="shcb-language" id="shcb-language-7"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이와 다르게, 문자열에 포함되어 있는 console.log() 의 파싱을 시도하면 이런 AST를 얻을 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-8" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript">{
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"Literal"</span>,
  <span class="hljs-string">"value"</span>: <span class="hljs-string">"console.log()"</span>,
  <span class="hljs-string">"raw"</span>: <span class="hljs-string">"\\"</span><span class="hljs-built_in">console</span>.log()\\<span class="hljs-string">""</span>
}
</code></div><small class="shcb-language" id="shcb-language-8"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>함수를 호출하는 경우, CallExpression과 MemberExpression이 사용되고, 문자열 안에 있는 경우 Literal이 사용되는 것을 볼 수 있네요.</p>



<p>여기서 얻은 정보를 바탕으로 acorn을 이용해 console.log를 감지하는 스크립트를 작성해볼 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-9" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { Parser } <span class="hljs-keyword">from</span> <span class="hljs-string">"acorn"</span>;
<span class="hljs-keyword">import</span> { simple } <span class="hljs-keyword">from</span> <span class="hljs-string">"acorn-walk"</span>;

simple(Parser.parse(sourceCode), {
  CallExpression({ callee }) {
    <span class="hljs-keyword">if</span> (callee.object.name === <span class="hljs-string">"console"</span> &amp;&amp; callee.property.name === <span class="hljs-string">"log"</span>) {
      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"console.log를 사용하면 안 돼요!"</span>);
    }
  },
});
</code></div><small class="shcb-language" id="shcb-language-9"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이렇게 acorn-walk를 사용하면 CallExpression에 해당하는 console.log만 감지할 수 있습니다. 주석이나 문자열, 화이트스페이스에 관계없이 안전하게 소스코드를 분석할 수 있는 것이죠.</p>



<h2>ESLint에서 사용할 규칙 직접 정의하기</h2>



<p>ESLint는 espree라고 하는 파서를 통해 소스 코드를 파싱하고, 이 결과를 각 플러그인에서 순회하며 규칙을 실행합니다. 우리가 원하는 규칙을 직접 플러그인을 통해 정의하고, 실행할 수 있어요.</p>



<p>Espree AST만 읽을 수 있다면 ESLint 규칙도 쉽게 만들 수 있습니다.</p>



<p>토스에서는 소스 코드 내에서 HTTP 링크를 찾아 HTTPS 링크로 바꿔야 한다고 알려주는 ban-http 와 같은 규칙을 정의하고 있습니다. 이런 규칙을 어떻게 직접 정의할 수 있는지 알아볼까요?</p>



<p>먼저 소스 코드 내 문자열이 Espree AST에서 어떻게 표현되는 지를 알아봐야 합니다. AST Explorer에서 상단의 파서 설정을 Espree로 변경해주면 이를 쉽게 알 수 있습니다.</p>



<p>Literal 타입의 노드에서 value를 읽으면 문자열 내용을 알 수 있네요.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-10" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript">{
  <span class="hljs-string">"type"</span>: <span class="hljs-string">"Literal"</span>,
  <span class="hljs-string">"value"</span>: <span class="hljs-string">"&lt;http://toss.im&gt;"</span>,
  <span class="hljs-string">"raw"</span>: <span class="hljs-string">"\\"</span>&lt;http:<span class="hljs-comment">//toss.im&gt;\\""</span>
}
</code></div><small class="shcb-language" id="shcb-language-10"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이를 기반으로 아래와 같이 ESLint 규칙을 새로 정의할 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-11" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">meta</span>: { <span class="hljs-comment">/* ... */</span> },
  <span class="hljs-attr">create</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) </span>{
    <span class="hljs-keyword">return</span> {
      <span class="hljs-attr">Literal</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">node</span>) </span>{
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> node.value !== <span class="hljs-string">'string'</span>) {
          <span class="hljs-keyword">return</span>;
        }
        
        <span class="hljs-keyword">if</span> (node.value.indexOf(<span class="hljs-string">'http://'</span>) &gt;= <span class="hljs-number">0</span>) {
          context.report({
            node,
            <span class="hljs-attr">messageId</span>: <span class="hljs-string">'isHttpBanned'</span>,
          });
        }
      },
    };
  }
};</code></div><small class="shcb-language" id="shcb-language-11"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>위 코드는 Literal을 만났을 때, 그 Literal의 값이 “http://” 로 시작하는 문자열이면 에러를 리포트하는 코드입니다. 생각보다 복잡하지는 않죠?</p>



<p>이렇게 작성된 규칙을 ESLint에 추가하면 개발자들이 개발 중 규칙에 맞지 않는 코드를 작성했을 때 이렇게 알려줄 수 있어요.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="133" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-7-1024x133.png" alt="" class="wp-image-2126" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-7-1024x133.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-7-300x39.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-7-768x100.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-7.png 1336w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<h2>토스에서 사용하는 여러가지 규칙들</h2>



<p>이를 바탕으로 토스에서는 여러 가지 ESLint 규칙을 만들어서 플러그인으로 배포하고, 이를 서비스에서 사용하여 코딩 컨벤션을 유지하고 있습니다. 몇 가지 사용하는 규칙들은 아래와 같은 규칙들이 있어요.</p>



<ul><li>토스 프론트엔드 챕터 내 맥락이 강한 규칙들<ul><li>사내 라이브러리 사용 시 deprecated된 API 사용 금지</li><li>이전 토스 도메인 사용 금지</li></ul></li><li>외부 라이브러리 사용에 관련한 규칙들<ul><li>사용하지 않기로 한 패키지 사용 제한 (ban-axios, ban-lodash)</li><li>훅 이름에서 한글 허용 (rules-of-hooks)</li><li>SSR에서 사용 시 오류를 내는 라이브러리 사용 제한 (ban-ssr-unsafe-method)</li></ul></li></ul>



<p>또한 ESLint 외에도 자체 제작한 도구를 통해 사용해 deperecated 된 API의 사용이나 중복된 코드를 감지하기도 해요.</p>



<h2>더 알아보기</h2>



<p>ESLint 플러그인을 만드는 방법과 ESLint API 자체에 대한 글은 ESLint 공식 문서에서 더 자세히 알 수 있어요.</p>



<p><a href="https://eslint.org/docs/latest/extend/plugins">Create Plugins &#8211; ESLint &#8211; Pluggable JavaScript Linter</a></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[내 아이디어를 너무 믿지 마세요]]></title>
            <link>https://toss.tech/article/dont-trust-your-gut</link>
            <guid>https://toss.tech/article/dont-trust-your-gut</guid>
            <pubDate>Tue, 28 Mar 2023 08:31:40 GMT</pubDate>
            <description><![CDATA[너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였어요.
]]></description>
            <content:encoded><![CDATA[
<p><em>‘내 아이디어를 너무 믿지 마세요.’ </em></p>



<p>제가 토스에서 일하면서 가장 크게 배웠던 것 중 하나예요. 저는 너무 좋은 아이디어라고 생각해서 만들었는데 실제 유저들의 반응은 정반대였던 적이 여러 번 있었거든요. 이걸 가장 크게 느꼈던 사례를 하나 소개해드릴게요.</p>



<p></p>



<h3><strong>문제</strong></h3>



<p>제가 채용 사이트를 맡고 있을 때였어요. 채용팀에서 하는 이벤트들과는 별개로 토스에 지원하는 지원자 수를 늘리기 위해 제품 관점에서 시도할 수 있는 게 없을까? 고민을 했었어요.</p>



<p></p>



<h3><strong>가설</strong></h3>



<p>이직을 할 때 보통 이력서나 자기소개서 등을 준비하는데, 이 서류들을 준비하는 과정이 엄두가 안나서 이직을 미루거나 포기하는 사람들이 많아요. 그래서 <code><span style="color:#ed2121" class="has-inline-color">서류를 준비하는 것보다 간편한 방법이 있다면 지원자가 많이 늘겠다</span></code> 싶었죠.</p>



<p>어떻게 해야 지원자가 간편하다고 느낄까? 고민하다가 문득 ‘음성’이라는 단어가 스쳐지나갔어요. 당시 제가 출근길에 항상 팟캐스트를 들었거든요. 편하게 이야기 하는 팟캐스트 속 사람들이 갑자기 생각나면서 아이디어 하나가 반짝 떠올랐어요.</p>



<p><strong><em>“이력서를 글이 아닌 음성으로 받으면 어떨까?”</em></strong></p>



<p></p>



<h3><strong>해결책</strong></h3>



<p>책상에 앉아 각 잡고 써야 하는 이력서가 아니라, 친한 동료한테 얘기하듯이 내 업무 경험을 음성으로 녹음하고 이걸로 이력서를 대신하는 제품을 만들기로 했어요. 하고 싶은 이야기를 문장으로 정리해서 쓰는 것보다 생각나는대로 내뱉는 게 부담도 덜하고 지원자의 마음을 더 잘 표현할 수 있을 것 같았죠.</p>



<p>어떤 회사에서도 시도하지 않았던 신박한 아이디어라는 생각에 저는 이 아이디어에 완전 빠져버렸어요. 그래서 클로바, 파파고, 아이폰 음성 메모 등 목소리를 녹음하는 각종 앱을 참고하며 빠르게 스케치를 했어요.</p>



<figure class="wp-block-image size-large is-style-default"><img loading="lazy" width="2672" height="838" src="https://wp.toss.tech/wp-content/uploads/2023/03/1-1024x321.png" alt="" class="wp-image-2095" srcset="https://toss.tech/wp-content/uploads/2023/03/1-1024x321.png 1024w, https://toss.tech/wp-content/uploads/2023/03/1-300x94.png 300w, https://toss.tech/wp-content/uploads/2023/03/1-768x241.png 768w, https://toss.tech/wp-content/uploads/2023/03/1-1536x482.png 1536w, https://toss.tech/wp-content/uploads/2023/03/1-2048x642.png 2048w, https://toss.tech/wp-content/uploads/2023/03/1-1568x492.png 1568w" sizes="(max-width: 2672px) 100vw, 2672px" /><figcaption><span style="color:#6b6d6e" class="has-inline-color">최초 아이디어 스케치</span></figcaption></figure>



<p>그리고 이 아이디어는 <strong>‘3가지 질문에 답하면 저절로 완성되는 이력서’</strong>라는 콘셉트로 발전했어요. 이력서나 자기소개서는 몇 번을 썼다 지웠다 하면서 짧게는 며칠, 길게는 몇 주에 걸쳐 간신히 완성하는 게 흔한 일이잖아요? </p>



<p>그런데 3가지 질문에 대답만 하면 저절로 완성된다니, 게다가 힘들게 글로 쓰는게 아니라 말로 하면 된다니! 우리가 채용의 문화를 완전 바꿔버릴 수도 있겠다 싶었어요. 너무 잘될 것 같다는 막연한 믿음이 있었지만 혹시 몰라서 프로토타입을 만들어 사내에서 UT(사용성 테스트)를 해봤어요.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="355" src="https://wp.toss.tech/wp-content/uploads/2023/03/2-1024x355.png" alt="" class="wp-image-2096" srcset="https://toss.tech/wp-content/uploads/2023/03/2-1024x355.png 1024w, https://toss.tech/wp-content/uploads/2023/03/2-300x104.png 300w, https://toss.tech/wp-content/uploads/2023/03/2-768x267.png 768w, https://toss.tech/wp-content/uploads/2023/03/2-1536x533.png 1536w, https://toss.tech/wp-content/uploads/2023/03/2-2048x711.png 2048w, https://toss.tech/wp-content/uploads/2023/03/2-1568x544.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p></p>



<h3><strong>결과</strong></h3>



<p>그런데 제 예상과는 완전히 다른 결과가 나온 거예요. 갑자기 예상 못한 녹음 기능이 나타나 당황스럽다는 의견부터 말투나 목소리까지 신경써야 해서 글로 쓰는 것보다 오히려 더 오래 걸릴 것 같다, 대본을 준비해서 말해야 할 것 같다 등 부정적인 피드백이 많았어요. 의도와는 다르게 <code><span style="color:#ed2121" class="has-inline-color">간편한게 아니라 오히려 더 어렵고 부담스러운 방식</span></code>이라고 느끼셨던거죠.</p>



<p>생각과 너무 다른 반응에 조금 당황스럽기도 했지만 그래도 개발하기 전에 알게 돼서 다행이다 싶었죠. 이후 여러 번의 UT를 반복하며, 입사 지원은 지원자에게 중요한 일이기 때문에 ‘음성 지원’이라는 낯선 방식이 오히려 거부감을 준다는 사실을 깨달았어요.</p>



<p>그래서 무작정 지원을 유도하는 게 아니라, 토스와 잠재 지원자 사이에 ‘작은 접점’이라도 만들어보자라는 마음으로 ‘3가지 질문에 답하면 합격 확률 높은 포지션을 알려줄게요’라는 콘셉트로 방향을 바꿨어요. 그리고 참여자의 부담감을 덜어주기 위해 ‘이건 입사 지원이 아니다’라는 것을 명시했고 편하게 말할 수 있도록 돕는 장치들을 넣었어요. 이렇게 출시한 제품은 정말 많은 분들이 참여해주셨고 그 중 일부는 실제 지원까지 하셨어요.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="356" src="https://wp.toss.tech/wp-content/uploads/2023/03/3-1024x356.png" alt="" class="wp-image-2097" srcset="https://toss.tech/wp-content/uploads/2023/03/3-1024x356.png 1024w, https://toss.tech/wp-content/uploads/2023/03/3-300x104.png 300w, https://toss.tech/wp-content/uploads/2023/03/3-768x267.png 768w, https://toss.tech/wp-content/uploads/2023/03/3-1536x534.png 1536w, https://toss.tech/wp-content/uploads/2023/03/3-2048x712.png 2048w, https://toss.tech/wp-content/uploads/2023/03/3-1568x545.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p></p>



<h3><strong>적용해보기</strong></h3>



<p>개발하기 전에 프로토타입을 만들어 UT를 하면 예상치 못한 문제를 발견할 수 있어요. 그렇게 발견한 문제를 개선한 후에 개발을 하면 시간과 비용을 많이 아낄 수 있고요. UT는 실제 유저를 대상으로 하면 제일 좋지만 그게 어려울 땐 비슷한 환경의 사람들을 찾는 편이에요.</p>



<ul><li>외부의 잠재 지원자를 찾기 어려우니 사내에 이직 경험이 있는 다양한 직군의 동료들을 대상으로 한다</li></ul>



<p>그리고 UT를 하기 전에 무엇을 검증하고 싶은지, 검증을 위해 확인해야 할 것은 무엇인지를 고려해서 시나리오를 짜요.</p>



<ul><li><strong>검증하고 싶은 것</strong><ul><li>음성을 녹음해서 지원하는 방식을 쉽고 편하게 느끼는가?</li></ul></li><li><strong>확인해야 할 것</strong><ul><li>음성 녹음 UI를 보고 어떤 반응을 보이는가?</li><li>녹음 기능을 어려움 없이 사용할 수 있는가?</li><li>질문을 보고 말로 쉽게 대답할 수 있는가?</li></ul></li><li><strong>시나리오</strong><ul><li>OO님은 &#8216;3가지 질문에 답하면 저절로 완성되는 이력서&#8217;라는 배너 광고를 보고 이 화면(첫 화면)으로 왔어요. 다음 버튼을 눌러 실제로 질문에 답해보시겠어요?</li></ul></li></ul>



<p>아이디어는 말 그대로 아이디어일 뿐, 실제로 의미있는 결과를 만들기 위해선 아이디어를 검증하고 수정하는 과정을 계속 반복해야 하는데요. 이때 프로토타입과 UT를 활용하면 검증에 걸리는 시간을 줄일 수 있으니 여러분도 적극 활용하시길 바라요!</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[추천할 때는 제일 좋은 것 하나면 된다]]></title>
            <link>https://toss.tech/article/recommend-just-one</link>
            <guid>https://toss.tech/article/recommend-just-one</guid>
            <pubDate>Thu, 23 Mar 2023 07:43:33 GMT</pubDate>
            <description><![CDATA[제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 사용자에게는 어떤 선택지를 주는 것이 좋을까요? 
]]></description>
            <content:encoded><![CDATA[
<p>제품을 만들 때, 사용자의 고민을 덜어주는 것이 중요해요. 여러 선택지 중에서 고민하다 보면, 쉽게 이탈하게 되니까요. 사용자에게는 너무 많은 선택지보다, 최고의 선택지 하나가 더 좋을 수 있어요. </p>



<p>그렇다면 어떤 것이 최고의 선택지일까요? 혜택이 가장 좋은 것? 다른 사람들이 많이 쓰는 것? 나와 관련이 있는 것? 카드혜택추천 서비스에서 직접 실험하고 발견한 선택지를 알려드릴게요.</p>



<p>카드혜택추천은 이름 그대로 체크/신용카드를 혜택에 따라 추천해주는 서비스예요. 사람들이 많이 쓴 순위를 보여주기도 하고, 혜택 종류별로 보여주거나, 사용자의 소비 내역을 분석해서 딱 맞는 카드를 추천해주기도 해요.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="731" src="https://wp.toss.tech/wp-content/uploads/2023/03/card-00-1024x731.png" alt="" class="wp-image-2065" srcset="https://toss.tech/wp-content/uploads/2023/03/card-00-1024x731.png 1024w, https://toss.tech/wp-content/uploads/2023/03/card-00-300x214.png 300w, https://toss.tech/wp-content/uploads/2023/03/card-00-768x548.png 768w, https://toss.tech/wp-content/uploads/2023/03/card-00.png 1333w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<hr class="wp-block-separator"/>



<h3><strong>문제</strong></h3>



<p>카드혜택추천은 이미 잘 운영되고 있는 제품이었어요. 카드 혜택 TOP 10에서 많은 사용자분들이 좋은 카드를 발급받았고, 매출에 큰 기여를 하고 있었어요. 꾸준한 매출로 기초 체력이 좋은 제품이라고 할 수 있죠. 하지만 폭발적인 성장을 위해서는, 이 기초 체력 위에 좀 더 튼튼한 체력을 더 쌓아올려야 했어요. 그래서, 새로운 카드 신청 맥락을 찾기로 했죠.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="731" src="https://wp.toss.tech/wp-content/uploads/2023/03/card-02-1024x731.png" alt="" class="wp-image-2067" srcset="https://toss.tech/wp-content/uploads/2023/03/card-02-1024x731.png 1024w, https://toss.tech/wp-content/uploads/2023/03/card-02-300x214.png 300w, https://toss.tech/wp-content/uploads/2023/03/card-02-768x548.png 768w, https://toss.tech/wp-content/uploads/2023/03/card-02.png 1333w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<h3><strong>가설</strong></h3>



<p>저희는 이전에 최고의 카드를 추천해주기 위해서 여러가지 실험을 했었어요. 그 중 ‘카드 혜택 TOP 10’으로 전달했을 때 신청율이 가장 높았기 때문에, 그 화면을 유지하고 있었죠.</p>



<p>그런데 지표를 살펴보니, (어쩌면 당연하겠지만) 그 중에서도 1위 카드의 신청율이 압도적이었어요. 카드 이벤트 혜택이 가장 좋기도 했고, 1위라는 단어 자체도 매력적인 요소였던 것 같아요. ‘1위’ 혹은 ‘1등’이라는 단어가 신뢰감과 검증된 느낌을 준다는 생각이 들었어요.</p>



<p>그렇다면 다른 카드 신청 화면에서도 ‘1위’를 적용해볼 수 있겠다 싶었죠.</p>



<h3><strong>해결책</strong></h3>



<p>먼저 토스 홈에 노출되는 배너 문구를 실험했는데, ‘1등 카드 확인하기’의 클릭율이 20%p 높았어요. 아무래도 나에게 딱 맞는 카드라는 게 추상적으로 느껴지기도 했을 것이고, 1등이라는 단어가 후킹하게 느껴졌던 것 같아요.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="380" src="https://wp.toss.tech/wp-content/uploads/2023/03/card-04-1024x380.png" alt="" class="wp-image-2069" srcset="https://toss.tech/wp-content/uploads/2023/03/card-04-1024x380.png 1024w, https://toss.tech/wp-content/uploads/2023/03/card-04-300x111.png 300w, https://toss.tech/wp-content/uploads/2023/03/card-04-768x285.png 768w, https://toss.tech/wp-content/uploads/2023/03/card-04.png 1333w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>다음으로는 카드 순위를 보여주며 추천하는 A안과, 1위 카드 한 개만 보여주는 B안를 비교해보기로 했어요. 저는 당연히 순위를 보여주는 A안이 이길 거라는 생각을 했어요.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="731" src="https://wp.toss.tech/wp-content/uploads/2023/03/card-07-1024x731.png" alt="" class="wp-image-2070" srcset="https://toss.tech/wp-content/uploads/2023/03/card-07-1024x731.png 1024w, https://toss.tech/wp-content/uploads/2023/03/card-07-300x214.png 300w, https://toss.tech/wp-content/uploads/2023/03/card-07-768x548.png 768w, https://toss.tech/wp-content/uploads/2023/03/card-07.png 1333w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<h3><strong>결과</strong></h3>



<p>제 예상과는 다르게 한 개만 보여준 B안이 카드 신청 전환율이 더 좋았어요. 여러개의 카드를 제안하게 되는 경우, 사용자들이 더 많이 고민하게 되었던 것 같아요. 결국 핵심은 선택지를 한 가지만 주는 것이었던 거죠.</p>



<p>(* 사실 각각 컨셉에 맞는 화면을 구성하느라 실험의 변수가 잘 통제되어있진 않았어요. 지금이라면 더 좋은 실험을 설계할 수 있을텐데, 하는 생각도 드네요! )</p>



<hr class="wp-block-separator"/>



<h3><strong>적용해보기</strong></h3>



<p>여러 가지 상품을 추천하는 제품이 있다면 한 개만 강조해보는건 어떨까요? 가장 좋은 선택지를 골라 사용자의 고민을 줄이면, 이탈이 줄어들 거에요.</p>



<p>가장 좋은 선택지처럼 보이게 아이디에이션하는 방법을 알려드릴게요.</p>



<ul><li>사회적 증거를 들어 신뢰감을 준다.<ul><li>토스 회원들이 가장 많이 구매한 상품이에요.</li><li>지금까지 3만명이 구매한 상품이에요.</li><li>리뷰 평점이 가장 좋은 상품을 소개할게요.</li></ul></li><li>사용자의 정보를 활용한다.<ul><li>매일 카페를 가는 김토스님, 카페 할인되는 카드를 만들어보세요.</li><li>30대 여성에게 가장 인기있는 원피스예요.</li><li>송파구에 사는 김토스님, 송파구 방문 1위 맛집이에요.</li></ul></li></ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[tosspayments-restdocs: 선언형 문서 작성 라이브러리]]></title>
            <link>https://toss.tech/article/tosspayments-restdocs</link>
            <guid>https://toss.tech/article/tosspayments-restdocs</guid>
            <pubDate>Wed, 22 Mar 2023 05:29:51 GMT</pubDate>
            <description><![CDATA[REST Docs 를 최소한의 코드로 작성하면서 변화에도 더 유연하게 대처할 수 있는 tosspayments-restdocs 라이브러리와, 라이브러리에 녹인 기술들을 소개합니다.
]]></description>
            <content:encoded><![CDATA[
<h1>tosspayments-restdocs: 선언형 문서 작성 라이브러리</h1>



<p><strong>최소한의 코드로 문서 작성하기</strong></p>



<h2>들어가며</h2>



<p>토스페이먼츠에서는 두 가지 장점 때문에 <a href="https://docs.spring.io/spring-restdocs/docs/current/reference/htmlsingle/">Spring REST Docs</a>를 권장하고 있는데요. 첫 번째는 문서 작성 단계부터 API를 통합 테스트할 수 있다는 점, 두 번째는 인터페이스의 의도치 않은 변경을 감지할 수 있다는 점 때문입니다.</p>



<p>하지만 Spring REST Docs에는 단점도 있습니다. 장황한 코드 때문에 가독성이 떨어지고, 코드 반복으로 인해 생산성이 떨어지는 아쉬움이 있었습니다. 이런 문제를 해소하기 위해 Kotlin DSL을 구현해서 반복적이고 지루한 Spring REST Docs 코드 작성에 필요한 노력을 줄이는 방법을 <a href="https://toss.tech/article/kotlin-dsl-restdocs">한규주님의 이전 글 &#8216;Kotlin으로 DSL 만들기: 반복적이고 지루한 REST Docs 벗어나기&#8217;</a>에서 소개했었습니다.</p>



<p>이번에는 나아가 더 높은 가독성, 더 최소화된 코드 중복, 세부 구현 및 의존성 은닉, 마지막으로 확장에 열려있는 특성을 갖춘 문서화 라이브러리&nbsp;<strong>&#8216;tosspayments-restdocs&#8217;</strong>를 소개하고 개발 후기를 공유합니다.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="807" height="1024" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-1-1-807x1024.png" alt="" class="wp-image-2033" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1-807x1024.png 807w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1-236x300.png 236w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1-768x975.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1-1210x1536.png 1210w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1-1614x2048.png 1614w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1-1568x1990.png 1568w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1.png 1822w" sizes="(max-width: 807px) 100vw, 807px" /><figcaption>동일한 컨트롤러를 Spring REST Docs(좌측)와 tosspayments-restdocs(우측)로 문서화했을 때의 차이. 작성한 문서화 코드의 양이 크게 감소했다.</figcaption></figure>



<h2>다시 살펴보기: Spring REST Docs의 문제들</h2>



<p>Spring REST Docs 기반 문서화 코드의 아쉬운 점을 아래 코드를 통해 다시 한번 살펴볼게요.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="816" height="1024" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-2-1.png" alt="" class="wp-image-2035" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-2-1.png 816w, https://toss.tech/wp-content/uploads/2023/03/Untitled-2-1-239x300.png 239w, https://toss.tech/wp-content/uploads/2023/03/Untitled-2-1-768x964.png 768w" sizes="(max-width: 816px) 100vw, 816px" /></figure>



<p><strong>요청 필드 2개, 응답 필드 3개</strong>로 구성된 단순한 <code>PUT</code> 인터페이스지만, 장황하게 작성된 코드 때문에 전체 구조를 한눈에 파악하기 어렵습니다. 이런 구조의 코드는 처음 작성하는 비용이 많이 들 뿐만 아니라 유지보수 비용도 늘립니다. 위 코드의 문제점을 좀 더 구체적으로 살펴보겠습니다.</p>



<h3>1. <strong>코드 중복</strong></h3>



<p>먼저, 같은 내용이 반복적으로 명세에 포함되어 있습니다. 예를 들어 MockMvcResponse와 REST Docs Snippet을 만들기 위해 Path Variable, 그리고 Request Body Field 코드 중복이 발생했습니다.</p>



<p>또한 Request Body값을 MockMvc에 전달하는 과정에서 샘플 데이터를 통해 필드의 타입 및 샘플이 추론 가능함에도 REST Docs Snippet에 불필요하게 다시 명세하고 있습니다.</p>



<h3>2. <strong>불필요한 명령</strong></h3>



<p><code>given()</code>,&nbsp;<code>prettyPrint()</code>,&nbsp;<code>then()</code>,&nbsp;<code>preprocessRequest()</code>,&nbsp;<code>preprocessResponse()</code>&nbsp;등의 메서드는 인터페이스 명세에 꼭 필요한 핵심이라 하기 어렵습니다. 문서 작성과 관계 없이 빌드에 필요하기 때문에 추가된 사항입니다.</p>



<h3>3. 인터페이스 명세 순서</h3>



<p>실제 HTTP 프로토콜에서는 Request Line → Request Header → Request Body → Response Line → Response Header → Response Body 순으로 페이로드가 만들어집니다.</p>



<p>그러나 위의 예시 코드는 이러한 흐름에 맞춘 자연스러운 명세 작성 대신, MockMvc를 구성하는 기반 기술에 의존하는 명령을 나열하는데 집중하고 있습니다. 그래서 코드를 작성할 때나 읽을 때 모두 코드 블록을 왔다갔다 해야 하는 불편을 겪습니다.</p>



<h3>4. 기반 기술에 강한 의존</h3>



<p>기반 기술에 강하게 의존하고 있기 때문에 기반 기술에 브레이킹 체인지가 생기거나, 유지보수가 중단되면 대응이 어렵습니다.</p>



<p>또, 이렇게 기반 기술에 많이 의존하게 되면 문서를 작성하는 모든 개발자가 기반 기술의 세부 항목을 학습해야 합니다. 가령 MultiPart API, Streaming API, Reactive API 등 다른 형태의 API를 문서화할 때마다 개발자는 사용할 MockMvc의 세부 기능을 각각 학습해야 합니다. 이런 방식은 문서화에 필요한 학습 비용을 높이고 지속적인 대응을 어렵게 만듭니다.</p>



<h1>tosspayments-restdocs로 다시 작성하기</h1>



<p>위 코드를 tosspayments-restdocs 라이브러리를 사용해서 다시 작성한 코드 예시입니다.</p>



<p>생성될 문서를 직관적으로 예측할 수 있고, 기반 기술을 완전히 추상화해서 코드가 절반 이하로 감소했습니다.</p>



<figure class="wp-block-image"><img src="https://wp.toss.tech/wp-content/uploads/2023/03/image-4-1024x579.png" alt="tosspayments-restdocs를 적용한 결과"/><figcaption>tosspayments-restdocs를 적용한 결과</figcaption></figure>



<p>이런 개선점을 만든 tosspayments-restdocs 라이브러리에는 선언형 프로그래밍, 타입 추론 개념이 녹아있는데요. 어떻게 적용됐는지 하나씩 설명해보겠습니다.</p>



<h3>선언형 프로그래밍</h3>



<figure class="wp-block-image size-large"><img loading="lazy" width="609" height="181" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-3-2.png" alt="" class="wp-image-2039" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-3-2.png 609w, https://toss.tech/wp-content/uploads/2023/03/Untitled-3-2-300x89.png 300w" sizes="(max-width: 609px) 100vw, 609px" /><figcaption><a href="https://developer.mozilla.org/en-US/docs/Glossary/Element">https://developer.mozilla.org/en-US/docs/Glossary/Element</a></figcaption></figure>



<p>선언적으로 코드를 작성하는 대표적인 사례는 HTML입니다. HTML에서는 표현하고자 하는 항목을 요소(Element)로 추상화하고, 요소의 태그(Tag), 속성(Attribute), 내용(Content)을 명세해서 최종 결과물을 만듭니다.</p>



<p>같은 방식으로, tosspayments-restdocs에서는 API의 실제 형태(HTTP의 페이로드)를 있는 그대로 표현할 수 있도록 Documentation, Request Line, Request Header, Request Body, Response Body를 요소화했습니다. 이렇게 모든 문서화 항목을 요소로 만들었기 때문에 HTML을 작성하는 방식처럼 선언적으로 문서를 작성할 수 있습니다.</p>



<p>선언적인 작성에는 이런 장점이 있습니다.</p>



<ul><li><strong>명세의 내용에 집중하게 됩니다.</strong> 세부 기술 및 이를 위한 불필요한 명령 없이, 문서화 코드의 본질인 인터페이스 명세에 집중할 수 있습니다.</li><li><strong>꼭 필요한 정보만 명세할 수 있습니다.</strong> 꼭 필요한 항목만 요소의 속성으로 선언하고, 추가적인 속성들은 중괄호를 열어 표현하게 됩니다.</li><li><strong>읽기 쉬운 코드가 됩니다.</strong> 최종 결과물의 실제 형태가 그대로 녹아져 있으므로, 위에서 아래로 한번만 읽으면 결과를 파악할 수 있습니다.</li><li><strong>확장이 쉽습니다.</strong> 새로운 문서화 항목이 생기는 경우 요소를 새로 정의하면 됩니다. 기존 항목에 자식 항목이 새롭게 생기는 경우에도 마찬가지로 대응이 가능합니다.</li><li><strong>구현 방법에서 자유로워집니다.</strong> 각 요소를 어떻게, 무엇으로 렌더링 할 지를 모두 라이브러리에 위임해서 기반 기술의 변화나 결과물의 포맷 변화가 코드에 미치는 영향을 줄일 수 있습니다.</li></ul>



<h3>선언형 프로그래밍 구현 &#8211; 함수와 확장 함수</h3>



<p>tosspayments-restdocs의 문서화 코드 진입점인 <code>documentation</code> 요소 함수를 살펴보겠습니다.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="154" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-4-1-1024x154.png" alt="" class="wp-image-2042" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-4-1-1024x154.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-4-1-300x45.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-4-1-768x116.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-4-1.png 1182w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>documentation 함수 호출 예</figcaption></figure>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="274" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-5-1024x274.png" alt="" class="wp-image-2043" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-5-1024x274.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-5-300x80.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-5-768x205.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-5.png 1100w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>documentation 내부 구현(이해를 돕기 위해 단순화하였습니다)</figcaption></figure>



<p><code>documentation</code>은 문서의 이름(<code>documentName</code>)을 필수 속성으로, <code>requestLine</code> 등 세부 스펙 요소 추가적인 속성으로 취급하는 요소 함수로, 문서화의 시작(문서 스펙 정의)과 끝(문서 출력)을 담당합니다.</p>



<p>앞서 <strong>꼭 필요한 항목만 요소의 속성으로 선언하고, 추가적인 속성들은 중괄호를 열어 표현한다</strong>고 했는데요. 이 개념을 코틀린으로 구현하면서 필수 속성은 함수의 파라미터로, 추가 속성은 람다 함수 파라미터로 표현했습니다. 요소의 모든 속성을 파라미터로 펼쳐두면 함수가 장황해지고 확장성이 떨어지기 때문입니다.</p>



<p>추가 속성을 람다 확장 함수(<a href="https://kotlinlang.org/docs/extensions.html#extension-functions">Extension Function</a>) 스코프 내에서 정의하도록 하면 스코프 내에서 일어나는 일들에는 함수가 관여하지 않습니다. 그래서 편의성을 확보하면서 확장성을 유지할 수 있고, 스코프를 계층화하여 도메인을 더욱 잘 표현할 수 있습니다.</p>



<p>예를 들어 <code>documentation</code> 요소 함수의 람다 확장 함수(<code>specCustomizer: DocumentSpec.() -&gt; Unit</code>) 스코프에서는 <code>RequestLineSpec</code>, <code>RequestBodySpec</code>, <code>ResponseBodySpec</code> 등을 세부 요소 스펙으로 품고 있는 <code>DocumentSpec</code>의 <code>this</code>가 주어집니다. 스코프 및 스코프에 <code>this</code>를 주입하는 이런 방식에는 다음과 같은 장점이 있습니다.</p>



<ul><li><strong>스코프 단위로 특화된 기능을 제공할 수 있습니다.</strong> 예를 들어 <code>requestLine</code> 함수는 <code>DocumentSpec</code>의 세부 요소 스펙인 <code>RequestLineSpec</code>을 정의하기 위한 요소 함수입니다.</li><li><strong>구조화된 확장성을 갖습니다.</strong> 새로운 속성이 추가되었을 때 스코프 내에 함수나 프로퍼티를 추가하여 쉽게 대응할 수 있습니다. 또한 새로운 자식 요소를 갖게 되는 경우에도 동일한 방식으로 람다 확장 함수 스코프를 정의해 대응할 수 있습니다. documentation → requestBody → field 로 이어지는 nested scope 가 그 예입니다.</li></ul>



<h3>타입 추론</h3>



<p>Spring REST Docs의 문제 중 하나는 필드의 타입을 REST Docs Snippet에 다시 명세하는 비효율적인 작성 방식입니다.</p>



<p>Kotlin에서는 Inline Function 한정으로&nbsp;<a href="https://kotlinlang.org/docs/inline-functions.html#reified-type-parameters">Reified Type Parameter</a>를 제공합니다. 타입 정보가 소거되는 일반적인 Generic Function의 Type Parameter와 달리, Reified Type Parameter의 경우에는 타입 정보가 소거되지 않아 라이브러리에서 접근할 수 있습니다.</p>



<p>tosspayments-restdocs에서는 항상 문서화 요소가 샘플을 받게 강제하고, 샘플의 타입과 값을 내부 자료구조에 저장하도록 했습니다.</p>



<figure class="wp-block-image"><img src="https://wp.toss.tech/wp-content/uploads/2023/03/image-6-1024x92.png" alt="sample이 reified T로 선언되어 타입 정보(T::class.java)에 접근이 가능합니다."/><figcaption>sample이 reified T로 선언되어 타입 정보(T::class.java)에 접근이 가능합니다.</figcaption></figure>



<p>타입 정보가 남아있다면 문서를 작성하는 개발자를 대신해 다양한 작업을 자동화 할 수 있습니다. tosspayments-restdocs에서는 타입 명세, 열거형 예시 작성, 포멧 명세 등에 타입 정보를 활용하고 잇습니다.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="267" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-6-1024x267.png" alt="" class="wp-image-2046" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-6-1024x267.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-6-300x78.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-6-768x200.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-6-1536x400.png 1536w, https://toss.tech/wp-content/uploads/2023/03/Untitled-6.png 1542w" sizes="(max-width: 1024px) 100vw, 1024px" /><figcaption>타입 정보 활용 예(타입별 양식 자동생성) – 열거형은 엔트리 나열, 시간 타입은 타임 포멧을 반환</figcaption></figure>



<figure class="wp-block-image"><img src="https://wp.toss.tech/wp-content/uploads/2023/03/image-5-1024x200.png" alt="타입 정보 활용 예(생성된 문서) – 열거형 타입으로부터 얻은 정보로 ResultType의 엔트리(SUCCESS, ERROR)가 자동생성 되었습니다."/><figcaption>타입 정보 활용 예(생성된 문서) – 열거형 타입으로부터 얻은 정보로 ResultType의 엔트리(SUCCESS, ERROR)가 자동생성 되었습니다.</figcaption></figure>



<h1>마치며</h1>



<p>지금까지 문서를 최소한의 코드로 작성하면서 변화에도 더 유연하게 대처할 수 있는 tosspayments-restdocs 라이브러리와, 라이브러리에 녹인 생각들을 소개했습니다.</p>



<p>tosspayments-restdocs는 토스페이먼츠의 다양한 팀에서 Spring REST Docs, kotlin-dsl-restdocs를 대신해 활용하며 생산성을 높이고 있습니다.</p>



<p>개발자가 더욱 변하지 않고 가치있는 일에 집중할 수 있도록, 토스페이먼츠에서는 생산성을 높이기 위한 다양한 활동을 이어나가고 있습니다. 함께 고민하며 더욱 좋은 문화와 기술을 만들어나가면 좋겠습니다.</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[선언적인 코드 작성하기]]></title>
            <link>https://toss.tech/article/frontend-declarative-code</link>
            <guid>https://toss.tech/article/frontend-declarative-code</guid>
            <pubDate>Thu, 16 Mar 2023 12:41:13 GMT</pubDate>
            <description><![CDATA[선언적인 코드, 토스 프론트엔드 챕터는 어떻게 생각을 하고 있을까요?
]]></description>
            <content:encoded><![CDATA[
<p>선언적인 코드(Declarative Code)는 프론트엔드 개발을 하다 보면 자주 만나게 되는 개념입니다. 특히 React 생태계에서 웹 서비스를 개발하다 보면 선언적인 코드에 대해 고민하게 되는데요. 이번 아티클에서는 토스 프론트엔드 챕터에서 생각하는 선언적인 코드란 무엇인지, 그리고 실제로 어떻게 선언적인 코드를 작성하는지 공유해드리려고 합니다.</p>



<h2>선언적인 코드</h2>



<p>토스 프론트엔드 챕터에서는 선언적인 코드를 “추상화 레벨이 높아진 코드”로 생각하고 있습니다. 예를 들어서, 아래와 같이 주어진 배열의 합을 구하는 함수 <code>sum</code> 을 생각해봅시다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-12" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript">sum([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]);</code></div><small class="shcb-language" id="shcb-language-12"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p></p>



<p><code>sum</code> 함수는 아래와 같이 <code>for</code> 문으로 구현할 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-13" data-shcb-language-name="TypeScript" data-shcb-language-slug="typescript"><div><code class="hljs language-typescript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">nums: <span class="hljs-built_in">number</span>[]</span>) </span>{
  <span class="hljs-keyword">let</span> result = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) {
    result += num;
  }

  <span class="hljs-keyword">return</span> result;
}</code></div><small class="shcb-language" id="shcb-language-13"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">TypeScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">typescript</span><span class="shcb-language__paren">)</span></small></pre>


<p>여기에서 <code>sum</code> 함수는 초기값이 0이고, 배열이 가지고 있는 각각의 원소를 순회하면서 결과값에 더하는 작업을 추상화합니다. 덕분에 <code>sum</code> 을 다루는 사람은 복잡한 제어 흐름을 이해할 필요 없이, “배열의 합을 구한다” 라고 하는 동작에 집중하여 함수를 사용할 수 있습니다.</p>



<p>토스는 이렇게 동작에 집중하여 추상화된 <code>sum</code> 함수를 선언적인 코드로 생각하고 있습니다.</p>



<p></p>



<p>여기에서 한 걸음 더 나아가서 <code>sum</code> 함수 내부의 <code>for ... of</code> 문을 살펴봅시다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-14" data-shcb-language-name="TypeScript" data-shcb-language-slug="typescript"><div><code class="hljs language-typescript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> num of nums) {
  <span class="hljs-comment">/* 동작 ... */</span>
}</code></div><small class="shcb-language" id="shcb-language-14"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">TypeScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">typescript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이 제어 흐름도 선언적인 코드로 볼 수 있습니다. 배열이 가지고 있는 각각의 요소를 순회하는 동작을 추상화하고 있기 때문입니다.</p>



<p></p>



<p>실제로 ECMAScript 표준에 따라서 <code>for ... of</code> 가 추상화하는 로직을 그대로 드러내면 아래와 같이 나타낼 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-15" data-shcb-language-name="TypeScript" data-shcb-language-slug="typescript"><div><code class="hljs language-typescript"><span class="hljs-keyword">const</span> iterator = nums[Symbol.iterator]();

<span class="hljs-keyword">let</span> step;

<span class="hljs-keyword">while</span> (!(step = iterator.next()).done) {
  <span class="hljs-keyword">const</span> num = step;
  <span class="hljs-comment">/* 동작 ... */</span>
}</code></div><small class="shcb-language" id="shcb-language-15"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">TypeScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">typescript</span><span class="shcb-language__paren">)</span></small></pre>


<p>위와 같이, <code>for ... of</code> 문은 Iterator를 생성하고, Iterator가 끝날 때까지 다음 요소를 차례차례 가져오는 작업을 “각각의 요소를 순회하는 작업”으로 추상화합니다. 이런 관점에서 봤을 때, <code>for ... of</code> 문은 선언적인 코드입니다.</p>



<p><em>*실제로는 생성된 Iterator를 삭제하는 동작도 존재하므로 보다 추상화되는 로직이 많습니다.</em></p>



<p></p>



<p>코드의 관점을 벗어나면 보다 재미있는 예시를 생각할 수 있습니다.</p>



<p>“왼쪽으로 10걸음 걸어라” 라고 하는 말을 생각합시다. 여기에서</p>



<ul><li>“왼쪽”은 “북쪽을 바라보았을 때 90도 돌아간 위치” 를 추상화한 것입니다.</li><li>“90도”는 “한 번의 회전을 360등분한 각의 90배만큼 시초선에 대해 시계 반대 방향으로 돌아간 것” 을 추상화한 것입니다.</li><li>“시계 방향” 의 정의는 “북반구에서 해시계의 바늘이 돌아가는 방향” 을 추상화한 것입니다.</li></ul>



<p>그래서 “왼쪽으로 10걸음 걸어라”는 사실 “북쪽을 바라보았을 때 한 번의 회전을 360등분한 각의 90배만큼 북반구에서 해시계의 바늘이 돌아가는 방향으로 돌아서, 동물이 육상에서 다리를 이용해 움직이는 가장 빠른 방법보다 느린, 신체를 한 지점에서 다른 지점으로 옮겨가는 행위를 10번 반복해라” 라는 말을 추상화한, 선언적인 말로 볼 수 있을 것입니다.</p>



<p></p>



<h2>좋은 선언적인 코드 작성하기</h2>



<p>위에서 선언적인 코드를 추상화 레벨이 높아진 코드로 살펴보았습니다. 그런데 선언적인 코드는 항상 좋은 것일까요? 토스에서는 추상화가 항상 좋은 것은 아닌 것처럼 선언적인 코드도 잘 쓰는 것이 중요하다고 생각합니다.</p>



<p>토스에서는 좋은 코드를 판단하는 제1원칙을 “수정하기 쉬운 코드”라고 생각합니다. 비즈니스 요구사항은 항상 빠르게 변하기 때문에, 개발자가 기민하게 대응하는 것이 중요하기 때문입니다. 그러면 선언적인 코드가 언제 수정하기 쉽고, 언제 그렇지 않은지 살펴봅시다.</p>



<p></p>



<p>먼저 아래와 같은 회원가입 폼 컴포넌트를 살펴봅시다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-16" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript">&lt;SignUpForm 
  onSubmit={result =&gt; {
    <span class="hljs-comment">/* 회원가입 결과에 따라서 특정 동작 수행 ... */</span>
  }}
/&gt;</code></div><small class="shcb-language" id="shcb-language-16"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>위 컴포넌트는 회원가입 로직을 하나의 컴포넌트로 추상화했기 때문에 선언적인 컴포넌트로 볼 수 있습니다.</p>



<p></p>



<p>이 코드는 수정하기 쉬울까요?</p>



<p>먼저 회원가입 폼을 여러 곳에서 사용한다면 각각의 폼을 중복해서 개발할 필요 없이 한 번만 개발하면 되기 때문에 효율적일 것입니다. 또한 회원가입 폼에 변경이 생긴다고 하더라도, 한 곳에서만 바꾸면 다른 화면들에 모두 반영되기 때문에 빨리 수정할 수 있을 것입니다.</p>



<p></p>



<p>수정하기 어려운 지점은 없을까요?</p>



<p>화면마다 <code>SignUpForm</code> 이 조금씩 다르다면, 공통화된 것이 오히려 코드의 복잡함을 가져올 수도 있습니다. 예를 들어서, 어떤 페이지에서는 SNS 회원가입을 일반 이메일 회원가입보다 먼저 보여줘야 할 수 있습니다. 또, 다른 페이지에서는 텍스트나 스타일을 조금씩 다르게 보여줘야 할 수 있습니다.</p>



<p></p>



<p>아래와 같이 <code>SignUpForm</code> 에서 바뀔 수 있는 부분이 많다면, 내부 구현과 인터페이스도 복잡해지고, 쓰는 쪽에서도 불편할 것입니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-17" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript">&lt;SignUpForm
  signUpOrder={[<span class="hljs-string">'sns'</span>, <span class="hljs-string">'normal'</span>]
  title=<span class="hljs-string">"사이트에 어서 오세요"</span>
  subtitle=<span class="hljs-string">"먼저 회원가입을 해주세요."</span>
  primaryButtonColor={colors.blue}
  secondaryButtonColor={colors.grey}
  <span class="hljs-comment">/* 많은 Prop 들 ... */</span>
  onCancel={<span class="hljs-comment">/* ... */</span>}
  onSubmit={result =&gt; {
    <span class="hljs-comment">/* 회원가입 결과에 따라서 특정 동작 수행 ... */</span>
  }}
/&gt;</code></div><small class="shcb-language" id="shcb-language-17"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이처럼 토스에서는 선언적인 코드가 항상 좋은 것이 아니라, 앞으로 제품이 어떻게 변화할지, 비즈니스 요구사항이 어떻게 되는지에 따라서 달라질 수 있다고 생각하고 있습니다. 앞으로 코드의 어떤 부분이 수정될지 예측하고, 이에 따라 적절한 선언 레벨을 따르는 코드를 작성할 필요가 있습니다.</p>



<p></p>



<h2>토스의 선언적 라이브러리</h2>



<p>그렇다면 다양한 상황에서 일반적으로 사용할 수 있는 좋은 선언적 코드는 없을까요? 이번 아티클은 토스 프론트엔드 챕터가 100개가 넘는 서비스들에서 자주 사용하고 있는 선언적 라이브러리에 대해서 소개하고 마무리하려고 합니다.</p>



<h3>useOverlay</h3>



<div class="wp-block-image"><figure class="aligncenter size-large is-resized"><img loading="lazy" src="https://wp.toss.tech/wp-content/uploads/2023/03/스크린샷-2023-03-16-오후-9.48.58-1024x623.png" alt="" class="wp-image-1744" width="512" height="311" srcset="https://toss.tech/wp-content/uploads/2023/03/스크린샷-2023-03-16-오후-9.48.58-1024x623.png 1024w, https://toss.tech/wp-content/uploads/2023/03/스크린샷-2023-03-16-오후-9.48.58-300x183.png 300w, https://toss.tech/wp-content/uploads/2023/03/스크린샷-2023-03-16-오후-9.48.58-768x467.png 768w, https://toss.tech/wp-content/uploads/2023/03/스크린샷-2023-03-16-오후-9.48.58-1536x935.png 1536w, https://toss.tech/wp-content/uploads/2023/03/스크린샷-2023-03-16-오후-9.48.58-1568x954.png 1568w, https://toss.tech/wp-content/uploads/2023/03/스크린샷-2023-03-16-오후-9.48.58.png 1584w" sizes="(max-width: 512px) 100vw, 512px" /></figure></div>



<p>토스에서는 BottomSheet, Dialog, Toast와 같이 화면 위에 뜨는 오버레이를 띄워야 하는 상황이 많습니다. 토스는 이렇게 오버레이를 띄우는 동작을 추상화하여 <code>useOverlay</code> 라고 하는 Hook 을 사용합니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-18" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-keyword">const</span> overlay = useOverlay();

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span>
  <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> {
    overlay.open(({ isOpen, close }) =&gt; {
      return (
        <span class="hljs-tag">&lt;<span class="hljs-name">BottomSheet</span> <span class="hljs-attr">open</span>=<span class="hljs-string">{isOpen}</span> <span class="hljs-attr">onClose</span>=<span class="hljs-string">{close}</span>&gt;</span>
          나는 바텀시트야
        <span class="hljs-tag">&lt;/<span class="hljs-name">BottomSheet</span>&gt;</span>
      );
    })
  }}
&gt;
  바텀시트 열기
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span></code></div><small class="shcb-language" id="shcb-language-18"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>예를 들어서, 위 코드에서는 <code>바텀시트 열기</code> 버튼을 누르면 <code>나는 바텀시트야</code> 라고 하는 바텀시트를 띄웁니다.</p>



<p></p>



<p><code>useOverlay</code> 가 없었더라면 아래와 같이 제어 흐름이 드러나는 코드를 작성했어야 할 것입니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-19" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-keyword">const</span> [isSheetOpen, setIsSheetOpen] = useState(<span class="hljs-literal">false</span>);

<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">{()</span> =&gt;</span> setIsSheetOpen(true)}&gt;
  바텀시트 열기
<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span>
<span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">BottomSheet</span> <span class="hljs-attr">open</span>=<span class="hljs-string">{isSheetOpen}</span> <span class="hljs-attr">onClose</span>=<span class="hljs-string">{()</span> =&gt;</span> setIsSheetOpen(false)}&gt;
  나는 바텀시트야
<span class="hljs-tag">&lt;/<span class="hljs-name">BottomSheet</span>&gt;</span></span>
</code></div><small class="shcb-language" id="shcb-language-19"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p><code>useOverlay</code>에 대한 자세한 정보는 Slash libraries의 <a href="https://slash.page/ko/libraries/react/use-overlay/src/useoverlay.i18n/">useOverlay Hook</a>을 참고해주세요.</p>



<p></p>



<h3>ImpressionArea</h3>



<p>토스 앱에서는 어떤 영역이 보여졌는지/숨겨졌는지에 따라서 동작하는 로직이 많습니다. 예를 들어서, 사용자가 특정한 요소를 보면 폭죽을 터뜨리거나 토스트를 보여주는 식이죠. 토스에서는 <code>ImpressionArea</code> 라고 하는 컴포넌트로 이를 추상화하고 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-20" data-shcb-language-name="plaintext" data-shcb-language-slug="plaintext"><div><code class="hljs language-plaintext">&lt;ImpressionArea onImpressionStart={() =&gt; { /* 보여졌을 때 실행 */ }}&gt;
  &lt;div&gt;내가 보여졌으면 onImpressionStart가 실행돼&lt;/div&gt;
&lt;/ImpressionArea&gt;
</code></div><small class="shcb-language" id="shcb-language-20"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">plaintext</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">plaintext</span><span class="shcb-language__paren">)</span></small></pre>


<p><code>ImpressionArea</code> 가 없었더라면, 복잡한 <code>IntersectionObserver</code> API 를 사용하거나, 복잡한 Scroll 이벤트 핸들러 로직을 사용해야 했을 것입니다.</p>



<p><code>ImpressionArea</code> 에 대한 자세한 정보는 Slash libraries의 <a href="https://slash.page/libraries/react/impression-area/src/impressionarea.i18n/">ImpressionArea 컴포넌트</a>를 참고해주세요.</p>



<p></p>



<h3>LoggingClick</h3>



<p>토스에서는 데이터 주도 의사결정을 위해서 화면에 진입하는 사용자가 몇 명인지, 그 중 몇 명이 버튼을 누르는지를 기록하는 경우가 있습니다. 이런 누르는 동작에 대한 기록을 추상화하여 <code>LoggingClick</code> 컴포넌트를 사용하고 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-21" data-shcb-language-name="plaintext" data-shcb-language-slug="plaintext"><div><code class="hljs language-plaintext">&lt;LoggingClick params={{ price }}&gt;
  &lt;button onClick={buy}&gt;사기&lt;/button&gt;
&lt;/LoggingClick&gt;
</code></div><small class="shcb-language" id="shcb-language-21"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">plaintext</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">plaintext</span><span class="shcb-language__paren">)</span></small></pre>


<p>예를 들어서, 위 코드에서 사용자가 버튼을 누르면 “사기” 버튼에 대한 동작이 분석 시스템에 기록됩니다.</p>



<p><code>LoggingClick</code> 이 없었다면 아래와 같이 <code>log</code> 함수를 실행하는 것이 그대로 드러났어야 할 것입니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-22" data-shcb-language-name="plaintext" data-shcb-language-slug="plaintext"><div><code class="hljs language-plaintext">&lt;button
  onClick={() =&gt; {
    log({ title: '사기', price });
    buy();
  }}
&gt;
  사기
&lt;/button&gt;
</code></div><small class="shcb-language" id="shcb-language-22"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">plaintext</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">plaintext</span><span class="shcb-language__paren">)</span></small></pre>]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[토스 디자인 원칙 Value first, Cost later]]></title>
            <link>https://toss.tech/article/value-first-cost-later</link>
            <guid>https://toss.tech/article/value-first-cost-later</guid>
            <pubDate>Thu, 16 Mar 2023 09:49:46 GMT</pubDate>
            <description><![CDATA[토스의 제품 디자인 원칙 중에는 Value first, cost later라는 항목이 있어요. 비용을 말하기 전에 가치를 명확하게 전달해야한다는 내용이에요. 가치를 먼저 보여주는 것 만으로도 지표를 눈에 띄게 개선한 사례를 소개해드릴게요.
]]></description>
            <content:encoded><![CDATA[
<p>토스의 제품 디자인 원칙 중에는 Value first, cost later라는 항목이 있어요. 비용을 말하기 전에 가치를 명확하게 전달해야한다는 내용이에요. </p>



<p>언뜻 생각하면 당연해 보이는 내용이지만, 종종 해야 할 액션을 설명하는 것에 집중한 나머지 가치를 생략하고 사용자에게 결정이나 비용을 지불할 것을 요구하곤 해요.</p>



<p>가치를 먼저 보여주는 것 만으로도 지표를 눈에 띄게 개선한 사례를 소개해드릴게요.</p>



<p></p>



<h3><strong>배경</strong></h3>



<p>오늘 소개해드릴 서비스는 ‘내 보험’인데요. 내가 가입한 모든 보험을 한 번에 조회해주는 서비스예요. 토스에는 여러 조회 서비스들이 있어요. 예를 들면 내 계좌 모아보기, 신용 점수 조회, 내게 맞는 대출 찾기 같은 서비스예요.  </p>



<p>&#8216;내 보험&#8217;은 기존 보험 조회 경험을 매우 편하게 만들어준 서비스예요. 만약 오프라인에서 내가 가입한 보험 내역을 알아보려면, 보험사에 전화해서 가입자 본인 확인 후에 이메일로 받아보아야 했어요. 하지만 토스에서는 몇 가지 정보만 입력하면 조회를 할 수 있었죠.</p>



<p>오프라인보다는 편해지기는 했지만, 토스의 다른 조회 서비스와 비교했을 때는 훨씬 불편했어요. ‘내 보험’은 핸드폰 문자 인증, 이메일 인증, 캡챠, 비밀번호 설정 등 여러 차례 인증을 거쳐야만 했거든요. 다른 조회 서비스들은 질문 3,4개 정도만 답해도 조회가 가능했기 때문에 비교가 됐죠.</p>



<p></p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="262" src="https://wp.toss.tech/wp-content/uploads/2023/03/asis-1024x262.png" alt="" class="wp-image-1718" srcset="https://toss.tech/wp-content/uploads/2023/03/asis-1024x262.png 1024w, https://toss.tech/wp-content/uploads/2023/03/asis-300x77.png 300w, https://toss.tech/wp-content/uploads/2023/03/asis-768x196.png 768w, https://toss.tech/wp-content/uploads/2023/03/asis-1536x393.png 1536w, https://toss.tech/wp-content/uploads/2023/03/asis-2048x524.png 2048w, https://toss.tech/wp-content/uploads/2023/03/asis-1568x401.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<h3><strong>문제</strong></h3>



<p>실제로 이 퍼널을 뚫고 조회를 완료한 사람의 비율은 매우 낮았어요. </p>



<p>토스를 쓰는 사용자들은 매끄러운 경험에 익숙해져있었어요. 그런 사용자들에게 갑자기 긴 퍼널을 지나가라고 하니 매우 견디기 어려웠겠죠.</p>



<p>사용자들은 ‘내 보험’ 탭에 들어오자마자 바로 가입한 보험들이 보였으면 했어요. 그런데 바로 보험이 보이지도 않는데, 긴 조회 과정을 거치게 하니 인내심을 잃고 포기했죠. 심지어 토스 팀원분들 중에서도 포기하는 분이 많았으니 문제가 심각하다고 생각했어요.</p>



<p></p>



<h3><strong>가설</strong></h3>



<p>문제를 해결하기 위해, <strong>어떤 가치를 얻을 수 있는지 미리 보여주면 지루한 과정도 마칠 수 있을 것</strong>이란 가설을 세웠어요.</p>



<p>당시 ‘내 보험’팀은 끔찍히 긴 조회 과정이 문제라고 생각했어요. 그래서 이 퍼널을 어떻게 하면 개선할 수 있을지에 대해 고민했죠. 하지만 조회 과정을 우리가 줄일 수는 없었어요. 왜냐하면 이 퍼널은 토스 내부에서 만드는 게 아니라, 보험을 조회하는 기관의 시스템을 이용했기 때문이죠.</p>



<p>어떻게 할지 고민하면서, 여러 실험과 유저 인터뷰를 진행했어요. 그러면서 몰랐던 사실을 알게 됐죠. 보험에 관심있는 사용자들 대부분은 나와 비슷한 연령대의 다른 사람들은 어떻게 보험을 들었는지 궁금해했어요. 보험료는 얼마인지, 어떤 보험을 가입했는지, 보장금액은 얼마나 준비했는지 등이요.</p>



<p>우리가 분명히 줄 수 있는 가치인데, 조회라는 허들을 넘지 못해서 그 가치를 보여주지 못한다는 게 너무 안타까웠어요. 그러다 ‘어떤 가치를 얻을 수 있는지 미리 보여주면 어떨까?’라는 생각을 하게 된 거예요.</p>



<p></p>



<h3><strong>해결</strong></h3>



<p>가설을 검증하기 위해, 사용자가 조회 퍼널을 시작하기 전에 얻을 수 있는 가치를 먼저 보여주기로 했어요.</p>



<p>긴 퍼널이 기다리고 있기 때문에, 가치를 아주 명료하게 보여줘야겠다고 생각했죠. 명료하게 보여준다는 말은 충분히 구체적이면서 이해하기 쉬워야 한다는 뜻이에요. 사용자가 얻게 될 이익을 체감할 수 있을 정도로요. </p>



<p>예를 들어 배달앱을 켜서 치킨을 고르고 있는 상황이라면, 30%할인이라는 말보다는 치킨 5000원 할인이 더 와닿을 수 있어요. 사용자가 내 보험의 이익을 체감하려면, 구체적으로 상상할 수 있게 조회 화면을 먼저 보여주어야겠다 생각했죠. 아직 조회 전이라 사용자 데이터가 없기 때문에 더미 데이터를 넣은 화면을 조회 시작하기 전에 보여주기로 했어요.</p>



<p>사용자는 보험료를 비교한 그래프를 보고, 본인의 보험료도 또래와 비교해서 볼 수 있다는 가치를 상상할 수 있게 되었어요.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="987" height="1024" src="https://wp.toss.tech/wp-content/uploads/2023/03/to-be22-987x1024.png" alt="" class="wp-image-1719" srcset="https://toss.tech/wp-content/uploads/2023/03/to-be22-987x1024.png 987w, https://toss.tech/wp-content/uploads/2023/03/to-be22-289x300.png 289w, https://toss.tech/wp-content/uploads/2023/03/to-be22-768x797.png 768w, https://toss.tech/wp-content/uploads/2023/03/to-be22-1480x1536.png 1480w, https://toss.tech/wp-content/uploads/2023/03/to-be22-1974x2048.png 1974w, https://toss.tech/wp-content/uploads/2023/03/to-be22-1568x1627.png 1568w" sizes="(max-width: 987px) 100vw, 987px" /></figure>



<p></p>



<h3><strong>결과</strong></h3>



<p>이 화면을 넣었더니, 조회를 끝내는 사용자 비율이 기존보다 67%나 높아졌어요.</p>



<p>얻을 수 있는 가치를 확실하게 체감하고 나니, 지루한 과정을 참고 조회를 끝까지 한 거죠. 조회하는 과정을 건드리지 않고, 앞단에서 화면 하나를 추가한 것 만으로도 엄청난 상승폭을 만들어낸 거죠. 정말 놀라웠어요.</p>



<p>단계를 줄여서 비용을 낮춰야겠다고만 생각했었는데, 가치를 먼저 이야기하는 것이 얼마나 강력한지 알게 된 실험이었어요.</p>



<p></p>



<h3><strong>적용해보기</strong></h3>



<p>혹시 사용자에게 행동을 유도하기 위해서, 무작정 요청하고 있지는 않나요?</p>



<p>“지금 보험을 조회하세요”, “신용점수를 알아보세요”처럼요. 물론 무슨 액션을 해야 하는지 알려주는 것도 중요하지만, 왜 사용자가 그 액션을 해야하는지 설명해주는 것도 정말 중요해요. 사용자는 처음 만난 화면에서 얻게될 이익과 지불할 비용을 본능적으로 저울질하거든요. </p>



<p>지금 디자인 하는 화면 중에 비용이 유독 큰 화면이 있진 않은지 한 번 점검해보세요. 예를 들어 오늘 사례처럼, 정보를 입력받는 화면의 비용을 확인해보는 방법이 있어요. 이 질문들을 해보고 비용이 높다고 판단된다면, 그만큼의 밸류를 먼저 알려주는 게 좋죠.</p>



<ul><li>질문이 3,4개 이상이면 사용자는 지치기 시작해요.</li><li>5초 내에 답변하기 어려운 질문이라면 사용자가 고민하게 만들어요. (까다로운 비밀번호 조건이나 이메일 주소 등)</li><li>민감한 질문을 받았을 때 거부감이 커질 수 있어요. 예를 들면 개인 정보에 가까울 수록 입력할 때 비용이 커지는 거죠. (연봉 정보 등)</li></ul>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[디자이너가 새로운 도메인을 빠르게 학습하는 법]]></title>
            <link>https://toss.tech/article/how-to-learn-new-domain</link>
            <guid>https://toss.tech/article/how-to-learn-new-domain</guid>
            <pubDate>Tue, 07 Mar 2023 05:56:37 GMT</pubDate>
            <description><![CDATA[토스는 일이 굉장히 빠르게 돌아가는 조직이에요. 저는 1년 반 동안 무려 4개의 새로운 분야를 학습해야 했어요. 이때 제가 쓴 방법들을 알려드릴게요.
]]></description>
            <content:encoded><![CDATA[
<p>저는 토스가 첫 금융권 회사예요. 그래서 입사하기 전에 굉장히 긴장을 했었죠. 왜냐하면 토스는 일이 굉장히 빠르게 돌아가는 조직이라고 들었는데, 금융이라는 새로운 분야를 빠르게 학습하고 따라갈 수 있을지 걱정이 됐거든요.</p>



<p>아니나 다를까, 1년 반 동안 무려 4개의 새로운 분야를 학습해야 했어요. 제한된 시간 안에서 결과물을 내려면 쏟아지는 정보를 빠르게 학습해야 했어요. 하지만 그게 어려운 상황들이 늘 있었죠.</p>



<p></p>



<h3><strong>문제</strong></h3>



<p><strong>온보딩할 때 많은 정보를 빠르게 익히는 것이 어렵다.</strong></p>



<p>4개의 분야를 만나며, 각 분야의 방대한 정보와 그것을 빠르게 익혀야 하는 상황은 정말 힘들었어요. 해야 할 일과 이해의 범위가 정해져 있고, 작았던 이전 조직과 다른 상황이었죠. 이후 회고했을 때 저는 주로 2가지의 실수를 반복하고 있었던 것 같아요.</p>



<p><strong>실수 1 &#8211; 모든 정보를 사실로 받아들이기</strong></p>



<p>설명해 주시는 분들도 간혹 오류가 있는 정보나, 개인의 생각이 반영된 정보를 주시는 경우도 많았어요. 처음 도메인을 만났을 때는 이런 부분들을 명확히 구분하기가 어려웠어요. <strong>온보딩 과정 중 대부분을 ‘사실’로 인지하고 문제를 해결하려고 했어요.</strong> 결국 디자인 단계에서 채워지지 않은 근거나 이해하기 어려운 논리를 발견하고 다시 처음으로 돌아가고는 했어요.</p>



<p></p>



<p><strong>실수 2 &#8211; 모든 것을 이해하려고 하기</strong></p>



<p><em>‘개념부터 완벽히 이해하면, 답은 저절로 찾게 될 거야’</em></p>



<p>대한민국에서 교육과정을 겪었던 분이라면, 꼭 한번은 들었던 이야기일 것 같아요. 제가 당시 선택했던 전략이었고, 틀린 방법은 아니라고 생각해요. 하지만 저를 기다리는 동료들과, 그 상황에서도 커져가고 있을 문제를 두고 여유롭게 학습하는 것은 비효율이었어요. 당시 저는 이 상황을 이해하지 못하고, 데스크 리서치를 필요 이상으로 갖기 시작했어요. 무엇부터 이해해야 할지 모르니 전부 다 이해해 보겠다는 마음이었죠. 논문까지 찾아보며, 시간 비용을 그대로 낭비하고 있었어요.</p>



<p>이 문제를 해결하지 않으면 계속해서 병목이 될 것 만 같았어요. 항상 억지로 이해하고, 길게 다시 돌아가서 전제를 바로잡거나, 설명자의 주관적인 판단은 반박 or 싱크를 했어요. 혹은 대차게 실패를 경험한 후에 깊은 회고를 하기도 했죠. </p>



<p>이런 식으로 문제가 될 때마다 돌아가는 방법은 제 문제를 본질적으로 해결해 주지는 못했어요. 저는 되돌아가기 보다 나아가고 싶었기 때문인 것 같아요. 과거의 경험들을 바탕으로 문제를 정의하고 해결할 가설을 세웠어요.</p>



<p></p>



<h3><strong>가설 </strong></h3>



<p><strong>‘온보딩, 싱크, 일을 동시에 할 수 있지 않을까?’</strong></p>



<p>처음부터 모든 것을 이해하기보다 필요한 것부터 이해할 방법을 찾고, 설명을 들으며 동시에 그 정보를 검증하는 것. 그리고 일까지 함께 할 방법이 있을 것 같았어요. 그리고 그 가설을 여러 방법으로 실행에 옮겨 보았어요.</p>



<p></p>



<h3><strong>해결책</strong></h3>



<p><strong>1. 내가 모르는 부분을 관찰해 줄 조력자 만들기</strong></p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="338" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-1024x338.png" alt="" class="wp-image-1682" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-1024x338.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-300x99.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-768x253.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1536x506.png 1536w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1568x517.png 1568w, https://toss.tech/wp-content/uploads/2023/03/Untitled.png 1784w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>처음부터 모든 것을 이해할 수 있는 것은 비효율임을 인정하고, 필요한 정보부터 이해할 필요가 있었어요. 하지만 제게 필요한 정보를 어떻게 찾을 수 있을까요? 초심자는 자신이 무엇을 모르는지 조차 알 수 없어요. 이에 도움받기 위해서는. <strong>내 무지 상태를 지속적으로 관찰해 줄 조력자가 필요했어요.</strong> 동료를 활용한 메타인지인 것이죠. 동료들도 제게 기대하는 결과가 있기 때문에, 현재 상황에서 필요한 정보부터 강조하여 말해줄 가능성이 높아요. 이때는 몰랐지만, 이 방식이 토스의 코어 밸류인 Learn Proactively의 일환임을 알게 됐어요.</p>



<p></p>



<p><strong>2. 들은 내용 그자리에서 직접 설명해보기</strong></p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="338" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-1-1024x338.png" alt="" class="wp-image-1683" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1024x338.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-300x99.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-768x254.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1536x507.png 1536w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-2048x676.png 2048w, https://toss.tech/wp-content/uploads/2023/03/Untitled-1-1568x518.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>앞서 말씀드렸던 ‘설명 받는 정보에 오류가 있거나 개인의 생각이 담겨있을 때’의 어려움과 내가 모르는 부분을 더 발견할 수 있는 방법이에요. <strong>저는 온보딩 중에 제가 직접 다시 설명해 보기로 했어요</strong>. 화이트보드를 이용해서요. 학생인 제가 직접 가르치는 입장이 돼보는 것이죠. 이 방식은 유대인의 교육 법인 ‘하브루타’와 유사한 방식이었어요.</p>



<p><em>*하브루타 &#8211; 짝을 이뤄 서로 질문을 주고받으면서 공부한 것에 대해 논쟁하는 정통 유대교 교리를 공부하는 유대인의 전통적인 토론 교육 방법</em></p>



<p>이 방식으로 제 생각과 설명자의 주장에 싱크를 맞추어 ‘정보의 오류’나 ‘가치 판단 영역’을 구분할 수 있었어요. 대부분 제 설명에서 부족한 정보는 바로바로 채워주시고, 논점이 발견되면 그 자리에서 이야기하고 싱크 할 수 있게 됐어요. 덧붙여서 이때 ‘설명이 막히는 곳’, ‘반박 당하는 곳’을 놓치지 않고 이야기하는 것이 중요한 것 같아요. 몰랐던 부분일 확률이 높고, 논쟁을 벌어야 하는 영역일 가능성이 높아요.</p>



<p></p>



<p><strong>3. 틀릴 것을 전제로 디자인하기</strong></p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="337" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-2-1024x337.png" alt="" class="wp-image-1684" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-2-1024x337.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-2-300x99.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-2-768x253.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-2-1536x506.png 1536w, https://toss.tech/wp-content/uploads/2023/03/Untitled-2-2048x675.png 2048w, https://toss.tech/wp-content/uploads/2023/03/Untitled-2-1568x517.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>아마도 2번이 제대로 진행된 이후라면 대부분의 제품디자이너 머릿속엔 어떤 그림이 나오기 시작할거에요. 2번 이후 간단히 문제와 가설을 정의한 후, 이해한 버전을 그대로 그림을 그려 관계자와 사용자에게 보여주는 방법이에요. <strong>이전에 서로 이해가 달랐던 부분을 디자이너의 그림을 통해 빨리 맞춰갈 수 있어요.</strong></p>



<p>제 경험상 이 때 나왔던 그림이 완전히 틀렸던 경우는 한번도 없었어요. 1~2번의 과정을 거쳐오며 많은 부분 싱크가 되었기 때문이죠. 수정하거나, 고민해야할 부분은 일부였고 전반적인 얼개는 맞았던 기억이 있어요. 이렇게 되었다면, 일은 거의 동시에 진행된거라 보아도 무관할 것 같아요.</p>



<p></p>



<h3><strong>결과</strong></h3>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="339" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-3-1024x339.png" alt="" class="wp-image-1685" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-3-1024x339.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-3-300x99.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-3-768x255.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-3-1536x509.png 1536w, https://toss.tech/wp-content/uploads/2023/03/Untitled-3-2048x679.png 2048w, https://toss.tech/wp-content/uploads/2023/03/Untitled-3-1568x520.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="339" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-4-1024x339.png" alt="" class="wp-image-1686" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-4-1024x339.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-4-300x99.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-4-768x255.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-4-1536x509.png 1536w, https://toss.tech/wp-content/uploads/2023/03/Untitled-4-2048x679.png 2048w, https://toss.tech/wp-content/uploads/2023/03/Untitled-4-1568x520.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>가설을 세우고, 새로운 방식으로 도메인을 이해하기 시작한 후와, 과거를 비교해 보았어요. 먼저 온보딩부터 첫 디자인 단계를 만나는 시점이 앞당겨졌어요. 그리고 다시 돌아가기보다는 나아가는 방식이 되었죠. 대부분의 단계를 동시에 하게 되니. 절대적인 시간도 줄어들고, 길었던 데스크 리서치 기간도 상당 부분 줄어들게 됐어요. 가장 좋았던 것은 오류 없는 가설로 만든 디자인을 사용자에게 더 빨리 테스트해 볼 수 있다는 점이었어요.</p>



<p>복잡한 도메인을 맞닥뜨리는 작업자라면 누구나 막막함을 경험하셨을 것 같아요. 이런 부분들을 적극적으로 채워주실 수 있는 동료분들이 있고, 몇 가지의 방법만 활용한다면 어떤 도메인을 만나도 필요한 정보를 빠르게 습득할 수 있을 것 같아요.</p>



<p>특히나 데이터 정합성이 중요한 도메인이라면, 초기에 얻은 정보에 bias가 생기지 않도록 관계자와 최대한 싱크를 하는 것이 중요한 것 같아요. 정확히 싱크 되지 않은 채로 탄생한 디자인은 결국 사용자의 문제를 뾰족하게 해결할 수 없게 되고, 개선하는 데에 많은 시간이 걸리게 되기 때문이에요.</p>



<p></p>



<h3><strong>적용해보기</strong></h3>



<p>진행하기 전에 꼭 염두 해야 할 점.<br>&#8211; 모든 정보들이 ‘가치 중립적’인지 생각해 보기.<br>&#8211; 많은 것을 이해하기 보다 필요한 것부터 이해하기.</p>



<ol><li>내가 모르는 부분을 관찰해줄 조력자 만들기.<ul><li>식사, 커피챗처럼 캐주얼한 자리에서 예고하기.</li><li>팀 내에서 직무별로 조력자 만들기. (도메인, 테크)</li><li>예 : ‘데이터 구조에 대해 모르는 것이 많아요. 앞으로 자주 물어보게 될 것 같은데 괜찮을까요?’ → 99%는 “언제든지 물어봐 주세요!”라고 답변 받음.</li></ul></li><li>들은 내용. 그자리에서 직접 설명해보기<ul><li>설명이 틀릴까 봐 긴장된다면, 말하기 전에 양해 구하기.</li><li>예 : “처음 듣는 정보들이라, 많이 틀리겠지만. 들은 내용들을 설명해 볼게요.”</li></ul></li><li>틀릴 것을 전제로 디자인하기<ul><li>생각이 다른 부분을 중점으로 이야기달라고 말하기.</li><li>이 디자인은 완성된 것이 아님을 공유하고, 논의 시작하기.</li></ul></li></ol>



<p>자꾸만 되돌아가게 되는 단계, 방대하고 어려워보이는 도메인 때문에 어려움을 겪고 계신다면, 이 방법들을 사용해보시면 어떨까요?</p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[문제 원인의 원인을 찾아서]]></title>
            <link>https://toss.tech/article/real-reason</link>
            <guid>https://toss.tech/article/real-reason</guid>
            <pubDate>Thu, 02 Mar 2023 08:40:06 GMT</pubDate>
            <description><![CDATA[좋은 해결책을 내기 위해서 제가 쓰는 방법은, 문제 원인의 원인을 찾는 거예요. 진짜 문제를 발견하면, 임팩트 있는 해결책을 생각해 낼 확률이 훨씬 높아지죠. 
]]></description>
            <content:encoded><![CDATA[
<p>토스 팀원이면 누구나 개인 법인 카드를 1장씩 가지고 있어요. 이 카드로 식대나 택시비, 교육비 등 업무와 관련된 것이라면 자율적인 판단 하에 결제할 수 있어요. 자유롭게 사용하되, 모바일 또는 PC로 어디에 사용했는지 그 용도와 내역을 적어 제출해야 해요. 재무팀에서 그 내용을 바탕으로 매달 법인 카드 결산 업무를 해야 하거든요.</p>



<p></p>



<p></p>



<h3><strong>문제</strong></h3>



<p>매달 반복되는 이 업무에 큰 문제가 있었어요. 바로 <span style="color:#ed2121" class="has-inline-color">마감 기한 내에 영수증을 제출하지 않는 팀원이 40%가 넘는다</span>는 것인데요. 재무팀에서는 법인 카드 결산을 해야 하는 일정이 있고 미작성된 영수증을 허위로 적을 수 없기 때문에 기한을 어긴 팀원들 한명 한명에게 메세지를 보내 얼른 적어달라고 부탁을 해야 했죠.</p>



<p>이 비효율적인 일을 매달 반복해야 한다니, 그냥 지나칠 수 없겠죠?</p>



<p></p>



<p></p>



<h3><strong>가설</strong></h3>



<p>그럼 팀원들은 왜 마감 기한을 지키지 못할까요? 팀원들이 실제로 영수증을 적는 모습을 관찰하고 인터뷰하며 이런 가설을 세웠어요.</p>



<p><span style="color:#ed2121" class="has-inline-color">영수증을 쓰는 과정이 너무 불편해서 미루다가 기한을 놓친다.</span></p>



<p>평균적으로 하루에 한 번 정도 법인 카드를 사용한다고 했을 때, 한 달에 약 20개의 영수증이 생겨요. 결제를 하고 영수증을 바로 적으면 1분이 채 걸리지 않지만 앱을 켜는 순간부터 답답하고 불편해서 나중에 적어야지 미루게 되고, 몰아서 한번에 적으려고 하니 어디에 썼나 기억도 잘 안나고 양도 많아져서 오래 걸리고&#8230; 그러다가 결국 마감 기한을 놓치게 된다고 생각했어요.</p>



<p></p>



<p></p>



<h3><strong>해결</strong></h3>



<p>그럼 이 제품은 왜 사용이 불편했을까요? 영상을 보면서 어떤 점이 불편한지 한번 찾아보시겠어요?</p>



<h4>첫 번째로, 식대 영수증을 적는 모습을 녹화한 영상인데요.</h4>



<figure class="wp-block-video"><video controls src="https://wp.toss.tech/wp-content/uploads/2023/03/1.mp4"></video></figure>



<p>문제가 보이시나요? 사실 이것만으로는 뭐가 문제인지 알기가 어려워요. 실제로 팀원들이 영수증을 적는 모습을 관찰할 땐 영상처럼 1개가 아니라 여러 개를 적는 모습을 봐야 해요. 그리고 한 사람이 아니라 여러 사람을 관찰해야 하고요. 그래야 여러 명이 반복적으로 겪는 불편함이 무엇인지 파악할 수 있고 비로소 문제가 뾰족해지기 시작하거든요.</p>



<p>저는 3명 정도 관찰했고 매월 팀원들의 법인 카드 사용 내역이 적힌 엑셀 시트도 몇 달치를 쭉 훑어봤어요. 여러분은 아래 시트에서 어떤 점이 눈에 띄세요?</p>



<p></p>



<p></p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="337" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-21-1024x337.png" alt="" class="wp-image-1643" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-21-1024x337.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-21-300x99.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-21-768x253.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-21.png 1458w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p>모두가 ‘식대’ 영수증을 적은 건데 사용 내역이 제각각이었어요. 작성 가이드가 있긴 했지만 이걸 아는 사람도 있고 모르는 사람도 있었어요. 그래서 그냥 각자가 아는 방식으로 다양하게 적게 된 것이죠. </p>



<p>이렇게 저마다 다르게 쓰는데 사용내역이라는 게 재무팀에게 정말 의미 있는 데이터일까요? 이를 확인하기 위해 재무팀에서 꼭 받아야 하는 정보와 이유를 물어봤고 ‘먹은 사람의 이름만 정확하게 적으면 된다’는 답변을 받았어요.</p>



<p>정리하면, 사용자 인터뷰와 시트에서 발견한 식대 영수증의 문제는 이런 것들이었어요.</p>



<p></p>



<p><strong>사용성 문제</strong></p>



<ul><li>어차피 대부분이 식대인데 계정 과목(사용용도)을 매번 선택해야 함</li><li>같이 먹는 사람이 항상 비슷한데 매번 새롭게 적어야 함</li><li>점심, 식대, 재택 등 굳이 적지 않아도 될 내용들을 몰라서 매번 적고 있음</li></ul>



<p><strong>데이터 문제</strong></p>



<ul><li>같이 먹은 사람의 이름을 적지 않거나 정확한 이름을 적지 않음(성이나 동명이인 구분용 알파벳을 빼고 적음)</li></ul>



<p><strong>여러분이라면</strong>, <strong>이 문제를 어떻게 해결하시겠어요?</strong></p>



<figure class="wp-block-video"><video controls src="https://wp.toss.tech/wp-content/uploads/2023/03/2.mp4"></video></figure>



<ul><li>결제처가 음식을 파는 업종일 때, 사용용도를 식대로 자동 선택해주기</li><li>사용내역을 자유롭게 적는 것이 아닌, 꼭 적어야 하는 식사한 사람 이름만 선택할 수 있게 바꾸기</li><li>내 이름은 기본으로 적어주기</li><li>최근에 같이 먹은 사람 리스트 보여주기</li><li>팀원의 이름을 직접 적는게 아니라 검색 &gt; 선택으로 바꿔서 정확한 이름 받기</li></ul>



<p>선택하거나 적어야 할 항목을 최소화하기 위해 가능한 것들은 자동화했고 사용자로부터 받아야 하는 정보를 정확하게 받을 수 있는 장치를 넣었어요.</p>



<p></p>



<p></p>



<h4>두 번째로, 많은 영수증인 야근택시비를 적는 과정을 볼게요.</h4>



<figure class="wp-block-video"><video controls src="https://wp.toss.tech/wp-content/uploads/2023/03/3.mp4"></video></figure>



<p>택시 앱의 결제 방식을 아는 분이라면 이번 영상에서는 무엇이 문제인지 캐치하셨을 것 같아요. 바로 택시는 1번 탔는데 영수증은 3개가 생긴다는 점인데요. </p>



<p>앱으로 택시를 부르던 경험을 한번 떠올려보세요. 출발지와 목적지를 선택하면 예상 금액이 나오죠? 택시를 잡으면 그 금액으로 일단 결제가 돼요. 그리고 도착지에서 내리면 최종 금액으로 다시 결제가 되고 이전에 결제했던 건은 취소가 돼죠. </p>



<p>그래서 영수증이 3개나 생기는데요. 문제는 이 3개를 처리하는 과정이 영상에서 보신 것처럼 너무 번거로운거죠. </p>



<p>그리고 사용 내역 역시 식대처럼 다양한 형태로 적고 계셨어요.</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="341" src="https://wp.toss.tech/wp-content/uploads/2023/03/IMG_1882-1024x341.png" alt="" class="wp-image-1667" srcset="https://toss.tech/wp-content/uploads/2023/03/IMG_1882-1024x341.png 1024w, https://toss.tech/wp-content/uploads/2023/03/IMG_1882-300x100.png 300w, https://toss.tech/wp-content/uploads/2023/03/IMG_1882-768x256.png 768w, https://toss.tech/wp-content/uploads/2023/03/IMG_1882-1536x512.png 1536w, https://toss.tech/wp-content/uploads/2023/03/IMG_1882-2048x683.png 2048w, https://toss.tech/wp-content/uploads/2023/03/IMG_1882-1568x523.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p></p>



<p>야근 교통비는 사용 내역을 구체적으로 적을 필요 없다는 재무팀의 의견을 받아 이렇게 해결했어요.</p>



<figure class="wp-block-video"><video controls src="https://wp.toss.tech/wp-content/uploads/2023/03/4.mp4"></video></figure>



<ul><li>선결제와 취소 영수증은 시스템에서 알아서 처리하고 사용자에게는 최종 영수증만 보여주기</li><li>결제처가 택시 앱이고 결제시간이 22시~06시 사이면 사용 용도와 사용 내역을 모두 야근 교통비로 자동 선택, 적어주기</li><li>영수증 상세 페이지에 진입하지 않아도 자동으로 적힌 내용이 맞는지 확인하고 빠르게 제출할 수 있도록 숏컷 제공하기</li></ul>



<p>모든 것을 자동화했고 제출 전 오류가 없는지 확인할 수 있도록 사용자의 최종 컨펌 단계만 남겨두었어요.</p>



<p></p>



<p></p>



<h3><strong>결과</strong></h3>



<p>앞에서 마감 기한을 놓치는 팀원이 약 <span style="color:#ed2121" class="has-inline-color">40%</span>가 된다고 했던 것 기억하시나요? 제품 개선 이후 이 비율이 무려 <span style="color:#ed2121" class="has-inline-color">5%</span>로 줄었어요. 95%의 팀원들이 제때 영수증을 낸다는 것이죠. 그 결과 재무팀의 커뮤니케이션 비용도 그만큼 줄일 수 있었어요. </p>



<p>해결책이 그렇게 대단하거나 특별한 게 아님에도 효과는 엄청나지 않나요?</p>



<figure class="wp-block-image size-large"><img loading="lazy" width="1024" height="462" src="https://wp.toss.tech/wp-content/uploads/2023/03/Untitled-23-1024x462.png" alt="" class="wp-image-1648" srcset="https://toss.tech/wp-content/uploads/2023/03/Untitled-23-1024x462.png 1024w, https://toss.tech/wp-content/uploads/2023/03/Untitled-23-300x135.png 300w, https://toss.tech/wp-content/uploads/2023/03/Untitled-23-768x347.png 768w, https://toss.tech/wp-content/uploads/2023/03/Untitled-23-1536x693.png 1536w, https://toss.tech/wp-content/uploads/2023/03/Untitled-23-2048x924.png 2048w, https://toss.tech/wp-content/uploads/2023/03/Untitled-23-1568x707.png 1568w" sizes="(max-width: 1024px) 100vw, 1024px" /></figure>



<p></p>



<p></p>



<h3><strong>적용해보기</strong></h3>



<p>좋은 해결책을 내기 위해서 제가 쓰는 방법은, <strong>문제 원인의 원인</strong>을 찾는 거예요.</p>



<ol><li>해결해야 하는 문제를 한 문장으로 적는다.<ul><li>예: 마감 기한 내에 영수증을 제출하지 않는 팀원이 40%가 넘는다.</li></ul></li><li>문제에 계속 질문을 하고 답을 한다.<ul><li>예: 왜 마감 기한을 놓치지? 한 달치를 한 번에 적으려다 보니 너무 많아서 → 왜 한 달치를 한번에 적지? 그때 그때 적기 귀찮아서 → 왜 적기 귀찮지? → 영수증 쓰는 게 불편해서 → 왜 불편하지? → 적어야 할 게 많아서 → 왜 적어야 할 게 많지? → 식대도 선택해야 되고 같이 먹은 사람도 적어야 되니까 → 꼭 적어야 되는 정보인 건 맞아? → 적어야 하는 정보인 건 맞아 → 그럼 왜 직접 적어야 하지? 자동으로 적어줄 순 없어?…</li></ul></li></ol>



<p>이렇게 질문을 반복하다 보면 근본적인 문제를 발견할 수 있어요. 일단 이 문제를 발견하고 나면, 임팩트 있는 해결책을 생각해 낼 확률이 훨씬 높아지죠. </p>



<p>내가 내는 해결책이 항상 그저 그렇다 싶으면, 이 방법을 써보시는 건 어떨까요?</p>



<p></p>
]]></content:encoded>
        </item>
        <item>
            <title><![CDATA[똑똑하게 브라우저 Polyfill 관리하기]]></title>
            <link>https://toss.tech/article/smart-polyfills</link>
            <guid>https://toss.tech/article/smart-polyfills</guid>
            <pubDate>Sat, 21 Jan 2023 03:52:16 GMT</pubDate>
            <description><![CDATA[현대적인 JavaScript를 쓰면서도 넓은 범위의 기기를 지원하기 위한 Polyfill을 어떻게 똑똑하게 설정할 수 있는지 소개합니다.
]]></description>
            <content:encoded><![CDATA[
<p>토스 앱은 넓은 범위의 기기를 지원하면서도 현대적인 JavaScript를 이용해서 개발되고 있습니다. 그렇지만 최신 JavaScript를 오래된 브라우저 위에서 실행하기 위해서는 “Polyfill” 문제를 해결해야 하는데요.</p>



<p>이번 아티클에서는 Polyfill 문제가 무엇인지 알아보고, 토스에서 어떻게 똑똑하게 다루고 있는지 살펴보려고 합니다.</p>



<h2>Polyfill이란?</h2>



<p>오래된 버전의 브라우저에서는 현재 JavaScript가 당연하게 사용하고 있는 <code>Promise</code>나 <code>Set</code> 객체가 없는 경우가 있습니다. 편리한 <a href="https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Array/at">Array.prototype.at()</a> API는 Chrome 92 이상에서만 지원되기도 합니다.</p>



<p>예를 들어서, 아래와 같은 코드는 최신 브라우저에서는 잘 동작하지만, 오래된 브라우저에서는 실패합니다. 객체나 메서드에 대한 구현이 없기 때문이죠.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-23" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].at(<span class="hljs-number">-1</span>);

<span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);

<span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);</code></div><small class="shcb-language" id="shcb-language-23"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이런 문제를 해결하기 위해서는 오래된 브라우저에서 없는 구현을 채워주어야 합니다. 이렇게 구현을 채워주는 스크립트를 <strong>Polyfill</strong>이라고 합니다. 대부분의 Polyfill은 아래와 같이 이미 브라우저에 포함되어 있는지 체크하고, 없으면 값을 채워주는 형태로 동작합니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-24" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-built_in">Array</span>.prototype.at = <span class="hljs-built_in">Array</span>.prototype.at ?? <span class="hljs-comment">/* Array.prototype.at에 대한 자체 구현 */</span>;
</code></div><small class="shcb-language" id="shcb-language-24"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>위 스크립트를 실행한 이후에는, 오래된 브라우저에서도 안전하게 <code>[1, 2, 3].at(-1)</code> 코드를 실행할 수 있습니다.</p>



<p>표준적으로 사용되는 Polyfill들은 <a href="https://github.com/zloirock/core-js">core-js 리포지토리</a>에 모여 있습니다. 아래 코드를 실행하면 대부분의 ECMAScript 표준 객체와 메서드를 오래된 브라우저에서도 사용할 수 있게 됩니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-25" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-string">'core-js/actual'</span>;</code></div><small class="shcb-language" id="shcb-language-25"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<h2>Polyfill의 문제</h2>



<p>위와 같이 코드를 작성하면 폭넓은 브라우저를 지원할 수 있다는 장점이 있지만 문제가 하나 생깁니다. 불러와야 하는 JavaScript 코드가 많아진다는 점입니다. 실행해야 하는 Polyfill 스크립트가 많아질수록 사용자가 경험하는 웹 서비스의 성능은 나빠집니다.</p>



<p>특히, 위와 같이 설정하면 최신 버전의 브라우저에서는 대부분의 ECMAScript 표준 객체와 메서드가 포함되어 있음에도 불구하고 불필요한 Polyfill 스크립트를 내려받아야 합니다. 꼭 필요한 Polyfill 스크립트만 선택적으로 불러올 수 있는 방법은 없을까요?</p>



<h2>첫 번째 방법: @babel/preset-env 사용하기</h2>



<p>이 문제를 해결하기 위해 사용할 수 있는 첫 번째 방법은 <a href="https://babeljs.io/docs/en/babel-preset-env">@babel/preset-env</a> Smart Preset을 사용하는 것입니다. 이 Smart Preset은 이미 정의된 브라우저 목록에 따라서 자동으로 필요 없는 Polyfill을 제거해 줍니다.</p>



<p>예를 들어서, 웹 페이지가 Internet Explorer 11을 지원해야 한다면 아래와 같이 <code>babel.config.js</code> 를 설정할 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-26" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">presets</span>: [
    [<span class="hljs-string">'@babel/preset-env'</span>, { <span class="hljs-attr">targets</span>: { <span class="hljs-attr">ie</span>: <span class="hljs-number">11</span> } }],
  ],
  <span class="hljs-comment">/* 그 외의 설정 */</span>
};
</code></div><small class="shcb-language" id="shcb-language-26"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이후에 동일하게 <code>core-js/actual</code> 을 import 하더라도 Internet Explorer 11에 필요한 Polyfill 목록만 포함되는 것을 확인할 수 있습니다. 총 221개의 Polyfill이 포함됩니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-27" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-comment">// 입력 코드</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'core-js/actual'</span>;</code></div><small class="shcb-language" id="shcb-language-27"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>

<pre class="wp-block-code" aria-describedby="shcb-language-28" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-comment">// 출력 코드</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.symbol.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.symbol.description.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.symbol.async-iterator.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.symbol.has-instance.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.symbol.is-concat-spreadable.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.symbol.iterator.js"</span>);
<span class="hljs-comment">// ... 계속 (총 221개의 Polyfill)</span></code></div><small class="shcb-language" id="shcb-language-28"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p><a href="https://babeljs.io/repl/#?browsers=ie%2011&amp;build=&amp;builtIns=entry&amp;corejs=3.21&amp;spec=false&amp;loose=false&amp;code_lz=JYWwDg9gTgLgBAcgMbQKYFoBWBnA9AQyRgFd8AbBAbiA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=env&amp;prettier=false&amp;targets=&amp;version=7.20.12&amp;externalPlugins=&amp;assumptions=%7B%7D">Babel playground</a></p>



<p>Internet Explorer 11을 지원 브라우저 목록에서 제외하면 훨씬 적은 25개의 Polyfill이 포함됩니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-29" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-built_in">module</span>.exports = {
  <span class="hljs-attr">presets</span>: [
    [<span class="hljs-string">'@babel/preset-env'</span>, { <span class="hljs-attr">targets</span>: <span class="hljs-string">'defaults, not ie 11'</span> }],
  ],
  <span class="hljs-comment">/* 그 외의 설정 */</span>
};</code></div><small class="shcb-language" id="shcb-language-29"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>

<pre class="wp-block-code" aria-describedby="shcb-language-30" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-comment">// 입력 코드</span>
<span class="hljs-keyword">import</span> <span class="hljs-string">'core-js/actual'</span>;</code></div><small class="shcb-language" id="shcb-language-30"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>

<pre class="wp-block-code" aria-describedby="shcb-language-31" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-comment">// 출력 코드</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.error.cause.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.aggregate-error.cause.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.array.at.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.array.includes.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.object.has-own.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.regexp.flags.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.string.at-alternative.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/es.typed-array.at.js"</span>);
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core-js/modules/esnext.array.find-last.js"</span>);
<span class="hljs-comment">// ... 계속 (총 25개의 Polyfill)</span>
</code></div><small class="shcb-language" id="shcb-language-31"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p><a href="https://babeljs.io/repl/#?browsers=defaults%2C%20not%20ie%2011&amp;build=&amp;builtIns=entry&amp;corejs=3.21&amp;spec=false&amp;loose=false&amp;code_lz=E4UwjgrglqAUDkBjA9qAtAKwM4HoCGiALhHgDbwCUA3EA&amp;debug=false&amp;forceAllTransforms=false&amp;shippedProposals=false&amp;circleciRepo=&amp;evaluate=false&amp;fileSize=false&amp;timeTravel=false&amp;sourceType=module&amp;lineWrap=true&amp;presets=env&amp;prettier=false&amp;targets=&amp;version=7.20.12&amp;externalPlugins=&amp;assumptions=%7B%7D">Babel playground</a></p>



<p>이렇게 <code>@babel/preset-env</code>에 브라우저 지원 범위를 설정하면 Polyfill을 안정적으로 포함하면서 스크립트의 크기를 감축할 수 있습니다.</p>



<h2>두 번째 방법: User-agent에 따라 동적으로 스크립트 생성하기</h2>



<p>Babel을 올바르게 설정함으로써 포함되는 Polyfill 스크립트의 크기를 줄일 수 있지만, 최신 버전의 브라우저에서 불필요한 스크립트를 내려받게 되는 문제는 동일합니다. 예를 들어서, Chrome 최신 버전은 문제없이 <code>[1, 2, 3].at(-1)</code> 을 실행할 수 있지만, 관련한 Polyfill 스크립트를 내려받습니다. </p>



<p>이 문제를 해결하는 또다른 방법은 브라우저의 User-agent에 따라서 동적으로 Polyfill 스크립트를 생성하는 것입니다.</p>



<p>예를 들어서, Financial Times에서 관리하고 있는 <a href="http://polyfill.io">polyfill.io</a> 서비스에서는 <a href="https://polyfill.io/v3/polyfill.min.js">https://polyfill.io/v3/polyfill.min.js</a> 라고 하는 경로로 동적인 Polyfill 스크립트를 제공합니다.</p>



<p>최신 버전의 Chrome에서 해당 경로에 접속하면, 아무 Polyfill 스크립트도 내려오지 않는다는 것을 알 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-32" data-shcb-language-name="Shell Session" data-shcb-language-slug="shell"><div><code class="hljs language-shell"><span class="hljs-meta">$</span><span class="bash"> curl -XGET <span class="hljs-string">"https://polyfill.io/v3/polyfill.min.js"</span> \</span>
   -H "User-Agent: Mozilla/5.0 (Linux; Android 6.0; Nexus 5 Build/MRA58N) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/109.0.0.0 Mobile Safari/537.36" \
   -v
/* 빈 스크립트 */</code></div><small class="shcb-language" id="shcb-language-32"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Shell Session</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">shell</span><span class="shcb-language__paren">)</span></small></pre>


<p>반대로, Internet Explorer 11에서 실행하면 많은 양의 Polyfill 스크립트가 내려온다는 것을 알 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-33" data-shcb-language-name="Shell Session" data-shcb-language-slug="shell"><div><code class="hljs language-shell"><span class="hljs-meta">$</span><span class="bash"> curl -XGET <span class="hljs-string">"https://polyfill.io/v3/polyfill.min.js"</span> \</span>
   -H "User-Agent: Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko" \
   -v
(function(self, undefined) {!function(t){t.DocumentFragment=function n(){return document.createDocumentFragment() # ...</code></div><small class="shcb-language" id="shcb-language-33"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">Shell Session</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">shell</span><span class="shcb-language__paren">)</span></small></pre>


<p>이렇게 User-agent에 따라 동적으로 Polyfill 스크립트를 생성하면 최신 브라우저에서는 아무 Polyfill도 내려주지 않고, 오래된 브라우저에서는 필요한 Polyfill 만 내려줄 수 있게 됩니다. ✨  브라우저가 꼭 필요한 Polyfill 스크립트만 내려받을 수 있는 것이죠.</p>



<h3>자체 Polyfill 서비스 구축하기</h3>



<p>토스에서는 <a href="http://polyfill.io">polyfill.io</a> 서비스를 그대로 사용할 수도 있었지만, Financial Times가 제공하는 Polyfill 중 일부가 ECMAScript 표준대로 작동하지 않아 오류가 발생한 경험이 있어서 자체적으로 구현했습니다.</p>



<p><code>core-js</code> 와 <code>core-js-compat</code>, <code>browserslist-useragent</code> 라이브러리를 사용하면 손쉽게 동적인 Polyfill을 제공하는 Node.js 서버를 만들 수 있었습니다.</p>



<p>먼저, User-agent에 따라서 필요한 core-js polyfill 목록을 계산하기 위해서 아래와 같은 <code>getCoreJSPolyfillList</code> 함수를 작성할 수 있습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-34" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { resolveUserAgent } <span class="hljs-keyword">from</span> <span class="hljs-string">'browserslist-useragent'</span>;
<span class="hljs-keyword">import</span> compat <span class="hljs-keyword">from</span> <span class="hljs-string">'core-js-compat'</span>;

<span class="hljs-comment">/**
 * userAgent에 따라 필요한 Polyfill의 목록을 반환합니다.
 * e.g. ['es.symbol', 'es.symbol.description', 'es.symbol.async-iterator']
 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getCoreJSPolyfillList</span>(<span class="hljs-params">userAgent: string</span>) </span>{
  <span class="hljs-keyword">try</span> {
    <span class="hljs-keyword">const</span> result = resolveUserAgent(userAgent);
    <span class="hljs-keyword">const</span> majorVersion = parseMajorVersion(result.version);

    <span class="hljs-keyword">return</span> compat({
      <span class="hljs-attr">targets</span>: <span class="hljs-string">`<span class="hljs-subst">${result.family}</span> &gt;= <span class="hljs-subst">${majorVersion}</span>`</span>,
      <span class="hljs-attr">version</span>: coreJSVersion,
    }).list;
  } <span class="hljs-keyword">catch</span> {
    <span class="hljs-comment">// 일반적이지 않은 User-Agent인 경우</span>
    <span class="hljs-keyword">return</span> compat({
      <span class="hljs-attr">targets</span>: <span class="hljs-string">'IE &gt;= 11'</span>,
      <span class="hljs-attr">version</span>: coreJSVersion,
    }).list;
  }
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">parseMajorVersion</span>(<span class="hljs-params">versionString: string</span>) </span>{
  <span class="hljs-keyword">const</span> match = versionString.match(<span class="hljs-regexp">/^(\\d+)\\.*/</span>);

  <span class="hljs-keyword">if</span> (match == <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">return</span> versionString;
  }

  <span class="hljs-keyword">return</span> match[<span class="hljs-number">1</span>];
}
</code></div><small class="shcb-language" id="shcb-language-34"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이제 필요한 Polyfill 리스트를 하나의 스크립트로 만들면 됩니다. 토스에서는 <code>esbuild</code> 를 이용하여 core-js 스크립트를 하나로 이어붙이는 방법을 선택했습니다.</p>


<pre class="wp-block-code" aria-describedby="shcb-language-35" data-shcb-language-name="JavaScript" data-shcb-language-slug="javascript"><div><code class="hljs language-javascript"><span class="hljs-keyword">import</span> { build } <span class="hljs-keyword">from</span> <span class="hljs-string">'esbuild'</span>;

<span class="hljs-comment">/*
 * userAgent에 맞는 완성된 Polyfill 스크립트를 생성한다.
 */</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">buildPolyfillScript</span>(<span class="hljs-params">userAgent: string</span>) </span>{
  <span class="hljs-keyword">const</span> script = getCoreJSPolyfillScript(userAgent);

  <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> build({
    <span class="hljs-attr">stdin</span>: {
      <span class="hljs-attr">contents</span>: script,
      <span class="hljs-attr">loader</span>: <span class="hljs-string">'js'</span>,
    },
    <span class="hljs-attr">target</span>: <span class="hljs-string">'es5'</span>, 
    <span class="hljs-attr">bundle</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">minify</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-attr">write</span>: <span class="hljs-literal">false</span>,
  });

  <span class="hljs-keyword">return</span> result.outputFiles[<span class="hljs-number">0</span>].contents;
}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">createCoreJSPolyfillScript</span>(<span class="hljs-params">userAgent: string</span>) </span>{
  <span class="hljs-keyword">return</span> getCoreJSPolyfillList(userAgent)
    <span class="hljs-comment">/* 실험적인 esnext 기능은 제외합니다. */</span>
    .filter(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> !x.startsWith(<span class="hljs-string">'esnext.'</span>))
    .map(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-string">`import "core-js/modules/<span class="hljs-subst">${item}</span>";`</span>)
    .join(<span class="hljs-string">'\\n'</span>);
};
</code></div><small class="shcb-language" id="shcb-language-35"><span class="shcb-language__label">Code language:</span> <span class="shcb-language__name">JavaScript</span> <span class="shcb-language__paren">(</span><span class="shcb-language__slug">javascript</span><span class="shcb-language__paren">)</span></small></pre>


<p>이제 이 함수를 Node.js 서버에 포함시키거나, Lambda@Edge, Compute@Edge 와 같은 Edge Runtime에 포함하면 손쉽게 나만의 Polyfill 서버를 띄울 수 있습니다.</p>



<h2>마치며</h2>



<p>토스팀에서는 자체 제작한 Polyfill 시스템을 이용하여 최신 JavaScript API는 마음껏 활용하면서도 오래된 버전의 브라우저도 빠짐없이 지원할 수 있었습니다.</p>



<p>글을 마무리하면서, 글의 내용을 요약해보자면 아래와 같습니다.</p>



<ul><li>Polyfill이란 신규 JavaScript API를 오래된 버전의 브라우저에서도 사용할 수 있도록 하는 방법입니다. 그렇지만, Polyfill 스크립트가 많아지면 웹 성능이 나빠집니다.</li><li>Babel의 @babel/preset-env 스마트 프리셋을 이용하여 포함할 Polyfill 스크립트의 범위를 지정할 수 있습니다. 다만, 이 경우에도 최신 브라우저는 오래된 브라우저를 위한 Polyfill을 내려받습니다.</li><li>User-agent에 따라 동적으로 Polyfill 스크립트를 생성할 수 있습니다. 이로써 최신 브라우저에서 내려받는 Polyfill 스크립트를 거의 없게 만들 수 있습니다.</li></ul>
]]></content:encoded>
        </item>
    </channel>
</rss>