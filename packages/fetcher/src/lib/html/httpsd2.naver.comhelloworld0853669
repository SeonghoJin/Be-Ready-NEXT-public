<!DOCTYPE html><html lang="ko"><head><script src="https://connect.facebook.net/ko_KR/sdk.js?hash=7e899826b14713274cda099ad43b215a" async="" crossorigin="anonymous"></script>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge">
    <meta name="viewport" content="width=device-width,initial-scale=1.0,minimum-scale=1.0,maximum-scale=1.0">

    <title>Kafka NetworkClient Internals</title>

    <link rel="stylesheet" type="text/css" href="/static/XEIcon/xeicon.min.css">
    <link rel="stylesheet" type="text/css" href="/static/katex/katex.min.css">
    <link rel="stylesheet" type="text/css" href="/static/css/naver_d2.from_server.css?1671783335538">
<link href="/static/css/app.css?13c1e9311ca34225bfc0" rel="stylesheet"><script type="text/javascript" charset="utf-8" src="https://ssl.pstatic.net/static.cbox/js/cbox.core.js?v=1399068"></script><style type="text/css" id="_cbox_default_style_"></style><script type="text/javascript" src="https://ssl.pstatic.net/static.cbox/20230309172524/js/cbox.all.js" charset="utf-8"></script><link type="text/css" rel="stylesheet" href="https://static-feedback.pstatic.net/css/cbox/cbox/ebb46c9a-246d-48cd-acc6-cf3892caf38d/3ed9c21a-1c97-4c94-aeeb-70cc581fb6a5/css/comment_default.css" charset="utf-8"><style type="text/css" data-fbcssmodules="css:fb.css.base css:fb.css.dialog css:fb.css.iframewidget css:fb.css.customer_chat_plugin_iframe">.fb_hidden{position:absolute;top:-10000px;z-index:10001}.fb_reposition{overflow:hidden;position:relative}.fb_invisible{display:none}.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:'lucida grande', tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}.fb_reset>div{overflow:hidden}@keyframes fb_transform{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}.fb_animate{animation:fb_transform .3s forwards}
.fb_hidden{position:absolute;top:-10000px;z-index:10001}.fb_reposition{overflow:hidden;position:relative}.fb_invisible{display:none}.fb_reset{background:none;border:0;border-spacing:0;color:#000;cursor:auto;direction:ltr;font-family:'lucida grande', tahoma, verdana, arial, sans-serif;font-size:11px;font-style:normal;font-variant:normal;font-weight:normal;letter-spacing:normal;line-height:1;margin:0;overflow:visible;padding:0;text-align:left;text-decoration:none;text-indent:0;text-shadow:none;text-transform:none;visibility:visible;white-space:normal;word-spacing:normal}.fb_reset>div{overflow:hidden}@keyframes fb_transform{from{opacity:0;transform:scale(.95)}to{opacity:1;transform:scale(1)}}.fb_animate{animation:fb_transform .3s forwards}
.fb_dialog{background:rgba(82, 82, 82, .7);position:absolute;top:-10000px;z-index:10001}.fb_dialog_advanced{border-radius:8px;padding:10px}.fb_dialog_content{background:#fff;color:#373737}.fb_dialog_close_icon{background:url(https://connect.facebook.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 0 transparent;cursor:pointer;display:block;height:15px;position:absolute;right:18px;top:17px;width:15px}.fb_dialog_mobile .fb_dialog_close_icon{left:5px;right:auto;top:5px}.fb_dialog_padding{background-color:transparent;position:absolute;width:1px;z-index:-1}.fb_dialog_close_icon:hover{background:url(https://connect.facebook.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -15px transparent}.fb_dialog_close_icon:active{background:url(https://connect.facebook.net/rsrc.php/v3/yq/r/IE9JII6Z1Ys.png) no-repeat scroll 0 -30px transparent}.fb_dialog_iframe{line-height:0}.fb_dialog_content .dialog_title{background:#6d84b4;border:1px solid #365899;color:#fff;font-size:14px;font-weight:bold;margin:0}.fb_dialog_content .dialog_title>span{background:url(https://connect.facebook.net/rsrc.php/v3/yd/r/Cou7n-nqK52.gif) no-repeat 5px 50%;float:left;padding:5px 0 7px 26px}body.fb_hidden{height:100%;left:0;margin:0;overflow:visible;position:absolute;top:-10000px;transform:none;width:100%}.fb_dialog.fb_dialog_mobile.loading{background:url(https://connect.facebook.net/rsrc.php/v3/ya/r/3rhSv5V8j3o.gif) white no-repeat 50% 50%;min-height:100%;min-width:100%;overflow:hidden;position:absolute;top:0;z-index:10001}.fb_dialog.fb_dialog_mobile.loading.centered{background:none;height:auto;min-height:initial;min-width:initial;width:auto}.fb_dialog.fb_dialog_mobile.loading.centered #fb_dialog_loader_spinner{width:100%}.fb_dialog.fb_dialog_mobile.loading.centered .fb_dialog_content{background:none}.loading.centered #fb_dialog_loader_close{clear:both;color:#fff;display:block;font-size:18px;padding-top:20px}#fb-root #fb_dialog_ipad_overlay{background:rgba(0, 0, 0, .4);bottom:0;left:0;min-height:100%;position:absolute;right:0;top:0;width:100%;z-index:10000}#fb-root #fb_dialog_ipad_overlay.hidden{display:none}.fb_dialog.fb_dialog_mobile.loading iframe{visibility:hidden}.fb_dialog_mobile .fb_dialog_iframe{position:sticky;top:0}.fb_dialog_content .dialog_header{background:linear-gradient(from(#738aba), to(#2c4987));border-bottom:1px solid;border-color:#043b87;box-shadow:white 0 1px 1px -1px inset;color:#fff;font:bold 14px Helvetica, sans-serif;text-overflow:ellipsis;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0;vertical-align:middle;white-space:nowrap}.fb_dialog_content .dialog_header table{height:43px;width:100%}.fb_dialog_content .dialog_header td.header_left{font-size:12px;padding-left:5px;vertical-align:middle;width:60px}.fb_dialog_content .dialog_header td.header_right{font-size:12px;padding-right:5px;vertical-align:middle;width:60px}.fb_dialog_content .touchable_button{background:linear-gradient(from(#4267B2), to(#2a4887));background-clip:padding-box;border:1px solid #29487d;border-radius:3px;display:inline-block;line-height:18px;margin-top:3px;max-width:85px;padding:4px 12px;position:relative}.fb_dialog_content .dialog_header .touchable_button input{background:none;border:none;color:#fff;font:bold 12px Helvetica, sans-serif;margin:2px -12px;padding:2px 6px 3px 6px;text-shadow:rgba(0, 30, 84, .296875) 0 -1px 0}.fb_dialog_content .dialog_header .header_center{color:#fff;font-size:16px;font-weight:bold;line-height:18px;text-align:center;vertical-align:middle}.fb_dialog_content .dialog_content{background:url(https://connect.facebook.net/rsrc.php/v3/y9/r/jKEcVPZFk-2.gif) no-repeat 50% 50%;border:1px solid #4a4a4a;border-bottom:0;border-top:0;height:150px}.fb_dialog_content .dialog_footer{background:#f5f6f7;border:1px solid #4a4a4a;border-top-color:#ccc;height:40px}#fb_dialog_loader_close{float:left}.fb_dialog.fb_dialog_mobile .fb_dialog_close_icon{visibility:hidden}#fb_dialog_loader_spinner{animation:rotateSpinner 1.2s linear infinite;background-color:transparent;background-image:url(https://connect.facebook.net/rsrc.php/v3/yD/r/t-wz8gw1xG1.png);background-position:50% 50%;background-repeat:no-repeat;height:24px;width:24px}@keyframes rotateSpinner{0%{transform:rotate(0deg)}100%{transform:rotate(360deg)}}
.fb_iframe_widget{display:inline-block;position:relative}.fb_iframe_widget span{display:inline-block;position:relative;text-align:justify}.fb_iframe_widget iframe{position:absolute}.fb_iframe_widget_fluid_desktop,.fb_iframe_widget_fluid_desktop span,.fb_iframe_widget_fluid_desktop iframe{max-width:100%}.fb_iframe_widget_fluid_desktop iframe{min-width:220px;position:relative}.fb_iframe_widget_lift{z-index:1}.fb_iframe_widget_fluid{display:inline}.fb_iframe_widget_fluid span{width:100%}
.fb_mpn_mobile_landing_page_slide_out{animation-duration:200ms;animation-name:fb_mpn_landing_page_slide_out;transition-timing-function:ease-in}.fb_mpn_mobile_landing_page_slide_out_from_left{animation-duration:200ms;animation-name:fb_mpn_landing_page_slide_out_from_left;transition-timing-function:ease-in}.fb_mpn_mobile_landing_page_slide_up{animation-duration:500ms;animation-name:fb_mpn_landing_page_slide_up;transition-timing-function:ease-in}.fb_mpn_mobile_bounce_in{animation-duration:300ms;animation-name:fb_mpn_bounce_in;transition-timing-function:ease-in}.fb_mpn_mobile_bounce_out{animation-duration:300ms;animation-name:fb_mpn_bounce_out;transition-timing-function:ease-in}.fb_mpn_mobile_bounce_out_v2{animation-duration:300ms;animation-name:fb_mpn_fade_out;transition-timing-function:ease-in}.fb_customer_chat_bounce_in_v2{animation-duration:300ms;animation-name:fb_bounce_in_v2;transition-timing-function:ease-in}.fb_customer_chat_bounce_in_from_left{animation-duration:300ms;animation-name:fb_bounce_in_from_left;transition-timing-function:ease-in}.fb_customer_chat_bounce_out_v2{animation-duration:300ms;animation-name:fb_bounce_out_v2;transition-timing-function:ease-in}.fb_customer_chat_bounce_out_from_left{animation-duration:300ms;animation-name:fb_bounce_out_from_left;transition-timing-function:ease-in}.fb_invisible_flow{display:inherit;height:0;overflow-x:hidden;width:0}@keyframes fb_mpn_landing_page_slide_out{0%{margin:0 12px;width:100% - 24px}60%{border-radius:18px}100%{border-radius:50%;margin:0 24px;width:60px}}@keyframes fb_mpn_landing_page_slide_out_from_left{0%{left:12px;width:100% - 24px}60%{border-radius:18px}100%{border-radius:50%;left:12px;width:60px}}@keyframes fb_mpn_landing_page_slide_up{0%{bottom:0;opacity:0}100%{bottom:24px;opacity:1}}@keyframes fb_mpn_bounce_in{0%{opacity:.5;top:100%}100%{opacity:1;top:0}}@keyframes fb_mpn_fade_out{0%{bottom:30px;opacity:1}100%{bottom:0;opacity:0}}@keyframes fb_mpn_bounce_out{0%{opacity:1;top:0}100%{opacity:.5;top:100%}}@keyframes fb_bounce_in_v2{0%{opacity:0;transform:scale(0, 0);transform-origin:bottom right}50%{transform:scale(1.03, 1.03);transform-origin:bottom right}100%{opacity:1;transform:scale(1, 1);transform-origin:bottom right}}@keyframes fb_bounce_in_from_left{0%{opacity:0;transform:scale(0, 0);transform-origin:bottom left}50%{transform:scale(1.03, 1.03);transform-origin:bottom left}100%{opacity:1;transform:scale(1, 1);transform-origin:bottom left}}@keyframes fb_bounce_out_v2{0%{opacity:1;transform:scale(1, 1);transform-origin:bottom right}100%{opacity:0;transform:scale(0, 0);transform-origin:bottom right}}@keyframes fb_bounce_out_from_left{0%{opacity:1;transform:scale(1, 1);transform-origin:bottom left}100%{opacity:0;transform:scale(0, 0);transform-origin:bottom left}}@keyframes slideInFromBottom{0%{opacity:.1;transform:translateY(100%)}100%{opacity:1;transform:translateY(0)}}@keyframes slideInFromBottomDelay{0%{opacity:0;transform:translateY(100%)}97%{opacity:0;transform:translateY(100%)}100%{opacity:1;transform:translateY(0)}}</style></head>

<body>
<div id="wrap" class="main"><div><div id="header"><div class="main_lnb"><div class="progress_bar" style="height: 2px; background-color: rgb(50, 205, 160); width: 0px;"></div><div class="header_sec"><div class="inner_sec"><div class="lnb" id="lnb"><h1><a class="lnb_top_logo" href="/home"><span class="blind">naver D2</span></a></h1><div class="menu_sec"><div class="btn_lnb_menu"><a href="#"><span class="blind">메뉴</span></a></div><div style="height: 0px; transition: all 0.5s ease 0s;"><ul><li class="on"><a href="/helloworld">Hello world</a></li><li class=""><a href="/news">D2 News</a></li><li class=""><a href="/program">D2 Program</a></li><li class=""><a href="/about">About D2</a></li></ul></div></div><div><div class="m_search_sec"><div class="btn_lnb_search"><a href="#"><span class="blind">검색</span></a></div><form action="/" style="height: 0px; transition: all 0.5s ease 0s;"><input type="text" value="" placeholder="D2에서 검색" class="search_area"><button type="sunmit" class="blind"><i class="xi-search"></i></button></form></div><div class="pc_search_input"><fieldset><legend>검색</legend><form action="/"><input type="text" value="" placeholder="D2에서 검색" class="search_area"><button type="sunmit" class="btn_search"><i class="xi-search"></i></button></form></fieldset></div></div></div></div></div></div></div><div id="container"><div class="con_area"><div class="contents detail_view"><div class="post_article"><div class="cont_post"><h1 class="posting_tit">Kafka NetworkClient Internals</h1><dl class="post_info"><dt><i class="xi-time-o"><span class="blind">등록일</span></i></dt><dd>2022.01.29</dd><dt><span class="blind">|</span></dt><dd><span class="line_bar">|</span></dd><dt><i class="xi-eye"><span class="blind">코멘트</span></i></dt><dd>13345</dd></dl><div class="con_view"><p>Apache Kafka는 Distributed Event Streaming Platform으로, 데이터의 생산자(producer)와 소비자(consumer)를 중개하는 메시징 시스템입니다. Kafka의 기본 개념과 용어에 관해서는 Kafka가 제공하는 문서인 <a href="https://kafka.apache.org/intro">Introduction</a>과 <a href="https://kafka.apache.org/documentation/#intro_concepts_and_terms">Main Concpets and Terminology</a>를 참고하기 바랍니다.</p>

<p>Kafka는 데이터의 생산자(KafkaProducer)가 데이터를 Kafka 클러스터로 전송할 수 있도록 Producer API를 제공하고, 데이터의 소비자(KafkaConsumer)가 데이터를 읽을 수 있도록 Consumer API를 제공합니다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-01.png" alt="그림 1 Kafka 클러스터와 KafkaProducer, KafkaConsumer"></p>

<p><span class="caption">그림 1 Kafka 클러스터와 KafkaProducer, KafkaConsumer</span></p>

<p>이전 글인 <a href="https://d2.naver.com/helloworld/6560422">KafkaProducer Client Internals</a>에서 설명한 것처럼 KafkaProducer는 효율적인 데이터 전송과 압축을 위해 RecordAccumulator를 사용해 여러 개의 Record를 하나의 RecordBatch로 묶어서 전송하는 로직을 도입했습니다. KafkaConsumer에서는 <a href="https://d2.naver.com/helloworld/0974525">KafkaConsumer Client Internals</a>에서 설명한 것처럼 여러 개의 KafkaConsumer가 Kafka 클러스터에서 데이터를 효과적으로 읽을 수 있도록 리밸런스(rebalance) 동작과 Processing guarantees를 구현했습니다.</p>

<p>이 글에서는 <a href="https://d2.naver.com/helloworld/6560422">"KafkaProducer Client Internals"</a> 와 <a href="https://d2.naver.com/helloworld/0974525">"KafkaConsumer Client Internals"</a>에서 구체적으로 다루지 않은 NetworkClient와 I/O 멀티플렉싱(I/O multiplexing 동작에 대해 알아보겠습니다.</p>

<p>이 글은 Kafka 클라이언트 0.10.2.1 버전을 기준으로 작성되었습니다.</p>

<h2 id="networkclient">NetworkClient</h2>

<p>Kafka 클라이언트인 KafkaProducer와 KafkaConsumer는 브로커 노드와 통신하기 위해 NetworkClient라는 클래스를 사용한다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-02.png" alt="그림 2 Kafka 클라이언트에서의 NetworkClient"></p>

<p><span class="caption">그림 2 Kafka 클라이언트에서의 NetworkClient</span></p>

<p>그림 2에서 볼 수 있듯이 Kafka 클라이언트의 내부 로직에서 브로커에 보낼 ClientRequest가 만들어진다. Kafka 클라이언트의 내부 로직에서 생성된 ClientRequest는 NetworkClient로 전해져 네트워크를 통해 브로커로 전송된다. 브로커로부터 응답이 도착하면 NetworkClient가 응답을 읽어 ClientResponse로 만들어 내부 로직으로 전달한다.</p>

<p>NetworkClient는 다음과 같은 KafkaClient 인터페이스를 구현한 클래스이다.</p>

<p><span class="caption">예제 1 KafkaClient 인터페이스</span></p>

<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">KafkaClient</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Closeable</span> </span>{

    <span class="hljs-comment">// 노드에 요청을 보낼 수 있는 상태인지 확인</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isReady</span><span class="hljs-params">(Node node, <span class="hljs-keyword">long</span> now)</span></span>;

    <span class="hljs-comment">// 노드에 요청을 보낼 수 있는 상태인지 확인하고 필요한 경우 Connection 생성</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">ready</span><span class="hljs-params">(Node node, <span class="hljs-keyword">long</span> now)</span></span>;

    <span class="hljs-comment">// 다음 연결 시도까지 얼마나 기다려야 하는지 확인</span>
    <span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">connectionDelay</span><span class="hljs-params">(Node node, <span class="hljs-keyword">long</span> now)</span></span>;

    <span class="hljs-comment">// 노드로의 연결이 끊겼는지 확인</span>
    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">connectionFailed</span><span class="hljs-params">(Node node)</span></span>;

    <span class="hljs-comment">// 노드로의 연결 닫기</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">close</span><span class="hljs-params">(String nodeId)</span></span>;

    <span class="hljs-comment">// 보내야 할 요청을 큐에 저장(나중에 준비되면 요청을 전송)</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ClientRequest request, <span class="hljs-keyword">long</span> now)</span></span>;

    <span class="hljs-comment">// 실제 I/O 수행 및 받은 응답을 가져옴</span>
    <span class="hljs-function">List&lt;ClientResponse&gt; <span class="hljs-title">poll</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeout, <span class="hljs-keyword">long</span> now)</span></span>;

    <span class="hljs-comment">// 가장 요청을 적게 받은 노드를 선택</span>
    <span class="hljs-function">Node <span class="hljs-title">leastLoadedNode</span><span class="hljs-params">(<span class="hljs-keyword">long</span> now)</span></span>;

    <span class="hljs-comment">// 브로커로 전송되었지만 응답을 아직 받지 못한 요청들의 총합</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inFlightRequestCount</span><span class="hljs-params">()</span></span>;

    <span class="hljs-comment">// 특정 브로커로 전송되었지만 응답을 아직 받지 못한 요청들의 수</span>
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">inFlightRequestCount</span><span class="hljs-params">(String nodeId)</span></span>;

    <span class="hljs-comment">// I/O 수행을 기다리고 있는 스레드를 깨움</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">wakeup</span><span class="hljs-params">()</span></span>;
}
</code></pre>

<p>KafkaClient 인터페이스의 메서드 이름이 나타내는 것처럼 NetworkClient는 Kafka 클라이언트와 브로커 노드들의 연결 상태를 관리하고 브로커 노드로 데이터를 쓰거나 브로커 노드에서 데이터를 읽는 역할을 한다.</p>

<h3 id="clusterconnectionstates">ClusterConnectionStates</h3>

<p>NetworkClient는 브로커와의 연결 상태를 ClusterConnectionStates로 관리한다.</p>

<p>ClusterConnectionStates는 Kafka 클라이언트와 연결되어 있는 브로커의 연결 상태에 관한 정보를 브로커마다 NodeConnectionState 객체에 기록한다. 다음 그림에서 노란색 박스에 해당하는 NodeConnectionState에는 현재 연결 상태를 나타내는 ConnectionState와 마지막으로 연결을 시도했던 시간 정보가 기록된다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-03.png" alt="그림 3 ClusterConnectionStates를 통한 연결관리"></p>

<p><span class="caption">그림 3 ClusterConnectionStates를 통한 연결 관리</span></p>

<p>Kafka 클라이언트가 브로커와 연결을 시도하면 ConnectionState는 다음 그림과 같이 CONNECTING 상태와 CHECKING<em>API</em>VERSION 상태를 거쳐 최종적으로 READY 상태가 된다. Kafka 클라이언트가 브로커 노드와 요청과 응답을 주고받으려면 브로커와의 연결 상태가 READY 상태여야 한다. 만약 각 연결 단계에서 문제가 발생한다면 DISCONNECTED 상태로 바뀌고 브로커와 통신하기 위해 다시 연결을 시도한다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-04-1.png" alt="그림 4 ConnectionState의 변경 순서"></p>

<p><span class="caption">그림 4 ConnectionState의 변경 순서</span></p>

<p>ConnectionState의 각 연결 상태의 의미는 다음과 같다.</p>

<table><thead><tr><th>연결 상태</th><th>설명</th></tr></thead><tbody><tr><td>DISCONNECTED</td><td>브로커와 연결이 끊긴 상태</td></tr><tr><td>CONNECTING</td><td>소켓을 생성하고 연결을 생성 중인 상태</td></tr><tr><td>CHECKING_API_VERSIONS</td><td>연결이 생성되었고 브로커와 API 버전이 호환되는지 확인 중인 상태</td></tr><tr><td>READY</td><td>브로커로 요청을 전송할 수 있는 상태</td></tr></tbody></table>

<h4 id="disconnected">DISCONNECTED 상태</h4>

<p>DISCONNECTED 상태는 Kafka 클라이언트와 브로커 노드의 연결이 끊긴 상태를 의미한다. 다음과 같이 다양한 경우에 브로커 노드와 연결이 DISCONNECTED 상태로 설정된다.</p>

<ul>
<li>브로커 노드로의 연결 초기화가 실패한 경우</li>
<li>API 버전이 호환되지 않는 경우</li>
<li>브로커 노드로 요청 전송이 실패한 경우</li>
<li>요청이 전송되고 응답을 기다리다가 타임아웃이 발생한 경우</li>
<li>일정 시간 동안 브로커로 새로운 요청을 보내지 않은 경우</li>
</ul>

<p>브로커와 연결 상태가 DISCONNECTED 상태라면 브로커로 요청을 보내기 위해 다시 연결을 시도해야 한다. 이때 Kafka 클라이언트가 특정 브로커와의 연결을 너무 빈번하게 재시도하지 않도록 최소한 <code>reconnect.backoff.ms</code>에 설정한 시간이 지난 이후에 재연결을 시도한다. <code>reconnect.backoff.ms</code> 설정의 기본값은 '50'으로, 브로커로 연결 시도 사이에 최소 50ms의 시간차를 둔다. 이 백오프(backoff) 시간을 보장하기 위해서 NetworkClient는 브로커의 NodeConnectionState에 마지막 연결 시도 시간을 기록한다.</p>

<h4 id="connecting">CONNECTING 상태</h4>

<p>Kafka 클라이언트가 브로커와 연결을 시도할 때 CONNECTING 상태가 된다. ConnectionState의 상태를 CONNECTING으로 변경하고 브로커와 통신하기 위한 SocketChannel을 생성한다. 이때 생성되는 SocketChannel의 크기는 <code>send.buffer.bytes</code>에 설정된 송신 버퍼(send buffer size)의 크기와 <code>receive.buffer.bytes</code>에 설정된 수신 버퍼(receive buffer)의 크기이다. 크기를 별도로 설정하지 않으면 송신 버퍼의 크기는 128KB이고, 수신 버퍼의 크기는 64KB이다. 만약 값을 '-1'로 설정하면 실행하는 운영체제의 기본값인 <code>SO_SNDBUF</code>와 <code>SO_RCVBUF</code>가 적용된다.</p>

<p>SocketChannel을 생성한 다음 <a href="#javanio">Java NIO</a>에서 설명할 I/O 멀티플렉싱을 위해 NetworkClient 내에 있는 Selector에 SocketChannel을 등록하고 KafkaChannel을 생성하는 등 네트워크 통신과 연결 관리에 필요한 각종 객체를 생성한다.</p>

<h4 id="checking_api_versionsready">CHECKING<em>API</em>VERSIONS 상태, READY 상태</h4>

<p>Kafka 클라이언트와 브로커가 통신하기 위해 필요한 객체들이 생성되면 CHECKING<em>API</em>VERSIONS 상태로 ConnectionState의 상태를 변경한다. Kafka 클라이언트와 브로커 사이에 연결이 수립되어 통신은 가능하지만 둘 사이의 API 버전이 맞지 않다면 정상적으로 동작할 수 없다. Kafka 클라이언트와 브로커가 호환되는 API 버전인지 확인하기 위해 Kafka 클라이언트는 자신의 API 버전 정보를 담은 ApiVersionRequest를 생성해서 브로커로 전송한다. 그러면 브로커가 호환되는 버전인지를 판단해서 ApiVersionResponse를 Kafka 클라이언트에 돌려준다. Kafka 클라이언트는 이 응답을 통해 API 호환 여부를 알 수 있다.</p>

<p>API가 문제없이 호환된다면 브로커의 연결 상태는 READY 상태가 된다.</p>

<h3 id="idleexpirymanager">IdleExpiryManager</h3>

<p>Kafka 클라이언트는 불필요한 연결을 정리하기 위해 IdleExpiryManager를 사용한다. READY 상태로 통신할 준비가 되어 있는 브로커 연결을 일정 시간 동안 사용하지 않으면 IdleExpiryManager에 의해 연결이 정리될 수 있다.</p>

<p>NetworkClient는 브로커와 연결된 SocketChannel들을 Java NIO의 Selector에 등록한 다음 비동기로 연산을 수행한다. NetworkClient의 poll() 메서드가 주기적으로 실행되면서 Selector에 등록된 SocketChannel 중 이벤트가 있는 것들을 그때그때 비동기 방식과 논블로킹 방식으로 처리한다. IdleExpiryManager는 특정 SocketChannel에 어떤 이벤트가 처리되었을 때 그 시간을 기록해 두며, 이 시간을 기준으로 브로커 연결을 LRU(Least Recently Used) 알고리즘으로 관리한다.</p>

<p>Selector에서 이벤트를 처리할 때마다 IdleExpiryManager는 가장 오래된 브로커 연결이 <code>connections.max.idle.ms</code> 설정값만큼 지났는지 확인한다. 만약 가장 오래된 연결이 이 시간 동안 아무 일도 하지 않았다면 연결을 닫고 관련 객체들을 정리한다. 이 설정의 기본값은 '540000'으로, 9분 동안 아무 이벤트가 없었다면 연결이 정리된다. 만약 이 값을 음수로 지정하면 IdleExpiryManager를 생성하지 않으며 관련 동작도 수행하지 않는다.</p>

<h3 id="inflightrequests">InFlightRequests</h3>

<p>NetworkClient는 <a href="https://d2.naver.com/helloworld/6560422">KafkaProducer Client Internals</a>에서 설명한 InFlightRequests도 관리한다.</p>

<p>Kafka 클라이언트는 브로커에 요청(request)을 전송하고 응답(response)을 기다린다. 요청을 매번 하나씩만 보내고 응답을 기다린다면 매우 긴 시간 동안 브로커의 응답을 기다릴 것이다. Kafka 클라이언트는 성능 향상을 위해서 이전에 보낸 요청에 대한 응답을 받기 전에 다음 요청을 브로커로 전송할 수 있게 한다. 이를 'in-flight request'라고 한다. 'in-flight'는 '운항 중의'라는 뜻의 영어 단어로, Kafka 클라이언트에서는 브로커로 전송은 되었지만 응답을 아직 받지 못한 요청을 의미한다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-05.png" alt="그림 5 InFlightRequest 관리"></p>

<p><span class="caption">그림 5 InFlightRequest 관리</span></p>

<p>NetworkClient는 각 브로커로 전송한 요청을 Deque라는 자료구조에 저장한다. 브로커마다 전송할 수 있는 최대 요청은 <code>max.in.flight.requests.per.connection</code>에 설정한 만큼이다. 이 값에 다다랐다면 SocketChannel을 통해 브로커로 데이터를 보낼 수 있는 상황이라도 추가 요청을 전송하지 않는다. 그림 5는 Broker1 브로커로 요청 Req1과 Req2, Req3이 순차적으로 전송된 상황이다. InFlightRequests의 Broker1 항목에 대한 Deque에 Req1과 Req2, Req3이 저장되어 있다.</p>

<p>브로커로부터 응답이 도착하면 그 브로커에 보냈던 요청을 저장해둔 Deque의 가장 앞쪽에서 요청을 하나 제거하고 응답을 처리한다. 만약 요청에 대한 응답에 오류가 있다면 Deque의 가장 앞에 있던 요청을 가장 뒤로 다시 넣고 요청을 브로커에 재전송한다. 이 때문에 <code>max.in.flight.requests.per.connection</code> 설정값을 1보다 큰 값으로 설정하면 오류가 발생했을 때 데이터 전송 순서가 바뀔 수 있다. 그림 5는 Broker1에서 응답 Res1이 온 상황이다. Res1이 왔으므로 Broker1의 Deque에서 가장 앞에 있는 Req1을 제거하고 Res1에 대한 처리를 한다.</p>

<h2 id="selector">Selector</h2>

<p>Kafka 클러스터는 보통 수십에서 수백 대에 이르는 브로커 노드로 구성되어 있다. 따라서 Kafka 클라이언트는 수많은 브로커와의 네트워크 통신을 효율적으로 관리해야 한다.</p>

<p>Kafka 클라이언트의 NetworkClient는 Java NIO를 사용해 브로커들과의 네트워크 통신을 구현했다. Kafka 클라이언트의 네트워크 통신 구현을 이해하기 위해 먼저 Java NIO를 사용한 I/O 멀티플렉싱을 간단히 살펴보겠다. 그리고 Kafka 클라이언트와 브로커 사이의 인증과 암호화도 살펴보겠다.</p>

<h3 id="javanio">Java NIO</h3>

<p>네트워크 통신을 다루는 가장 간단한 방법은 다음 그림과 같이 모든 연결마다 전담하는 스레드(I/O Thread)를 생성하는 것이다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-06.png" alt="그림 6 I/O 스레드 생성을 통한 네트워크 통신 방법"></p>

<p><span class="caption">그림 6 I/O 스레드 생성을 통한 네트워크 통신 방법</span></p>

<p>통신할 서버와 연결이 생성될 때 그 서버와 통신할 전담 스레드를 생성한다. 특정 서버로 전송할 요청이 생기면 전담 스레드를 통해서 요청을 전송하고, 서버에서 오는 데이터 역시 전담 스레드가 읽는다. 이 방법은 가장 직관적이면서 간단한 방법이다.</p>

<p>하지만 Kafka 클라이언트가 구동되는 도중 대부분의 스레드는 통신을 하지 않고 대기 상태에 있을 것이다. 대부분의 스레드가 동작하지 않고 대기 상태에 머물러 있기 때문에 상당한 리소스 낭비가 발생한다. 연결할 서버의 개수가 많을수록, 그리고 주고받는 데이터의 양이 적을수록 대기 상태에서 보내는 시간이 길어지기 때문에 리소스 낭비는 더 심해진다. 게다가 전담 스레드가 많아질수록 공유 자원에 대한 동기화 이슈로 오히려 코드가 복잡해지거나 의외의 부분에서 병목 현상이 발생할 가능성도 높아진다.</p>

<p>Kafka 클라이언트의 NetworkClient는 이러한 전담 스레드 모델 대신 Java NIO를 사용한 비동기 통신 모델로 구현되었다.</p>

<p>Java NIO는 다음 그림과 같이 하나의 스레드가 Selector라는 컴포넌트를 두고 여러 SocketChannel을 관리할 수 있게 한다. 스레드는 Selector를 사용해서 Selector에 등록된 SocketChannel들 중 하나라도 읽거나 쓰는 등 뭔가를 할 수 있는 상황이 되면 바로 알 수 있다. 이런 방식을 SocketChannel의 '멀티플렉싱'이라고 한다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-07.png" alt="그림 7 Java NIO Selector 생성을 통한 비동기 네트워크 통신 방법"></p>

<p><span class="caption">그림 7 Java NIO Selector를 통한 비동기 네트워크 통신 방법</span></p>

<p>Java NIO를 사용해 여러 SocketChannel을 멀티플렉싱 방식으로 관리하려면 먼저 Selector를 생성해야 한다. Selector는 다음 예와 같이 정적 메서드인 open() 메서드를 사용해서 만들 수 있다.</p>

<p><span class="caption">예제 2 Java NIO Selector 생성</span></p>

<pre><code class="language-java hljs">Selector selector = Selector.open();  
</code></pre>

<p>그리고 Kafka 클라이언트가 메타데이터를 통해 알고 있는 브로커 노드 정보를 사용해 SocketChannel을 생성한다.</p>

<p><span class="caption">예제 3 Java NIO SocketChannel 생성</span></p>

<pre><code class="language-java hljs">SocketChannel socketChannel = SocketChannel.open();  
socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);  
socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(node.host(), node.port());  
</code></pre>

<p>예제 3에서 주의해야 할 부분은 <code>socketChannel.configureBlocking(false)</code>이다. Selector를 사용한 멀티플렉싱을 위해 생성되는 SocketChannel은 반드시 논블로킹 모드로 설정해야 한다.</p>

<p>그런 다음 SocketChannel을 Selector에 등록한다. 다음과 같이 SocketChannel의 register() 메서드를 사용해 SocketChannel을 등록할 수 있다.</p>

<p><span class="caption">예제 4 Selector에 SocketChannel 등록</span></p>

<pre><code class="language-java hljs"><span class="hljs-comment">// Selector에 SocketChannel 등록</span>
SelectionKey selectionKey = channel.register(selector, SelectionKey.OP_CONNECT | SelectionKey.OP_READ);  
</code></pre>

<p>register() 메서드의 첫 번째 파라미터는 등록할 Selector이고, 두 번째 파라미터는 interestSet이다. interestSet은 interest operation의 집합으로, 이 SocketChannel에서 어떤 연산을 수행하고 싶은지 Selector에 알려주는 역할을 한다. 즉, Selector에 '이 SocketChannel에 이런 연산들이 가능해지면 알려줘'라고 말하는 것이다.</p>

<p>SocketChannel을 Selector에 등록하면 SelectionKey 객체를 얻게 된다. SelectionKey 객체를 사용해서 Selector 객체와 SocketChannel 객체를 얻어올 수 있고, 다음 예처럼  SelectionKey 객체를 사용해 등록했던 interestSet을 바꿀 수도 있다.</p>

<p><span class="caption">예제 5 특정 채널의 interestSet 변경</span></p>

<pre><code class="language-java hljs">selectionKey.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);  
</code></pre>

<p>Selector에 설정할 수 있는 interest operation은 다음과 같다. Bitwise OR 연산(<code>|</code>)으로 하나의 채널에 대해서 두 개 이상의 interest operation을 설정하는 것도 가능하다.</p>

<ul>
<li>OP_READ</li>
<li>OP_WRITE</li>
<li>OP_CONNECT</li>
<li>OP_ACCEPT</li>
</ul>

<p>NetworkClient는 브로커로의 새로운 연결이 필요할 때 SocketChannel을 생성하고 내부 Selector에 등록한다. 그리고 필요에 따라 OP<em>CONNECT, OP</em>READ, OP_WRITE를 설정한다. 필요한 SocketChannel의 등록이 끝났으면 Selector를 사용해서 등록된 SocketChannel 중 필요한 연산을 수행할 수 있는 것이 나타날 때까지 기다린다.</p>

<p>다음 예처럼 select() 메서드를 호출하면 Selector에 등록된 SocketChannel이 각각의 interestSet을 수행할 준비가 될 때까지 select() 메서드의 내부에서 기다린다. 이후 연산할 준비가 된 SocketChannel이 생기거나 타임아웃 시간이 지나면 select() 메서드가 깨어난다. 이때 사용되는 타임아웃 시간은 Kafka 클라이언트의 내부 로직에 따라 매우 다양하게 결정되며 꼭 필요한 만큼만 기다린다.</p>

<p><span class="caption">예제 6 select() 메서드를 통해 이벤트가 발생할 때까지 대기</span></p>

<pre><code class="language-java hljs">selector.select(timeout);  
</code></pre>

<p>select() 메서드가 깨어난 이후 Selector의 selectedKeys() 메서드를 호출하면 준비된 SocketChannel의 SelectionKey를 가져올 수 있다. 보통 다음 예와 같은 형태의 코드가 사용된다.</p>

<p><span class="caption">예제 7 이벤트가 발생한 채널을 순회하며 처리</span></p>

<pre><code class="language-java hljs"><span class="hljs-comment">// 등록한 브로커 중 필요한 연산을 할 수 있는 SocketChannel의 SelectionKey</span>
Set&lt;SelectionKey&gt; selectedKeys = selector.selectedKeys();

<span class="hljs-comment">// SelectedKeys 순회</span>
Iterator&lt;SelectionKey&gt; iterator = selectedKeys.iterator();  
<span class="hljs-keyword">while</span>(iterator.hasNext()) {

    SelectionKey key = iterator.next();
    iterator.remove();

    <span class="hljs-keyword">if</span> (key.isReadable()) {
        <span class="hljs-comment">// ... 실행 코드 </span>
    }

    <span class="hljs-keyword">if</span> (key.isWritable()) {
        <span class="hljs-comment">// ... 실행 코드</span>
    }
    ...
}
</code></pre>

<p>selectedKeys() 메서드를 통해 가져온 SelectionKey들은 뭔가 연산을 할 준비가 된 SocketChannel에 대한 것들이며, 이들을 순회하면서 SocketChannel에 Send 혹은 Receive 같은 연산을 수행하면 된다.</p>

<p>KafkaProducer와 KafkaConsumer에서 브로커와 통신을 담당하는 스레드는 반복적으로 NetworkClient의 poll() 메서드를 호출한다. poll() 메서드의 내부에서는 Selector의 select() 메서드가 실행되며, 이를 통해서 브로커들과의 통신이 멀티플렉싱 방식으로 처리된다.</p>

<h3 id="kafkachannel">KafkaChannel과 인증, 암호화</h3>

<p>Kafka는 Kafka 클라이언트와 브로커 사이에 생성된 SocketChannel을 기반으로 인증과 암호화 기능을 추가하기 위해 KafkaChannel 클래스를 구현한다.</p>

<p><span class="caption">예제 8 KafkaChannel 클래스의 주요 멤버</span></p>

<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KafkaChannel</span> </span>{

    <span class="hljs-comment">// 브로커 ID</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String id;

    <span class="hljs-comment">// SocketChannel과 SelectionKey를 사용한 전송 동작</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> TransportLayer transportLayer;

    <span class="hljs-comment">// Kafka 클라이언트 인증 과정</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Authenticator authenticator;

    <span class="hljs-comment">// 브로커에서 받은 데이터</span>
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> maxReceiveSize;
    <span class="hljs-keyword">private</span> NetworkReceive receive;

    <span class="hljs-comment">// 브로커로 전송할 데이터</span>
    <span class="hljs-keyword">private</span> Send send;
    ...
}
</code></pre>

<p>예제 8에 있는 KafkaChannel의 주요 멤버 중 Authenticator와 TransportLayer는 각각 Kafka 클라이언트를 인증하기 위한 동작과 브로커와의 통신 암호화를 위해 사용된다. 만약 인증을 사용한다면 다음 그림처럼 Authenticator가 TransportLayer를 통해서 브로커와 인증 정보를 주고받으며 Kafka 클라이언트에 대한 인증을 진행한다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-08.png" alt="그림 8 KafkaChannel의 Authenticator를 사용한 Kafka 클라이언트 인증"></p>

<p><span class="caption">그림 8 KafkaChannel의 Authenticator를 사용한 Kafka 클라이언트 인증</span></p>

<p>인증이 끝나면 다음 그림과 같이 TransportLayer를 통해 브로커와 통신하면서 Send에 있는 데이터를 전송하거나 브로커로부터 데이터를 받아서 NetworkReceive에 담아 둔다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-09.png" alt="그림 9 KafkaChannel의 TransportLayer를 통한 브로커 통신"></p>

<p><span class="caption">그림 9 KafkaChannel의 TransportLayer를 통한 브로커 통신</span></p>

<p>Send는 NetworkClient 밖에서 브로커로 전송할 목적으로 생성한 ClientRequest를 직렬화(serialize)한 바이트 버퍼(byte buffer)라고 생각하면 된다. 반대로 NetworkReceive는 브로커에서 전송된 데이터를 조금씩 받아서 저장해 두는 곳으로, 데이터 수신이 끝나면 ClientResponse를 만들어 반환한다.</p>

<p>앞서 Selector에 등록된 SocketChannel은 KafkaChannel의 TransportLayer 객체로 래핑된다.</p>

<p>KafkaChannel은 브로커와의 연결이 맺어지는 과정에서 ChannelBuilder에 의해 생성된다. ChannelBuilder는 <code>security.protocol</code> 설정값에 따라 정해지며, 생성되는 KafkaChannel의 Authenticator와 TransportLayer의 구현체를 결정한다.</p>

<p><code>security.protocol</code>에 설정할 수 있는 값에는 다음과 같은 4가지가 있다.</p>

<table><thead><tr><th></th><th>인증 미사용</th><th>인증 사용</th></tr></thead><tbody><tr><td>암호화 미사용</td><td>PLAINTEXT</td><td>SASL_PLAINTEXT</td></tr><tr><td>암호화 사용</td><td>SSL</td><td>SASL_SSL</td></tr></tbody></table>

<p><code>SASL_PLAINTEXT</code>와 <code>SASL_SSL</code>처럼 접두어 'SASL_'로 시작하는 설정을 사용하면 Kafka 클라이언트 연결에 인증을 사용하겠다는 의미이다. 인증을 사용하면 브로커와의 연결에 사용되는 KafkaChannel 객체의 Authenticator로 SaslClientAuthenticator가 사용된다. 이 SaslClientAuthenticator의 동작을 설정하기 위해서 'sasl.*' 형태의 설정값을 사용한다.</p>

<p>예를 들어 다음과 같이 설정할 수 있다.</p>

<pre><code class="language-java hljs">bootstrap.servers=kafkahost:<span class="hljs-number">9093</span>  
security.protocol=SASL_PLAINTEXT  
sasl.mechanism=PLAIN  
sasl.jaas.config=org.apache.kafka.common.security.plain.PlainLoginModule required \  
   username=<span class="hljs-string">"user1"</span> \
   password=<span class="hljs-string">"user1passwd"</span>;
</code></pre>

<p>'SASL_' 같은 접두어가 없는 설정값인 <code>PLAINTEXT</code>나 <code>SSL</code>을 사용하면 KafkaChanel 객체의 Authenticator로 DefaultAuthenticator가 사용되며, Kafka 클라이언트가 브로커로 연결할 때 인증 동작을 수행하지 않는다.</p>

<p>설정 이름에 'SSL'이 있는 <code>SSL</code>이나 <code>SASL_SSL</code>을 사용하면 브로커와의 통신을 암호화한다.  이 경우 SocketChannel을 사용해 통신을 수행하는 TransportLayer로 SslTransportLayer가 사용된다. 이 SslTransportLayer의 동작을 설정하기 위해서 'ssl.*' 형태의 설정값을 사용한다.</p>

<p>예를 들어 다음과 같이 설정할 수 있다.</p>

<pre><code class="language-java hljs">bootstrap.servers=kafkahost:<span class="hljs-number">9093</span>  
security.protocol=SSL  
ssl.truststore.location=/var/<span class="hljs-keyword">private</span>/ssl/kafka.client.truststore.jks  
ssl.truststore.password=test1234  
ssl.keystore.location=/var/<span class="hljs-keyword">private</span>/ssl/kafka.client.keystore.jks  
ssl.keystore.password=test1234  
ssl.key.password=test1234  
</code></pre>

<p>이름에 SSL이 없는 <code>PLAINTEXT</code>나 <code>SASL_PAINTEXT</code>을 사용하면 TransportLayer로 PlaintextTransportLayer가 사용되며, 단순히 SocketChannel로 데이터를 전송하기만 한다.</p>

<p>SASL을 통한 Kafka 클라이언트의 인증 동작이나 SSL을 사용한 통신 암호화를 적용하기 위해서는 브로커의 설정 변경이 필요할 수 있다. SASL 설정과 SSL 설정에 관한 내용은 이 글에 담기에는 너무 길기 때문에 설명을 생략하겠다. 대신 SASL 설정에 관해서는 Confluent의 <a href="https://docs.confluent.io/platform/current/kafka/authentication_sasl/auth-sasl-overview.html">Authentication with SASL</a> 문서를 참고하고, SSL 설정에 관해서는 <a href="https://docs.confluent.io/platform/current/kafka/authentication_ssl.html">Encryption and Authentication with SSL</a> 문서를 참고한다.</p>

<h2 id="metadata">Metadata</h2>

<p>지금까지 NetworkClient가 특정 브로커와 통신하는 방법에 대해서 알아봤다. 여기까지의 내용은 Kafka 클라이언트가 접속할 브로커의 주소 정보를 알고 있다는 가정이 있었다. 하지만 Kafka 클라이언트의 사용자는 메시지를 전송하거나 읽기 위해 어떤 브로커에 접속해야 하는지 모른다. 데이터의 접근 포인트로 클러스터에 있는 '토픽' 이름만 알고 있을 뿐이다.</p>

<p>KafkaProducer API를 사용하는 다음 예를 보자. KafkaProducer 사용자는 어떤 토픽으로 Key, Value 데이터를 전송할 것인지 ProducerRecord 객체를 만들어 넘겨준다. 사용자 입장에서는 이 데이터가 어떤 브로커 노드로 전송되어야 하는지 모른다.</p>

<p><span class="caption">예제 9 KafkaProducer 예제</span></p>

<pre><code class="language-java hljs">Properties properties = <span class="hljs-keyword">new</span> Properties();  
properties.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, <span class="hljs-string">"kafka01:9092"</span>);  
properties.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());  
properties.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class.getName());

KafkaProducer&lt;<span class="hljs-keyword">byte</span>[], <span class="hljs-keyword">byte</span>[]&gt; producer = <span class="hljs-keyword">new</span> KafkaProducer&lt;&gt;(properties);

String key = <span class="hljs-string">"My Key"</span>;  
String value = <span class="hljs-string">"My Value"</span>;

ProducerRecord&lt;<span class="hljs-keyword">byte</span>[], <span class="hljs-keyword">byte</span>[]&gt; record = <span class="hljs-keyword">new</span> ProducerRecord&lt;&gt;(<span class="hljs-string">"MyTopic"</span>, key.getBytes(), value.getBytes());  
producer.send(record, <span class="hljs-keyword">null</span>);

producer.close();  
</code></pre>

<p>사용자로부터 ProducerRecord 객체를 넘겨받은 KafkaProducer는 내부적으로 다음 그림과 같은 순서로 브로커 주소를 알게 된다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-10.png" alt="그림 10 사용자의 데이터가 해석되어 브로커 노드를 찾는 순서"></p>

<p><span class="caption">그림 10 사용자의 데이터가 해석되어 브로커 노드를 찾게 되는 순서</span></p>

<p>ProducerRecord를 전달받은 KafkaProducer는 Partitioner를 사용해 토픽의 몇 번 파티션으로 데이터를 전송해야 하는지 결정한다. 하지만 여전히 그 파티션이 어떤 브로커 노드에 있는지는 모른다. Kafka 클라이언트는 토픽의 파티션이 어떤 브로커에서 서비스되고 있는지 Metadata 클래스를 통해 알게 된다.</p>

<p>Metadata에는 Kafka 클라이언트가 알아야 할 Kafka 클러스터의 메타데이터와 그 메타데이터를 갱신하기 위한 동작이 정의되어 있다.</p>

<p>Metadata에서 관리되는 첫 번째 메타데이터는 클러스터를 구성하고 있는 브로커 노드의 접속 정보이다.</p>

<p>클러스터를 구성하는 브로커 노드는 브로커 ID로 구별할 수 있다. 다음 예와 같이 Kafka 클라이언트가 특정 브로커 노드에 접속하기 위해 Metadata에서 얻어온 Node 객체에는 SocketChannel을 생성하기 위한 주소 정보가 담겨 있다.</p>

<p><span class="caption">예제 10 브로커 노드 정보를 저장하는 Node 객체</span></p>

<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Node</span> </span>{  
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> id;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String idString;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;
    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String rack;
  ...
}
</code></pre>

<p>두 번째로, Kafka 클라이언트가 사용하는 토픽에 대한 정보가 관리된다.</p>

<p>Kafka 클라이언트가 사용하는 토픽이 몇 개의 파티션으로 구성되어 있는지, 파티션의 복제본(replica)이 어떤 브로커에서 서비스되는지, 그중 Leader는 어디에 있는지, In-Sync 상태인 복제본은 어떤 브로커에 있는지 등이 관리된다. Metadata 내부에서는 다음과 같은 PartitionInfo 객체에 파티션에 대한 정보가 담겨있다.</p>

<p><span class="caption">예제 11 파티션 정보를 저장하는 PartitionInfo 객체</span></p>

<pre><code class="language-java hljs"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PartitionInfo</span> </span>{  
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String topic;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> partition;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node leader;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node[] replicas;
  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Node[] inSyncReplicas;
...
}
</code></pre>

<h3 id="metadataupdater">MetadataUpdater</h3>

<p>Kafka 클라이언트가 Metadata로 관리하는 메타데이터는 클러스터가 운영되는 도중에 얼마든지 바뀔 수 있다. 예를 들어 새로운 토픽이 만들어지거나 파티션 개수가 추가될 수 있다. 성능을 위해서 신규 브로커 장비가 클러스터에 추가되는 경우도 있고, 장비 장애로 클러스터에서 브로커가 제외되는 경우, 노후 장비 교체로 브로커의 장비가 교체되는 경우도 얼마든지 있을 수 있다.</p>

<p>일반적으로 Kafka 클라이언트는 다음의 경우에 메타데이터 갱신이 필요하다.</p>

<ol>
<li>특정 브로커 노드로 연결하다가 실패한 경우  </li>
<li>특정 브로커 노드에 요청을 보냈는데 타임아웃이 발생한 경우  </li>
<li>새로운 토픽에 데이터를 전송하거나 새로운 토픽을 구독하는 경우  </li>
<li>컨슈머 코디네이터 객체가 생성되는 경우  </li>
<li>Fetcher에서 데이터를 가져오려는데 Leader의 정보를 알 수 없을 경우  </li>
<li>데이터 요청을 보냈는데 Unknown Partition이라는 오류가 응답으로 오거나 Leader가 아니라는 오류가 응답으로 왔을 때  </li>
<li>그 밖에 메타데이터가 Stale 상태일 경우 만나게 되는 각종 Exception이 발생할 때</li>
</ol>

<p>Kafka 클라이언트가 동작하다가 자기가 알고 있는 메타데이터와 조금 다르거나 이상함을 감지하면 바로 메타데이터 갱신이 필요하다고 인지하게 된다. 매끄러운 동작을 위해서는 Kafka 클라이언트가 메타데이터의 변경을 감지했을 때 재 구동 없이 최신 메타데이터로 갱신할 수 있어야 한다. Kafka 클라이언트의 NetworkClient는 Metadata를 갱신하기 위해 MetadataUpdater라는 클래스를 사용한다.</p>

<p>다음 그림과 같이 MetadataUpdater는 MetadataRequest라는 요청을 생성해서 브로커로 전송한다. MetadataRequest를 전송할 브로커 노드는 현재 InFlightRequest 항목이 제일 적은 노드들 중에 임의로 선택한 노드이다. 요청을 받은 브로커 노드가 메타데이터를 정리해서 MetadataResponse에 담아 반환하면 반환받은 정보를 바탕으로 Metadata의 정보를 갱신한다.</p>

<p><img src="/content/images/2022/01/KafkaClientInternalsNetworkClient-11.png" alt="그림 11 MetadataUpdater의 Metadata 갱신"></p>

<p><span class="caption">그림 11 MetadataUpdater의 Metadata 갱신</span></p>

<p>Kafka 클라이언트 인스턴스가 최초로 생성되었을 때에는 Metadata를 요청할 브로커 주소 정보조차 가지고 있지 않다. 따라서 Kafka 클라이언트가 최초로 구동될 때 Metadata를 얻어올 수 있도록 <code>bootstrap.servers</code> 설정에 Kafka 클라이언트의 브로커 중 일부의 주소를 입력해야 한다.</p>

<p>Kafka 클라이언트가 최초로 구동되거나 없는 토픽을 막 만들어내기 시작하면 메타데이터에 대한 갱신 요청(MetadataRequest)이 너무 빈번하게 브로커로 전송될 수 있다. 따라서 메타데이터 갱신 요청이 너무 빈번하게 브로커로 전송되지 않도록 백오프 시간을 설정할 수 있다. Metadata에는 마지막으로 정보가 갱신된 시간이 기록되어 있고, <code>retry.backoff.ms</code> 설정을 사용하면 마지막 갱신 시간으로부터 <code>retry.backoff.ms</code> 설정값만큼 시간이 지날 때까지 새로운 MetadataRequest를 전송하지 않고 기다린다. <code>retry.backoff.ms</code> 설정의 기본값은 '100'이다.</p>

<p>반대로 메타데이터에 대한 변경이 오랜 시간 동안 감지되지 않더라도 일정 시간이 지나면 갱신 요청을 브로커로 전송한다. 당장은 필요하지 않더라도 Kafka 클러스터에 추가된 브로커나 파티션에 대한 정보를 미리 알아오면 나중에 MetadataRequest를 전송하고 기다리지 않아도 되기 때문이다. MetadataUpdater는 마지막 메타데이터 갱신이 성공한 이후 <code>metadata.max.age.ms</code>에 설정한 시간이 지나면 다시 갱신 요청을 전송한다. <code>metadata.max.age.ms</code> 설정의 기본 값은 '300000'으로, 5분이다.</p>

<p>MetadataUpdater가 생성하는 MetadataRequest에는 Kafka 클라이언트가 관심 있어 하는 토픽의 리스트가 담겨 있다. 다시 돌아오는 응답에는 Kafka에 있는 Kafka 클라이언트가 관심 있다고 보낸 토픽의 정보만 담겨 있다. 만약 오랜 기간 동안 사용되지 않은 토픽이 있다면 MetadataRequest에 쓸데없는 정보가 포함되어 브로커도 느려지고 주고받는 요청의 크기도 커진다. KafkaProducer는 일정 기간 동안 사용되지 않은 토픽의 정보는 메타데이터에서 제외한다. 제외된 토픽은 앞으로 전송되는 메타데이터 갱신 요청에 포함되지 않는다. 이 기간은 설정할 수 있는 값이 아니며, 5분이라는 고정값으로 설정되어 있다.</p>

<h2 id="">마치며</h2>

<p>지금까지 Kafka 클라이언트에서 네트워크 통신을 위해 사용한 NetworkClient의 내부 구조와 설정값에 관해 알아보았다.</p>

<p>Kafka 클라이언트는 클러스터를 구성하고 있는 수많은 브로커와의 통신을 Java NIO를 통해서 구현했다. 사실 가장 궁금했던 것은 '왜 Java NIO를 사용해서 직접 구현했는가'였다. <a href="https://storm.apache.org/">Apache Storm</a>의 경우에는 Worker들의 네트워크 통신을 <a href="https://netty.io/">Netty</a>라는 네트워크 프레임워크를 통해서 구현했다. Kafka의 공식 입장은 아니지만 Kafka 커미터의 <a href="https://www.quora.com/Why-did-Kafka-developers-prefer-to-implement-their-own-socket-server-instead-of-using-Netty-Does-that-help-with-performance-Does-Kafka-implement-such-features-already">Quora 답변</a>을 통해 어느 정도 이유를 알 수 있었다. 우선 가장 최적의 성능을 구현할 수 있기 때문이다. 그리고 '의존성 지옥(dependency hell)'을 최대한 피하기 위함이라고 한다. 특히 다양한 환경에서 실행되는 Kafka 클라이언트에서는 의존성이 충돌하는 상황이 얼마든지 발생할 수 있기 때문에 되도록 의존성이 추가되는 것을 피하려고 노력한다는 것이다.</p>

<p>실제로 Kafka 클라이언트의 코드를 보면 굉장히 많은 부분이 라이브러리를 사용하지 않고 직접 구현되어 있다. Kafka처럼 의존성이 문제가 될 가능성이 있는 클라이언트 라이브러리를 개발하는 경우라면 Kafka 클라이언트의 코드를 참고하는 것이 많은 도움이 될 것이다.</p></div><div class="txt_tag"><span class="icon_tag">Tag</span><div class="tag_list"><a href="/search?keyword=Apache Kafka"><span>Apache Kafka</span></a></div></div><div class="post_writer_info"><div class="writer_info"><div class="ly_img_people"></div><div class="img_people"><img src="/image/20220127/638655852651.jpeg" alt=""></div><div class="people_info"><dl><dt><span class="blind">글쓴이</span></dt><dd><span class="name">안인석<span></span></span><span><span class="bar">|</span><span class="duty_dept">네이버 Platform</span></span></dd><dt><span class="blind">소개</span></dt><dd class="info">네이버에서 대용량 데이터 저장소 운영 및 개발을 담당하고 있습니다.</dd></dl></div><div class="people_write"><a href="https://d2.naver.com/search?keyword=%EC%95%88%EC%9D%B8%EC%84%9D">글쓴이의 다른 글 보기</a></div></div></div><div class="sns_position"><div class="sns_sec"><button type="button" class="sns_naver"><span class="sns_icon">NAVER</span></button><button type="button" class="sns_facebook"><span class="sns_icon">facebook</span></button><div class="fb-like fb_iframe_widget" data-href="http://d2.naver.com/helloworld/0853669" data-layout="button_count" data-action="like" data-size="large" data-show-faces="false" data-share="false" fb-xfbml-state="parsed" fb-iframe-plugin-query="action=like&amp;app_id=816454888441763&amp;container_width=714&amp;href=http%3A%2F%2Fd2.naver.com%2Fhelloworld%2F0853669&amp;layout=button_count&amp;locale=ko_KR&amp;sdk=joey&amp;share=false&amp;show_faces=false&amp;size=large"><span style="vertical-align: top; width: 0px; height: 0px; overflow: hidden;"><iframe name="f3b932c2dd813e" width="1000px" height="1000px" data-testid="fb:like Facebook Social Plugin" title="fb:like Facebook Social Plugin" frameborder="0" allowtransparency="true" allowfullscreen="true" scrolling="no" allow="encrypted-media" src="https://www.facebook.com/v2.11/plugins/like.php?action=like&amp;app_id=816454888441763&amp;channel=https%3A%2F%2Fstaticxx.facebook.com%2Fx%2Fconnect%2Fxd_arbiter%2F%3Fversion%3D46%23cb%3Df23407ea27fd914%26domain%3Dd2.naver.com%26is_canvas%3Dfalse%26origin%3Dhttps%253A%252F%252Fd2.naver.com%252Ffe3f4dc97d5b7c%26relation%3Dparent.parent&amp;container_width=714&amp;href=http%3A%2F%2Fd2.naver.com%2Fhelloworld%2F0853669&amp;layout=button_count&amp;locale=ko_KR&amp;sdk=joey&amp;share=false&amp;show_faces=false&amp;size=large" style="border: none; visibility: hidden;"></iframe></span></div><button type="button" class="sns_url"><span class="sns_icon">URL</span></button></div></div></div></div><div class="relation_sec"><p class="relation_title">관련글</p><div class="relation_list"><div class="list"><ul><li><a href="/helloworld/7731491"><img src="/content/images/2016/04/---.png" width="60" height="50" alt="썸네일"><div class="relation_list_txt">대용량 스트리밍 데이터 실시간 분석</div></a></li><li><a href="/helloworld/1044388"><img src="/content/images/2015/07/1044388.PNG" width="60" height="50" alt="썸네일"><div class="relation_list_txt">Storm과 Elasticsearch Percolator를 이용한 NELO2 알람 기능 개선</div></a></li><li><a href="/helloworld/6560422"><img src="/content/images/2020/08/hwhw_200813.png" width="60" height="50" alt="썸네일"><div class="relation_list_txt">KafkaProducer Client Internals</div></a></li><li><a href="/helloworld/8852387"><img src="/content/images/2016/11/spark-summit-europe-2016-02-1.png" width="60" height="50" alt="썸네일"><div class="relation_list_txt">Spark Summit Europe 2016 참관기</div></a></li></ul></div></div></div><div id="cbox_module" style="max-width: 840px; margin: 0px auto; padding-bottom: 35px;" class="u_cbox"><div class="u_cbox_wrap u_cbox_ko"><div class="u_cbox_head"><h5 class="u_cbox_title">댓글</h5><span class="u_cbox_count">2</span><button type="button" class="u_cbox_btn_refresh" data-action="count#refresh" data-log="RPO.refresh"><span class="u_cbox_ico_refresh"></span><span class="u_cbox_txt_refresh">새로고침</span></button><div class="u_cbox_head_tools"></div></div><div class="u_cbox_write_wrap"><div class="u_cbox_write_box u_cbox_type_logged_out"><form><fieldset><legend class="u_vc">댓글 쓰기</legend><div class="u_cbox_write"><div class="u_cbox_write_inner"><div class="u_cbox_write_area"><strong class="u_vc">댓글 입력</strong><div class="u_cbox_inbox"><textarea title="댓글" id="cbox_module__write_textarea" class="u_cbox_text" rows="3" cols="30" data-log="RPC.input"></textarea><label for="cbox_module__write_textarea" class="u_cbox_guide" data-action="write#placeholder" data-param="@event">댓글을 작성하려면 <a href="#" class="u_cbox_link">로그인</a> 해주세요</label></div></div><div class="u_cbox_upload_sticker" style="display:none"></div><div class="u_cbox_write_count"><span class="u_vc">현재 입력한 글자수</span><strong class="u_cbox_count_num">0</strong>/<span class="u_vc">전체 입력 가능한 글자수</span><span class="u_cbox_write_total">400</span></div><div class="u_cbox_upload"><div class="u_cbox_addition"></div><button type="button" class="u_cbox_btn_upload" data-action="write#request" data-log="RPC.write#RPC.reply"><span class="u_cbox_ico_upload"></span><span class="u_cbox_txt_upload">등록</span></button></div></div></div></fieldset></form></div></div><div class="u_cbox_notice u_cbox_notice_none" style="display: none;"></div><div id="cbox_module_wai_u_cbox_content_wrap_tabpanel" tabindex="0" class="u_cbox_content_wrap" style="outline: 0"><ul class="u_cbox_list"><li class="u_cbox_comment cbox_module__comment_749625283304227569 _user_id_no_2rXX5" data-info="commentNo:'749625283304227569',deleted:false,best:false,visible:true,secret:false,manager:false,mine:false,report:undefined,blindReport:false,objectId:'0853669',replyLevel:1,parentCommentNo:'749625283304227569',pick:false"><div class="u_cbox_comment_box"><div class="u_cbox_area"><div class="u_cbox_info"><span class="u_cbox_info_main"><span class="u_cbox_name"><span class="u_cbox_name_area"><span class="u_cbox_nick_area"><span class="u_cbox_nick">geog****</span></span></span></span></span><span class="u_cbox_info_sub"></span></div><div class="u_cbox_text_wrap"><span class="u_cbox_contents" data-lang="ko">기존 producer 와 consumer가  blockingRequest나 대기열이나 bloking io로 인해 많은 대안들이 나왔었는데요 java 1.6부터 nonblocking이 제공됐고 이후 nio패키지가 나왔는데, 당시 java.sun에서 제공된 코드체계가 현재에 이르러  아파치에서 카프카라는 형태로 대부분 차용한 형태를 보이는 걸 볼 수 있는데, workThead같은 역활로 분산처리방법을 좀더 효과적으로 아파치로 들여오면서 보완한 것으로 이해되내요. 글 잘 봤습니다..</span></div><div class="u_cbox_info_base"><span class="u_cbox_date" data-value="2022-02-14T17:35:48+0900">2022-02-14 17:35</span></div><div class="u_cbox_tool"><a href="#" role="button" aria-expanded="false" class="u_cbox_btn_reply" data-action="reply#toggle" data-param="749625283304227569" data-log="RPC.replyopen#RPC.replyclose"><strong class="u_cbox_reply_txt">답글</strong><span class="u_cbox_reply_cnt u_vc">0</span></a><div class="u_cbox_recomm_set"><strong class="u_vc">공감/비공감</strong><a href="#" data-action="vote" data-param="mine:false,commentNo:'749625283304227569',voteStatus:'SYMPATHY',objectId:'0853669',ticket:'d2'" data-log="RPC.sym#RPC.unsym" class="u_cbox_btn_recomm"><span class="u_cbox_ico_recomm">공감</span><em class="u_cbox_cnt_recomm">0</em></a><a href="#" data-action="vote" data-param="mine:false,commentNo:'749625283304227569',voteStatus:'ANTIPATHY',objectId:'0853669',ticket:'d2'" data-log="RPC.dis#RPC.undis" class="u_cbox_btn_unrecomm"><span class="u_cbox_ico_unrecomm">비공감</span><em class="u_cbox_cnt_unrecomm">0</em></a></div></div><span class="u_cbox_comment_frame"><span class="u_cbox_ico_tip"></span><span class="u_cbox_comment_frame_top"><span class="u_cbox_comment_bg_r"></span><span class="u_cbox_comment_bg_l"></span></span><span class="u_cbox_comment_frame_bottom"><span class="u_cbox_comment_bg_r"></span><span class="u_cbox_comment_bg_l"></span></span></span></div></div><div class="u_cbox_reply_area" style="display:none;"></div></li><li class="u_cbox_comment cbox_module__comment_748667921940611367 _user_id_no_6ib4m" data-info="commentNo:'748667921940611367',deleted:false,best:false,visible:true,secret:false,manager:false,mine:false,report:undefined,blindReport:false,objectId:'0853669',replyLevel:1,parentCommentNo:'748667921940611367',pick:false"><div class="u_cbox_comment_box"><div class="u_cbox_area"><div class="u_cbox_info"><span class="u_cbox_info_main"><span class="u_cbox_name"><span class="u_cbox_name_area"><span class="u_cbox_nick_area"><span class="u_cbox_nick">팽팽</span></span></span></span></span><span class="u_cbox_info_sub"></span></div><div class="u_cbox_text_wrap"><span class="u_cbox_contents" data-lang="ko">좋은 글 잘 보았습니다.</span></div><div class="u_cbox_info_base"><span class="u_cbox_date" data-value="2022-02-04T09:55:36+0900">2022-02-04 09:55</span></div><div class="u_cbox_tool"><a href="#" role="button" aria-expanded="false" class="u_cbox_btn_reply" data-action="reply#toggle" data-param="748667921940611367" data-log="RPC.replyopen#RPC.replyclose"><strong class="u_cbox_reply_txt">답글</strong><span class="u_cbox_reply_cnt u_vc">0</span></a><div class="u_cbox_recomm_set"><strong class="u_vc">공감/비공감</strong><a href="#" data-action="vote" data-param="mine:false,commentNo:'748667921940611367',voteStatus:'SYMPATHY',objectId:'0853669',ticket:'d2'" data-log="RPC.sym#RPC.unsym" class="u_cbox_btn_recomm"><span class="u_cbox_ico_recomm">공감</span><em class="u_cbox_cnt_recomm">0</em></a><a href="#" data-action="vote" data-param="mine:false,commentNo:'748667921940611367',voteStatus:'ANTIPATHY',objectId:'0853669',ticket:'d2'" data-log="RPC.dis#RPC.undis" class="u_cbox_btn_unrecomm"><span class="u_cbox_ico_unrecomm">비공감</span><em class="u_cbox_cnt_unrecomm">1</em></a></div></div><span class="u_cbox_comment_frame"><span class="u_cbox_ico_tip"></span><span class="u_cbox_comment_frame_top"><span class="u_cbox_comment_bg_r"></span><span class="u_cbox_comment_bg_l"></span></span><span class="u_cbox_comment_frame_bottom"><span class="u_cbox_comment_bg_r"></span><span class="u_cbox_comment_bg_l"></span></span></span></div></div><div class="u_cbox_reply_area" style="display:none;"></div></li></ul></div><div class="u_cbox_paginate" style=""><div class="u_cbox_page_wrap"><span class="u_cbox_pre u_cbox_pre_end" title="첫 페이지 목록으로 이동하기"><span class="u_cbox_ico_page"></span><span class="u_cbox_cnt_page">맨앞</span><span class="u_vc">페이지 목록으로 이동하기</span></span><span class="u_cbox_pre" title="이전 페이지 목록으로 이동하기"><span class="u_cbox_ico_page"></span><span class="u_cbox_cnt_page">이전</span><span class="u_vc">페이지 목록으로 이동하기</span></span><strong class="u_cbox_page" data-param="1"><span class="u_cbox_num_page">1</span><span class="u_vc">현재 선택된 페이지</span></strong><span class="u_cbox_next" title="다음 페이지 목록으로 이동하기"><span class="u_cbox_cnt_page">다음</span><span class="u_cbox_ico_page"></span><span class="u_vc">페이지 목록으로 이동하기</span></span><span class="u_cbox_next u_cbox_next_end" title="마지막 페이지 목록으로 이동하기"><span class="u_cbox_cnt_page">맨뒤</span><span class="u_cbox_ico_page"></span><span class="u_vc">페이지 목록으로 이동하기</span></span></div></div></div></div></div></div></div><div id="footer"><div class="inner_sec"><div class="footer_sec"><ul class="other_site"><li><a href="https://developers.naver.com/" target="_blank" class="developers">NAVER Developers</a></li><li><a href="https://techcon.naver.com/" target="_blank" class="techcon">NAVER TECH CONCERT</a></li><li><a href="https://deview.kr/" target="_blank" class="deview">DEVIEW</a></li><li><a href="https://naver.github.io/" target="_blank" class="opensource">OpenSource</a></li><li><a href="http://www.d2startup.com/" target="_blank" class="startup">D2 STARTUP FACTORY</a></li></ul><div class="sns_share"><ul><li class="email"><a href="mailto:d2@navercorp.com"><i class="xi-mail"></i></a></li><li class="facebook"><a href="https://facebook.com/naverd2" target="_blank"><i class="xi-facebook"></i></a></li><li class="rss"><a href="https://d2.naver.com/d2.atom" target="_blank"><i class="xi-social-rssfeed"></i></a></li></ul></div></div><div class="footer_sec"><div class="copyright"><p><span>Copyright</span> © <a href="https://www.navercorp.com/" target="_blank">NAVER Corp.</a> <span>All Rights Reserved.</span></p></div><a href="#" class="btn_go_top" style="bottom: 20px; right: 0px;"></a></div></div></div></div></div><i classname="xi-search">
<script id="facebook-jssdk" src="https://connect.facebook.net/ko_KR/sdk.js#xfbml=1&amp;version=v2.11&amp;appId=816454888441763"></script><script async="" src="//www.google-analytics.com/analytics.js" id="google-analytics"></script><script async="" src="https://wcs.naver.net/wcslog.js" id="naver-analytics"></script><script type="text/javascript" src="/static/js/app.js?13c1e9311ca34225bfc0"></script>

</i><div id="fb-root" class=" fb_reset"><div style="position: absolute; top: -10000px; width: 0px; height: 0px;"><div></div></div></div></body></html>