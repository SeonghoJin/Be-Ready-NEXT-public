{"company":{"imageUrl":"/companyImages/naver.ico","name":"네이버","href":"https://d2.naver.com/d2.atom","basePath":"https://d2.naver.com","rssUrl":"https://d2.naver.com/d2.atom"},"title":"웹 3D 모델 최적화 기법 소개","createdAt":"2022-05-25T10:48:45Z","description":"<p>이 글에서는 웹에서 주로 사용되는 3D 모델 형식인 glTF(GL Transmission Format)를 대상으로 적용할 수 있는 최적화 기법을 소개합니다. 이를 통해 웹에서 3D 모델을 사용할 때 발생할 수 있는 지연 시간과 관련된 문제를 해결하는 방법에 대해서 알아보겠습니다.</p>\n\n<h2 id=\"3dgltf\">3D 모델과 glTF</h2>\n\n<p>웹에서 3D 모델을 사용하는 것은 이미지나 비디오와 같은 다른 형태의 멀티미디어 콘텐츠를 사용하는 것과 별반 다르지 않다. 다만, 3D 모델을 웹페이지에서 표시하기 위해서는 다른 콘텐츠에 비해 몇 가지 더 고려할 사항이 있다.</p>\n\n<p>먼저, 3D 모델은 이미지나 비디오처럼 웹 브라우저에 <code>&lt;img&gt;</code>나 <code>&lt;video&gt;</code>와 같은 태그로 <code>src</code> 특성만 지정하는 형태로 바로 사용하는 것이 불가능하다. 3D 모델을 WebGL을 통해 렌더링하려면 <code>&lt;canvas&gt;</code> 태그를 사용하여 WebGL 컨텍스트를 받아와 렌더링하는 코드를 직접 작성할 필요가 있으며, 3D 모델 파일(glTF, FBX, OBJ 등) 또한 일종의 인코딩된 형태이기 때문에 실제 사용할 데이터를 받아오려면 파일을 로드하여 디코딩하는 과정을 거쳐야 한다. 이 과정은 <a href=\"https://threejs.org/\">Three.js</a>나 <a href=\"https://www.babylonjs.com/\">Babylon.js</a>와 같이 각종 3D 형식의 로드 및 디코딩을 지원하는 라이브러리를 사용하거나, <a href=\"https://naver.github.io/egjs-view3d/\">View3D</a>와 같은 3D 뷰어 컴포넌트를 활용하면 단순화할 수 있다.</p>\n\n<p>또한 3D 모델은 일반적으로 다른 콘텐츠에 비해 파일 크기가 큰 편이고, 데이터를 스트리밍하여 받아오기도 어렵기 때문에 상대적으로 최적화가 더 필요한 편이다. 물론 3D 모델 간에도 상대적인 차이는 있다. 예를 들어 4K 비디오와 480p 동영상의 파일 크기가 다르듯이, 3D 모델도 어떻게 구성하느냐에 따라서 파일 크기가 천차만별일 수 있다.</p>\n\n<p>3D 모델의 종류에는 여러 가지가 있지만, 대표적으로 polygonal mesh 형태의 3D 모델이 가장 많이 사용된다. <br />\npolygonal mesh 3D 모델을 구성하는 데이터를 간략히 나눠보면 크게 <strong>형태(geometry)</strong>, <strong>재질(material)</strong>, <strong>동작(animation)</strong>으로 나눠볼 수 있으며 그 밖에 장면 구성 데이터(빛, 카메라) 등이 있다. 각 요소를 살펴보면서, 어떠한 데이터가 3D 모델의 파일 크기를 차지하는지 알아보겠다.</p>\n\n<h3 id=\"geometry\">형태(geometry)</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b76681de6853.gif\" alt=\"geometry.gif\" /></p>\n\n<p>polygonal mesh 3D 모델은 정점(vertex), 정점들을 잇는 선(edge), 그리고 그 선들이 합쳐져 만들어지는 면(face)들로 이루어져 있다. 점 하나에 들어가는 데이터를 생각해보면, 먼저 각 점마다 3차원 좌표(x, y, z)가 반드시 포함되며 그 밖에 텍스처 데이터를 매핑하는 2차원 좌표인 UV 좌표, 점마다의 색상을 나타내는 3차원 데이터(r, g, b), 법선 방향을 나타내는 3차원 벡터 등이 포함될 수 있다.</p>\n\n<p>정점의 개수는 3D 모델의 디테일에 따라 다르며, 몇백~몇천 개부터 몇십~몇백만 개까지 사용될 수 있다. 이는 3D 모델을 생성하는 과정과 연관이 깊은데, 3D sculpting 프로그램을 통해 생성된 모델은 추가 처리를 하지 않을 경우 일반적으로 정점의 개수가 굉장히 많으며, 이 밖에 Subdivision Surface와 같은 modifier를 통해 정점의 개수와 디테일을 늘리고 표면을 더 부드럽게 만드는 방식 등이 많이 사용되고 있다.</p>\n\n<h3 id=\"material\">재질(material)</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b76831276b5c.png\" alt=\"image-20220512-173502-797.png\" /></p>\n\n<p>3D 모델이 어떤 색상을 갖는지, 빛을 비췄을 때는 어떤 특성을 갖고 있는지와 같이, 모델 표면의 성질을 나타내는 것이 재질(material)이다. 재질을 표현하기 위해 텍스처(texture)가 사용되는데, 일반적으로 2D 이미지 형태로 3D 모델에 저장된다.</p>\n\n<p>텍스처 이미지는 웹에서 사용되는 JPG나 PNG 형식 등이 사용되며, 지원 여부에 따라 WebP 형식을 사용하는 경우도 있다. 텍스처 이미지는 일반적으로 1024x1024, 2048x2048 등 2의 배수 크기를 사용하며, 2D 이미지를 사용하기 때문에 일반적으로 2D 이미지에 사용하는 것과 동일한 이미지 최적화 기법을 적용할 수 있다.</p>\n\n<h3 id=\"animations\">동작(animations)</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b769015e0edc.gif\" alt=\"animation.gif\" /></p>\n\n<p>3D 모델을 움직이게 하기 위해 일반적으로 3D 모델 내부에 뼈대를 심어 그 뼈대를 움직이는 skeletal animation(rigging) 방식을 사용한다. 실제로 사용되는 데이터의 경우 여러 저장 방식이 있으나, 대표적으로 정점마다 영향받는 뼈대의 id와 영향받는 정도(weight)를 같이 저장하는 방식이 있다. 이 경우 뼈대별로 offset matrix, 그리고 키프레임별로 애니메이션을 적용할 뼈대의 position, rotation, scale, 그리고 키프레임 간의 interpolation 방법 등이 같이 저장된다.</p>\n\n<h3 id=\"gltfgltransmissionformat\">glTF(GL Transmission Format)</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b773dd3562b6.png\" alt=\"image-20220512-174747-792.png\" /></p>\n\n<p><a href=\"https://github.com/KhronosGroup/glTF\">glTF</a>는 3D 모델을 저장하는 형식 중 하나로, 빠르고 효율적인 데이터 구조를 갖고 있어 웹에서 많이 사용되고 있다. 추가로, glTF는 물리 기반 렌더링, Skeletal Animation 등 현 세대에서 사용하는 많은 기능을 지원함은 물론 extension을 통해 다양한 기능을 추가로 사용할 수 있다.</p>\n\n<p>glTF는 메인이 되는 JSON 형식의 glTF 파일, 그리고 형태ㆍ동작 등 버퍼 데이터가 저장되는 바이너리 파일(.bin), 그리고 모델마다 상이하지만 다수의 텍스처 이미지로 구성된다. 혹은 이를 전부 합하여 하나의 바이너리 파일로 구성할 수도 있으며, 이 경우 glb 형식을 사용한다.</p>\n\n<h2 id=\"geometry\">Geometry 최적화</h2>\n\n<p>Geometry 최적화는 폴리곤 개수 감소와 Geometry Compression의 두 가지 측면에서 접근할 수 있다. 폴리곤 개수 감소는 정점 및 폴리곤의 개수를 감소시키는 방식으로 실제 데이터 양을 줄이는 것이기 때문에 모델의 디테일은 감소할 수 있으나 처리할 데이터의 절대적인 양이 감소하므로 모델 파일 크기을 줄일 뿐만 아니라 런타임 성능을 높일 수도 있다. Geometry Compression은 데이터를 압축하는 방법으로, 폴리곤 개수 감소에 더해 추가로 적용할 수 있다.</p>\n\n<h3 id=\"retopology\">Retopology</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b7743be962c4.png\" alt=\"image-20220512-174812-002.png\" /></p>\n\n<p><span class=\"caption\">이미지 출처: <a href=\"http://people.wku.edu/joon.sung/edu/anim/3d/modeling/retopology/retopology.html\">http://people.wku.edu/joon.sung/edu/anim/3d/modeling/retopology/retopology.html</a></span></p>\n\n<p>Retopology는 대표적으로 폴리곤 개수를 감소시키는 방법으로, Sculpting 등을 통해 생성된 Highpoly 모델을 원본 형태는 최대한 유지하면서 폴리곤의 개수는 더 적어지도록 수정한다. 이 방식의 경우 폴리곤의 절대적인 개수가 줄어들기 때문에 원본에 비해 디테일이 떨어지는 것은 사실이지만, 원본, 즉 Highpoly 상태에서 노멀맵을 생성한 후 Retopology가 적용된 모델에 생성된 노멀맵을 적용하여 원본의 디테일을 살리는 방법을 사용할 수 있다.</p>\n\n<h3 id=\"runtimemeshsimplification\">Runtime Mesh Simplification</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b776279f656b.png\" alt=\"image-20220512-175017-879.png\" /></p>\n\n<p><span class=\"caption\">3D 모델 출처: <a href=\"https://sketchfab.com/3d-models/juvenile-teratophoneus-curriei-2d7c4e880c2e45289ebbade3ec479979\">https://sketchfab.com/3d-models/juvenile-teratophoneus-curriei-2d7c4e880c2e45289ebbade3ec479979</a></span></p>\n\n<p>이 방식은 이름 그대로, 런타임에 geometry mesh를 단순화해 원본 모델의 형태를 최대한 유지하는 선에서 폴리곤 개수를 감소시키는 방식이다. 이 경우 Retopology와 동일한 효능을 얻을 수 있으나, 웹에서는 원본 3D 모델을 동일하게 다운로드해야 한다는 문제가 있다. 따라서 런타임 성능의 문제로 병목이 생기는 경우가 아니라면 원본 모델을 사용하는 것이 낫고, 이 방식을 사용하면 디테일만 낮출 뿐이라는 한계가 있다.</p>\n\n<h3 id=\"dracomeshcompression\">Draco Mesh Compression</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b7827e6e1de8.png\" alt=\"image-20220512-180346-572.png\" /></p>\n\n<p><span class=\"caption\">이미지 출처: <a href=\"https://opensource.googleblog.com/2017/01/introducing-draco-compression-for-3d.html\">https://opensource.googleblog.com/2017/01/introducing-draco-compression-for-3d.html</a></span></p>\n\n<p><a href=\"https://github.com/google/draco\">Draco</a>는 Google이 만든 mesh/point cloud compression 라이브러리로, 형태와 관련된 데이터를 높은 효율로 압축하는 것이 가능하다. 다만 Draco는 애니메이션 관련 데이터나 텍스처 데이터를 압축하지는 못하기 때문에 모델 내에서 형태 데이터가 차지하는 비율에 따라 그 영향이 달라질 수 있다. 일반적으로 굉장히 작은 크기의 텍스처를 사용하거나, 텍스처를 사용하지 않고 애니메이션을 사용하지 않는 경우 Draco가 가장 높은 압축 성능을 보인다.</p>\n\n<p>Draco는 glTF 형식에 <a href=\"https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md\">KHR<em>draco</em>mesh_compression</a> extension을 사용하여 적용할 수 있다.</p>\n\n<h3 id=\"meshoptcompression\">Meshopt Compression</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b783796f2a01.png\" alt=\"image-20220512-180450-831.png\" /></p>\n\n<p><a href=\"https://github.com/zeux/meshoptimizer\">Meshoptimizer</a>는 Draco에 비해 더 lightweight한 라이브러리로 단순히 3D 모델의 파일 크기를 줄이는 것 뿐만 아니라 GPU 캐시를 더 활용하기 좋은 형태로 데이터를 가공하는데도 초점이 맞춰저 있어 런타임 성능을 증가시키는 데도 도움을 줄 수 있다.\n또한, Meshopt는 Geometry 뿐만 아니라 모든 바이너리 데이터에 대해 적용되며, 애니메이션이 포함된 경우에도 관련 데이터들을 압축할 수 있다.\n추가로, Meshopt를 통해 압축된 데이터는 gzip이나 brotli와 같은 encoding을 적용 가능하도록 구성되어 있기 때문에, 추가로 gzip 등을 이용하여 압축해야 높은 성능을 보인다.\nMeshoptimizer는 glTF 형식에 <a href=\"https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md\">EXT<em>meshopt</em>compression</a> extension을 사용하여 적용할 수 있다.</p>\n\n<h2 id=\"\">텍스처 최적화</h2>\n\n<p>텍스처는 일반적으로 2D 이미지 형태로 3D 모델과 함께 저장되며, 색상/법선 방향 등 여러 데이터에 해당하는 다수의 이미지를 사용할 수 있다. 텍스처 이미지는 웹에서 사용되는 PNG나 JPG 등 일반적인 형식을 사용 가능하며, 보통 2의 배수 크기(1024x1024, 2048x2048 등)를 사용한다. 이와 같이 일반적인 이미지 형식을 사용하기 때문에, 동일한 이미지 압축 기법을 텍스처 이미지에도 적용할 수 있으며 이 밖에 이미지 크기를 변경하거나 전용 형식을 활용하여 최적화하는 것이 가능하다.</p>\n\n<h3 id=\"\">텍스처 크기 선정</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b783fbf82bdb.png\" alt=\"image-20220512-180524-208.png\" /></p>\n\n<p>텍스처는 일반적으로 2의 배수 크기를 사용하기 때문에, 가로/세로 크기를 절반으로만 줄여도 전체 크기는 1/4로 감소한다. 즉, 그만큼 작은 크기의 텍스처를 사용하면 파일 크기도 크게 감소하는데, 두 가지 측면에서 작은 텍스처 크기를 사용하는 것이 유리하다. 먼저, 파일 크기 자체가 감소하기 때문에 네트워크 성능 면에서 이득이 있다. 그리고 네트워크에서 텍스처 이미지를 다운로드한 후에, GPU에서 참조하기 위해 텍스처의 압축을 해제하고 GPU에서 로드할 필요가 있는데 그 과정에서의 I/O 딜레이도 줄어들게 된다.</p>\n\n<p>물론 텍스처의 크기가 작아지면 3D 모델의 디테일이 떨어지기 때문에 적절한 크기를 찾는 것이 중요하다. 일반적으로 현세대의 대부분의 기기에서는 최대 4096x4096의 텍스처 크기를 사용할 수 있다. 아이폰3GS 등 오래된 기기에서는 최대 2048x2048까지의 텍스처를 사용할 수 있으므로 지원할 환경에 따라 최대 텍스처 크기를 정해놓는 것이 좋다.</p>\n\n<p>최대 텍스처 크기를 정한 후에는 3D 모델에 포함된 텍스처 이미지들의 크기를 조정하며 원본의 디테일을 잃지 않는 선에서 최대한 작은 크기의 텍스처를 사용하는 것이 좋다. glTF의 경우 메인 glTF 파일이 사람이 읽을 수 있는 JSON 형식이고 해당 파일 내부에서 다른 텍스처 이미지들을 참조하는 형태이기 때문에, 텍스처 이미지의 이름과 확장자만 동일하게 하면 쉽게 바꿀 수 있다. 따라서 크기가 다른 이미지로 바꾸면서 테스트해보고, 만약 디테일에 큰 차이가 없다면 작은 것을 사용하는 것이 성능 면에서 큰 이득을 가져다줄 수 있다.</p>\n\n<h3 id=\"\">텍스처 형식 선정과 최적화</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b7849b0730b1.png\" alt=\"image-20220512-180604-943.png\" /></p>\n\n<p>텍스처 이미지는 웹에서 사용되는 PNG나 JPG 등 일반적인 형식을 사용 가능하다. GIF와 같이 애니메이션이 포함된 이미지도 사용할 수는 있으나 애니메이션이 동작하게 하기 위해서는 별도의 처리가 필요하다.</p>\n\n<p>일반적으로 사용되는 이미지 형식인 PNG, JPG, WebP의 파일 크기를 비교해보면 같은 이미지일 때 보통 PNG가 가장 크고 WebP가 가장 작으므로 일반 이미지 형식 중에서는 WebP를 사용하는 것이 이득이 있다. 하지만 WebP는 iOS 14 이상에서만 사용할 수 있는 등 <a href=\"https://caniuse.com/webp\">환경 제약</a>이 있으므로, WebP를 기본으로 사용하되 WebP를 사용할 수 없는 환경에서의 fallback으로 다른 이미지 형식을 사용하는 방식이 좋다. glTF에서는 <a href=\"https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md\">EXT<em>texture</em>webp</a> extension을 통해 WebP 이미지를 사용할 수 있다. JPG는 파일 크기가 일반적으로 PNG보다 작지만 JPG는 알파 채널을 지원하지 않으며 손실 압축 방식을 사용하기 때문에 원본과 결과물이 달라질 수 있으므로 이러한 점을 고려하여 텍스처 형식을 선정해야 한다.</p>\n\n<p>텍스처 이미지는 일반 이미지 형식을 사용하므로 각 형식별로 일반적으로 사용되는 최적화 기법을 적용할 수도 있다. JPG와 WebP의 경우 다양한 손실 압축 기법을 사용 가능하고, PNG 또한 일부 이미지의 경우 추가로 비손실 압축이 가능하다. JPG와 WebP는 손실 압축 기법 사용 시 원본 이미지와 색상이나 디테일에 차이가 발생할 수 있기 때문에, 실제 3D 모델에 추가 압축 기법을 적용한 텍스처를 사용하면서 확인해보는 것이 중요하다.</p>\n\n<h3 id=\"basisuniversal\">Basis Universal 텍스처</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b786089136cb.png\" alt=\"image-20220512-180738-386.png\" />\n<span class=\"caption\">이미지 출처: <a href=\"https://www.khronos.org/ktx/\">https://www.khronos.org/ktx/</a></span></p>\n\n<p>KTX2/basis는 <a href=\"https://github.com/BinomialLLC/basis_universal\">BasisU(Basis Universal) Supercompressed GPU Texture Codec</a>을 사용하는 텍스처 이미지 형식으로, 높은 품질의 UASTC 모드와 낮은 품질의 ETC1S 모드가 있다. Basis Universal 텍스처는 PNG, JPG 등의 일반 이미지와 GPU에서 사용하는 데이터의 중간 단계로, 빠르게 다양한 GPU 압축 픽셀 형식으로 transcode될 수 있다. 특히 일반 이미지와 같은 크기일 때 GPU 내에서 훨씬 더 작은 메모리 용량을 차지하며 모바일/데스크톱 환경의 GPU가 각각 요구하는 적절한 형식으로 빠르게 변환될 수 있다. 이러한 특징 덕분에, 특히 ETC1S 모드는 일반적으로 파일 크기가 굉장히 작고 텍스처 이미지를 GPU에 업로드하기까지의 시간도 단축할 수 있으며 GPU 내에서의 메모리 사용량도 적다는 점 등 다양한 이점이 있다.</p>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b786c92d3ac3.png\" alt=\"image-20220512-180827-819.png\" /></p>\n\n<p>다만, ETC1S 모드 사용 시 사용 옵션 및 경우에 따라 원본 이미지의 디테일이 누락되는 경우가 발생하므로 이 점에 유의해서 사용할 필요가 있다.</p>\n\n<h2 id=\"\">그 밖의 최적화 기법</h2>\n\n<h3 id=\"gltf\">glTF 최적화</h3>\n\n<p>glTF의 구조에서 설명했던 것처럼, glTF 모델은 메인 glTF 파일과 바이너리 데이터를 담는 bin, 그리고 텍스처 이미지들로 구성된다. 이 중 메인 glTF 파일은 JSON 형식과 같은 형식이기 때문에 일반적으로 JSON 형식에 적용되는 minify 방식을 동일하게 적용할 수 있다. 또한, 모델 생성 과정에서 중복되거나 사용하지 않는 데이터가 포함될 수도 있는데, <a href=\"https://github.com/donmccurdy/glTF-Transform\">gltf-transform</a>과 같은 도구를 사용하여 이를 제거할 수 있다.</p>\n\n<h3 id=\"gzipbrotli\">gzip/brotli</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b787f6e05e57.png\" alt=\"image-20220512-180945-088.png\" /></p>\n\n<p>다른 최적화 기법과 함께, gzip이나 brotli와 같은 일반적인 비손실 압축 방식을 사용할 수 있다. 실제 3D 모델을 대상으로 각 방식을 사용한 결과를 비교해보면 텍스처 이미지에는 상대적으로 효과가 약했지만 그 밖의 데이터는 상당한 정도를 추가로 압축할 수 있었으며 일반적으로 brotli가 gzip에 비해 더 높은 압축 효율을 보였다.</p>\n\n<h3 id=\"progressiveloading\">Progressive Loading</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b78bb5993297.gif\" alt=\"pl.gif\" /></p>\n\n<p>텍스처 이미지로 일반 2D 이미지를 사용하므로 Progressive Loading을 사용할 수 있다. 이는 원본 이미지에 비해 훨씬 더 작은 크기를 갖는 이미지를 별도로 준비한 후 이를 먼저 로드하고 그 후에 원본 이미지로 교체하는 방식이다. 이 방식은 원본 이미지만 사용하는 것에 비해 훨씬 더 빠르게 3D 모델을 표시할 수 있기 때문에 사용자가 인터랙트 가능하기까지의 시간을 줄이는 것이 가능하다.</p>\n\n<h2 id=\"\">결과</h2>\n\n<p>현재 네이버 <a href=\"https://m.search.naver.com/search.naver?sm=mtp_hty.top&amp;where=m&amp;query=티라노사우루스\">통합검색 페이지</a> 및 <a href=\"https://m.search.naver.com/p/n.search/csearch/content/eprender.nhn?q=티라노사우루스&amp;where=m&amp;pkid=698&amp;key=DINO&amp;u1=25900842&amp;u2=&amp;u3=&amp;u4=csearch\">지식 인터랙티브</a> 서비스에서 사용하고 있는 티라노사우르스 모델을 대상으로, 위 방법들을 실제로 적용해본 결과를 공유한다.</p>\n\n<p><img src=\"/content/images/2022/05/0a710ba9-80ac-1f12-8180-e0a543971dfc.png\" alt=\"image-20220512-181516-128.png\" /></p>\n\n<p><img src=\"/content/images/2022/05/0a710ba9-80ac-1f12-8180-e0a57e721e00.png\" alt=\"image-20220512-181456-806.png\" /></p>\n\n<p>이 글에서 다뤘던 최적화 기법을 전부 적용했을 때, 위의 표와 차트에 표시한 결과와 같이 원본이 60MB인 3D 모델의 파일 크기를 약 98~99% 감소시켜 1MB 가량이 되었고 로드 시간도 85% 정도 감소하는 것을 확인할 수 있었다.</p>","rawText":"<p>이 글에서는 웹에서 주로 사용되는 3D 모델 형식인 glTF(GL Transmission Format)를 대상으로 적용할 수 있는 최적화 기법을 소개합니다. 이를 통해 웹에서 3D 모델을 사용할 때 발생할 수 있는 지연 시간과 관련된 문제를 해결하는 방법에 대해서 알아보겠습니다.</p>\n\n<h2 id=\"3dgltf\">3D 모델과 glTF</h2>\n\n<p>웹에서 3D 모델을 사용하는 것은 이미지나 비디오와 같은 다른 형태의 멀티미디어 콘텐츠를 사용하는 것과 별반 다르지 않다. 다만, 3D 모델을 웹페이지에서 표시하기 위해서는 다른 콘텐츠에 비해 몇 가지 더 고려할 사항이 있다.</p>\n\n<p>먼저, 3D 모델은 이미지나 비디오처럼 웹 브라우저에 <code>&lt;img&gt;</code>나 <code>&lt;video&gt;</code>와 같은 태그로 <code>src</code> 특성만 지정하는 형태로 바로 사용하는 것이 불가능하다. 3D 모델을 WebGL을 통해 렌더링하려면 <code>&lt;canvas&gt;</code> 태그를 사용하여 WebGL 컨텍스트를 받아와 렌더링하는 코드를 직접 작성할 필요가 있으며, 3D 모델 파일(glTF, FBX, OBJ 등) 또한 일종의 인코딩된 형태이기 때문에 실제 사용할 데이터를 받아오려면 파일을 로드하여 디코딩하는 과정을 거쳐야 한다. 이 과정은 <a href=\"https://threejs.org/\">Three.js</a>나 <a href=\"https://www.babylonjs.com/\">Babylon.js</a>와 같이 각종 3D 형식의 로드 및 디코딩을 지원하는 라이브러리를 사용하거나, <a href=\"https://naver.github.io/egjs-view3d/\">View3D</a>와 같은 3D 뷰어 컴포넌트를 활용하면 단순화할 수 있다.</p>\n\n<p>또한 3D 모델은 일반적으로 다른 콘텐츠에 비해 파일 크기가 큰 편이고, 데이터를 스트리밍하여 받아오기도 어렵기 때문에 상대적으로 최적화가 더 필요한 편이다. 물론 3D 모델 간에도 상대적인 차이는 있다. 예를 들어 4K 비디오와 480p 동영상의 파일 크기가 다르듯이, 3D 모델도 어떻게 구성하느냐에 따라서 파일 크기가 천차만별일 수 있다.</p>\n\n<p>3D 모델의 종류에는 여러 가지가 있지만, 대표적으로 polygonal mesh 형태의 3D 모델이 가장 많이 사용된다. <br />\npolygonal mesh 3D 모델을 구성하는 데이터를 간략히 나눠보면 크게 <strong>형태(geometry)</strong>, <strong>재질(material)</strong>, <strong>동작(animation)</strong>으로 나눠볼 수 있으며 그 밖에 장면 구성 데이터(빛, 카메라) 등이 있다. 각 요소를 살펴보면서, 어떠한 데이터가 3D 모델의 파일 크기를 차지하는지 알아보겠다.</p>\n\n<h3 id=\"geometry\">형태(geometry)</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b76681de6853.gif\" alt=\"geometry.gif\" /></p>\n\n<p>polygonal mesh 3D 모델은 정점(vertex), 정점들을 잇는 선(edge), 그리고 그 선들이 합쳐져 만들어지는 면(face)들로 이루어져 있다. 점 하나에 들어가는 데이터를 생각해보면, 먼저 각 점마다 3차원 좌표(x, y, z)가 반드시 포함되며 그 밖에 텍스처 데이터를 매핑하는 2차원 좌표인 UV 좌표, 점마다의 색상을 나타내는 3차원 데이터(r, g, b), 법선 방향을 나타내는 3차원 벡터 등이 포함될 수 있다.</p>\n\n<p>정점의 개수는 3D 모델의 디테일에 따라 다르며, 몇백~몇천 개부터 몇십~몇백만 개까지 사용될 수 있다. 이는 3D 모델을 생성하는 과정과 연관이 깊은데, 3D sculpting 프로그램을 통해 생성된 모델은 추가 처리를 하지 않을 경우 일반적으로 정점의 개수가 굉장히 많으며, 이 밖에 Subdivision Surface와 같은 modifier를 통해 정점의 개수와 디테일을 늘리고 표면을 더 부드럽게 만드는 방식 등이 많이 사용되고 있다.</p>\n\n<h3 id=\"material\">재질(material)</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b76831276b5c.png\" alt=\"image-20220512-173502-797.png\" /></p>\n\n<p>3D 모델이 어떤 색상을 갖는지, 빛을 비췄을 때는 어떤 특성을 갖고 있는지와 같이, 모델 표면의 성질을 나타내는 것이 재질(material)이다. 재질을 표현하기 위해 텍스처(texture)가 사용되는데, 일반적으로 2D 이미지 형태로 3D 모델에 저장된다.</p>\n\n<p>텍스처 이미지는 웹에서 사용되는 JPG나 PNG 형식 등이 사용되며, 지원 여부에 따라 WebP 형식을 사용하는 경우도 있다. 텍스처 이미지는 일반적으로 1024x1024, 2048x2048 등 2의 배수 크기를 사용하며, 2D 이미지를 사용하기 때문에 일반적으로 2D 이미지에 사용하는 것과 동일한 이미지 최적화 기법을 적용할 수 있다.</p>\n\n<h3 id=\"animations\">동작(animations)</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b769015e0edc.gif\" alt=\"animation.gif\" /></p>\n\n<p>3D 모델을 움직이게 하기 위해 일반적으로 3D 모델 내부에 뼈대를 심어 그 뼈대를 움직이는 skeletal animation(rigging) 방식을 사용한다. 실제로 사용되는 데이터의 경우 여러 저장 방식이 있으나, 대표적으로 정점마다 영향받는 뼈대의 id와 영향받는 정도(weight)를 같이 저장하는 방식이 있다. 이 경우 뼈대별로 offset matrix, 그리고 키프레임별로 애니메이션을 적용할 뼈대의 position, rotation, scale, 그리고 키프레임 간의 interpolation 방법 등이 같이 저장된다.</p>\n\n<h3 id=\"gltfgltransmissionformat\">glTF(GL Transmission Format)</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b773dd3562b6.png\" alt=\"image-20220512-174747-792.png\" /></p>\n\n<p><a href=\"https://github.com/KhronosGroup/glTF\">glTF</a>는 3D 모델을 저장하는 형식 중 하나로, 빠르고 효율적인 데이터 구조를 갖고 있어 웹에서 많이 사용되고 있다. 추가로, glTF는 물리 기반 렌더링, Skeletal Animation 등 현 세대에서 사용하는 많은 기능을 지원함은 물론 extension을 통해 다양한 기능을 추가로 사용할 수 있다.</p>\n\n<p>glTF는 메인이 되는 JSON 형식의 glTF 파일, 그리고 형태ㆍ동작 등 버퍼 데이터가 저장되는 바이너리 파일(.bin), 그리고 모델마다 상이하지만 다수의 텍스처 이미지로 구성된다. 혹은 이를 전부 합하여 하나의 바이너리 파일로 구성할 수도 있으며, 이 경우 glb 형식을 사용한다.</p>\n\n<h2 id=\"geometry\">Geometry 최적화</h2>\n\n<p>Geometry 최적화는 폴리곤 개수 감소와 Geometry Compression의 두 가지 측면에서 접근할 수 있다. 폴리곤 개수 감소는 정점 및 폴리곤의 개수를 감소시키는 방식으로 실제 데이터 양을 줄이는 것이기 때문에 모델의 디테일은 감소할 수 있으나 처리할 데이터의 절대적인 양이 감소하므로 모델 파일 크기을 줄일 뿐만 아니라 런타임 성능을 높일 수도 있다. Geometry Compression은 데이터를 압축하는 방법으로, 폴리곤 개수 감소에 더해 추가로 적용할 수 있다.</p>\n\n<h3 id=\"retopology\">Retopology</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b7743be962c4.png\" alt=\"image-20220512-174812-002.png\" /></p>\n\n<p><span class=\"caption\">이미지 출처: <a href=\"http://people.wku.edu/joon.sung/edu/anim/3d/modeling/retopology/retopology.html\">http://people.wku.edu/joon.sung/edu/anim/3d/modeling/retopology/retopology.html</a></span></p>\n\n<p>Retopology는 대표적으로 폴리곤 개수를 감소시키는 방법으로, Sculpting 등을 통해 생성된 Highpoly 모델을 원본 형태는 최대한 유지하면서 폴리곤의 개수는 더 적어지도록 수정한다. 이 방식의 경우 폴리곤의 절대적인 개수가 줄어들기 때문에 원본에 비해 디테일이 떨어지는 것은 사실이지만, 원본, 즉 Highpoly 상태에서 노멀맵을 생성한 후 Retopology가 적용된 모델에 생성된 노멀맵을 적용하여 원본의 디테일을 살리는 방법을 사용할 수 있다.</p>\n\n<h3 id=\"runtimemeshsimplification\">Runtime Mesh Simplification</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b776279f656b.png\" alt=\"image-20220512-175017-879.png\" /></p>\n\n<p><span class=\"caption\">3D 모델 출처: <a href=\"https://sketchfab.com/3d-models/juvenile-teratophoneus-curriei-2d7c4e880c2e45289ebbade3ec479979\">https://sketchfab.com/3d-models/juvenile-teratophoneus-curriei-2d7c4e880c2e45289ebbade3ec479979</a></span></p>\n\n<p>이 방식은 이름 그대로, 런타임에 geometry mesh를 단순화해 원본 모델의 형태를 최대한 유지하는 선에서 폴리곤 개수를 감소시키는 방식이다. 이 경우 Retopology와 동일한 효능을 얻을 수 있으나, 웹에서는 원본 3D 모델을 동일하게 다운로드해야 한다는 문제가 있다. 따라서 런타임 성능의 문제로 병목이 생기는 경우가 아니라면 원본 모델을 사용하는 것이 낫고, 이 방식을 사용하면 디테일만 낮출 뿐이라는 한계가 있다.</p>\n\n<h3 id=\"dracomeshcompression\">Draco Mesh Compression</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b7827e6e1de8.png\" alt=\"image-20220512-180346-572.png\" /></p>\n\n<p><span class=\"caption\">이미지 출처: <a href=\"https://opensource.googleblog.com/2017/01/introducing-draco-compression-for-3d.html\">https://opensource.googleblog.com/2017/01/introducing-draco-compression-for-3d.html</a></span></p>\n\n<p><a href=\"https://github.com/google/draco\">Draco</a>는 Google이 만든 mesh/point cloud compression 라이브러리로, 형태와 관련된 데이터를 높은 효율로 압축하는 것이 가능하다. 다만 Draco는 애니메이션 관련 데이터나 텍스처 데이터를 압축하지는 못하기 때문에 모델 내에서 형태 데이터가 차지하는 비율에 따라 그 영향이 달라질 수 있다. 일반적으로 굉장히 작은 크기의 텍스처를 사용하거나, 텍스처를 사용하지 않고 애니메이션을 사용하지 않는 경우 Draco가 가장 높은 압축 성능을 보인다.</p>\n\n<p>Draco는 glTF 형식에 <a href=\"https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md\">KHR<em>draco</em>mesh_compression</a> extension을 사용하여 적용할 수 있다.</p>\n\n<h3 id=\"meshoptcompression\">Meshopt Compression</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b783796f2a01.png\" alt=\"image-20220512-180450-831.png\" /></p>\n\n<p><a href=\"https://github.com/zeux/meshoptimizer\">Meshoptimizer</a>는 Draco에 비해 더 lightweight한 라이브러리로 단순히 3D 모델의 파일 크기를 줄이는 것 뿐만 아니라 GPU 캐시를 더 활용하기 좋은 형태로 데이터를 가공하는데도 초점이 맞춰저 있어 런타임 성능을 증가시키는 데도 도움을 줄 수 있다.\n또한, Meshopt는 Geometry 뿐만 아니라 모든 바이너리 데이터에 대해 적용되며, 애니메이션이 포함된 경우에도 관련 데이터들을 압축할 수 있다.\n추가로, Meshopt를 통해 압축된 데이터는 gzip이나 brotli와 같은 encoding을 적용 가능하도록 구성되어 있기 때문에, 추가로 gzip 등을 이용하여 압축해야 높은 성능을 보인다.\nMeshoptimizer는 glTF 형식에 <a href=\"https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_meshopt_compression/README.md\">EXT<em>meshopt</em>compression</a> extension을 사용하여 적용할 수 있다.</p>\n\n<h2 id=\"\">텍스처 최적화</h2>\n\n<p>텍스처는 일반적으로 2D 이미지 형태로 3D 모델과 함께 저장되며, 색상/법선 방향 등 여러 데이터에 해당하는 다수의 이미지를 사용할 수 있다. 텍스처 이미지는 웹에서 사용되는 PNG나 JPG 등 일반적인 형식을 사용 가능하며, 보통 2의 배수 크기(1024x1024, 2048x2048 등)를 사용한다. 이와 같이 일반적인 이미지 형식을 사용하기 때문에, 동일한 이미지 압축 기법을 텍스처 이미지에도 적용할 수 있으며 이 밖에 이미지 크기를 변경하거나 전용 형식을 활용하여 최적화하는 것이 가능하다.</p>\n\n<h3 id=\"\">텍스처 크기 선정</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b783fbf82bdb.png\" alt=\"image-20220512-180524-208.png\" /></p>\n\n<p>텍스처는 일반적으로 2의 배수 크기를 사용하기 때문에, 가로/세로 크기를 절반으로만 줄여도 전체 크기는 1/4로 감소한다. 즉, 그만큼 작은 크기의 텍스처를 사용하면 파일 크기도 크게 감소하는데, 두 가지 측면에서 작은 텍스처 크기를 사용하는 것이 유리하다. 먼저, 파일 크기 자체가 감소하기 때문에 네트워크 성능 면에서 이득이 있다. 그리고 네트워크에서 텍스처 이미지를 다운로드한 후에, GPU에서 참조하기 위해 텍스처의 압축을 해제하고 GPU에서 로드할 필요가 있는데 그 과정에서의 I/O 딜레이도 줄어들게 된다.</p>\n\n<p>물론 텍스처의 크기가 작아지면 3D 모델의 디테일이 떨어지기 때문에 적절한 크기를 찾는 것이 중요하다. 일반적으로 현세대의 대부분의 기기에서는 최대 4096x4096의 텍스처 크기를 사용할 수 있다. 아이폰3GS 등 오래된 기기에서는 최대 2048x2048까지의 텍스처를 사용할 수 있으므로 지원할 환경에 따라 최대 텍스처 크기를 정해놓는 것이 좋다.</p>\n\n<p>최대 텍스처 크기를 정한 후에는 3D 모델에 포함된 텍스처 이미지들의 크기를 조정하며 원본의 디테일을 잃지 않는 선에서 최대한 작은 크기의 텍스처를 사용하는 것이 좋다. glTF의 경우 메인 glTF 파일이 사람이 읽을 수 있는 JSON 형식이고 해당 파일 내부에서 다른 텍스처 이미지들을 참조하는 형태이기 때문에, 텍스처 이미지의 이름과 확장자만 동일하게 하면 쉽게 바꿀 수 있다. 따라서 크기가 다른 이미지로 바꾸면서 테스트해보고, 만약 디테일에 큰 차이가 없다면 작은 것을 사용하는 것이 성능 면에서 큰 이득을 가져다줄 수 있다.</p>\n\n<h3 id=\"\">텍스처 형식 선정과 최적화</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b7849b0730b1.png\" alt=\"image-20220512-180604-943.png\" /></p>\n\n<p>텍스처 이미지는 웹에서 사용되는 PNG나 JPG 등 일반적인 형식을 사용 가능하다. GIF와 같이 애니메이션이 포함된 이미지도 사용할 수는 있으나 애니메이션이 동작하게 하기 위해서는 별도의 처리가 필요하다.</p>\n\n<p>일반적으로 사용되는 이미지 형식인 PNG, JPG, WebP의 파일 크기를 비교해보면 같은 이미지일 때 보통 PNG가 가장 크고 WebP가 가장 작으므로 일반 이미지 형식 중에서는 WebP를 사용하는 것이 이득이 있다. 하지만 WebP는 iOS 14 이상에서만 사용할 수 있는 등 <a href=\"https://caniuse.com/webp\">환경 제약</a>이 있으므로, WebP를 기본으로 사용하되 WebP를 사용할 수 없는 환경에서의 fallback으로 다른 이미지 형식을 사용하는 방식이 좋다. glTF에서는 <a href=\"https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Vendor/EXT_texture_webp/README.md\">EXT<em>texture</em>webp</a> extension을 통해 WebP 이미지를 사용할 수 있다. JPG는 파일 크기가 일반적으로 PNG보다 작지만 JPG는 알파 채널을 지원하지 않으며 손실 압축 방식을 사용하기 때문에 원본과 결과물이 달라질 수 있으므로 이러한 점을 고려하여 텍스처 형식을 선정해야 한다.</p>\n\n<p>텍스처 이미지는 일반 이미지 형식을 사용하므로 각 형식별로 일반적으로 사용되는 최적화 기법을 적용할 수도 있다. JPG와 WebP의 경우 다양한 손실 압축 기법을 사용 가능하고, PNG 또한 일부 이미지의 경우 추가로 비손실 압축이 가능하다. JPG와 WebP는 손실 압축 기법 사용 시 원본 이미지와 색상이나 디테일에 차이가 발생할 수 있기 때문에, 실제 3D 모델에 추가 압축 기법을 적용한 텍스처를 사용하면서 확인해보는 것이 중요하다.</p>\n\n<h3 id=\"basisuniversal\">Basis Universal 텍스처</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b786089136cb.png\" alt=\"image-20220512-180738-386.png\" />\n<span class=\"caption\">이미지 출처: <a href=\"https://www.khronos.org/ktx/\">https://www.khronos.org/ktx/</a></span></p>\n\n<p>KTX2/basis는 <a href=\"https://github.com/BinomialLLC/basis_universal\">BasisU(Basis Universal) Supercompressed GPU Texture Codec</a>을 사용하는 텍스처 이미지 형식으로, 높은 품질의 UASTC 모드와 낮은 품질의 ETC1S 모드가 있다. Basis Universal 텍스처는 PNG, JPG 등의 일반 이미지와 GPU에서 사용하는 데이터의 중간 단계로, 빠르게 다양한 GPU 압축 픽셀 형식으로 transcode될 수 있다. 특히 일반 이미지와 같은 크기일 때 GPU 내에서 훨씬 더 작은 메모리 용량을 차지하며 모바일/데스크톱 환경의 GPU가 각각 요구하는 적절한 형식으로 빠르게 변환될 수 있다. 이러한 특징 덕분에, 특히 ETC1S 모드는 일반적으로 파일 크기가 굉장히 작고 텍스처 이미지를 GPU에 업로드하기까지의 시간도 단축할 수 있으며 GPU 내에서의 메모리 사용량도 적다는 점 등 다양한 이점이 있다.</p>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b786c92d3ac3.png\" alt=\"image-20220512-180827-819.png\" /></p>\n\n<p>다만, ETC1S 모드 사용 시 사용 옵션 및 경우에 따라 원본 이미지의 디테일이 누락되는 경우가 발생하므로 이 점에 유의해서 사용할 필요가 있다.</p>\n\n<h2 id=\"\">그 밖의 최적화 기법</h2>\n\n<h3 id=\"gltf\">glTF 최적화</h3>\n\n<p>glTF의 구조에서 설명했던 것처럼, glTF 모델은 메인 glTF 파일과 바이너리 데이터를 담는 bin, 그리고 텍스처 이미지들로 구성된다. 이 중 메인 glTF 파일은 JSON 형식과 같은 형식이기 때문에 일반적으로 JSON 형식에 적용되는 minify 방식을 동일하게 적용할 수 있다. 또한, 모델 생성 과정에서 중복되거나 사용하지 않는 데이터가 포함될 수도 있는데, <a href=\"https://github.com/donmccurdy/glTF-Transform\">gltf-transform</a>과 같은 도구를 사용하여 이를 제거할 수 있다.</p>\n\n<h3 id=\"gzipbrotli\">gzip/brotli</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b787f6e05e57.png\" alt=\"image-20220512-180945-088.png\" /></p>\n\n<p>다른 최적화 기법과 함께, gzip이나 brotli와 같은 일반적인 비손실 압축 방식을 사용할 수 있다. 실제 3D 모델을 대상으로 각 방식을 사용한 결과를 비교해보면 텍스처 이미지에는 상대적으로 효과가 약했지만 그 밖의 데이터는 상당한 정도를 추가로 압축할 수 있었으며 일반적으로 brotli가 gzip에 비해 더 높은 압축 효율을 보였다.</p>\n\n<h3 id=\"progressiveloading\">Progressive Loading</h3>\n\n<p><img src=\"/content/images/2022/05/0a710dbd-80ac-1c4e-8180-b78bb5993297.gif\" alt=\"pl.gif\" /></p>\n\n<p>텍스처 이미지로 일반 2D 이미지를 사용하므로 Progressive Loading을 사용할 수 있다. 이는 원본 이미지에 비해 훨씬 더 작은 크기를 갖는 이미지를 별도로 준비한 후 이를 먼저 로드하고 그 후에 원본 이미지로 교체하는 방식이다. 이 방식은 원본 이미지만 사용하는 것에 비해 훨씬 더 빠르게 3D 모델을 표시할 수 있기 때문에 사용자가 인터랙트 가능하기까지의 시간을 줄이는 것이 가능하다.</p>\n\n<h2 id=\"\">결과</h2>\n\n<p>현재 네이버 <a href=\"https://m.search.naver.com/search.naver?sm=mtp_hty.top&amp;where=m&amp;query=티라노사우루스\">통합검색 페이지</a> 및 <a href=\"https://m.search.naver.com/p/n.search/csearch/content/eprender.nhn?q=티라노사우루스&amp;where=m&amp;pkid=698&amp;key=DINO&amp;u1=25900842&amp;u2=&amp;u3=&amp;u4=csearch\">지식 인터랙티브</a> 서비스에서 사용하고 있는 티라노사우르스 모델을 대상으로, 위 방법들을 실제로 적용해본 결과를 공유한다.</p>\n\n<p><img src=\"/content/images/2022/05/0a710ba9-80ac-1f12-8180-e0a543971dfc.png\" alt=\"image-20220512-181516-128.png\" /></p>\n\n<p><img src=\"/content/images/2022/05/0a710ba9-80ac-1f12-8180-e0a57e721e00.png\" alt=\"image-20220512-181456-806.png\" /></p>\n\n<p>이 글에서 다뤘던 최적화 기법을 전부 적용했을 때, 위의 표와 차트에 표시한 결과와 같이 원본이 60MB인 3D 모델의 파일 크기를 약 98~99% 감소시켜 1MB 가량이 되었고 로드 시간도 85% 정도 감소하는 것을 확인할 수 있었다.</p>","href":"this.company.rssUrl웹 3D 모델 최적화 기법 소개"}