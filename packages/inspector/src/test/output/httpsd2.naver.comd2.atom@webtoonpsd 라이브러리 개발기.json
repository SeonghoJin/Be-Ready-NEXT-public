{"company":{"imageUrl":"/companyImages/naver.ico","name":"네이버","rssUrl":"https://d2.naver.com/d2.atom","href":"https://d2.naver.com/d2.atom","basePath":"https://d2.naver.com"},"title":"@webtoon/psd 라이브러리 개발기","createdAt":"2022-06-28T16:18:30Z","description":"@webtoon/psd 라이브러리는 TypeScript로 작성한 Adobe Photoshop(이하 포토샵) 파일 파싱 라이브러리로, 브라우저 및 NodeJS 환경에서 포토샵 파일 정보를 읽어와 레이어 이미지를 비롯한 다양한 메타데이터를 추출할 수 있습니다.\n\n필자는 네이버 웹툰에서 포토샵 파일을 활용하는 웹 애플리케이션을 개발하고 있습니다. 그 과정에서 요구 조건을 만족하는 라이브러리가 없어서 직접 개발했습니다. 이 글에서는 라이브러리를 개발하면서 얻은 지식과 경험을 공유합니다.\n\n@webtoon/psd 라이브러리 코드는 GitHub에 공개되어 있으며 NPM 또는 Yarn에서 다운로드할 수 있습니다.\n\n    \n\n라이브러리 개발 배경\n\n웹툰 작가가 작품을 창작할 때 사용하는 도구에는 여러 가지가 있지만 그중 포토샵을 빼놓을 수 없다. .psd 확장자 파일은 포토샵에서 작업한 결과물을 저장할 때 생성되는 파일로, 이미지 데이터를 비롯한 다양한 메타데이터를 포함하고 있다.\n\n웹 애플리케이션에서 포토샵 파일 정보를 활용하고 싶다면 두 가지 방법이 있다.\n\n\n로컬에서 선택한 파일을 서버에 업로드하여 분석, 이미지 및 메타데이터를 추출한 뒤 다운로드\n브라우저에서 바로 포토샵 파일을 분석, 이미지 및 메타데이터 추출\n\n\n작가가 작업한 포토샵 파일은 크게는 몇백 MB로, 파일을 서버에 업로드하여 분석하는 과정을 거친다면 파일 정보 파악에 시간이 오래 걸린다. 따라서 웹 애플리케이션에서 직접 포토샵 파일을 열어 데이터를 분석해야 한다.\n\n오픈소스로 공개된 라이브러리 중에는 이미 JavaScript 기반 포토샵 파일 파싱 라이브러리가 있다. 바로 PSD.js라는 라이브러리로, JavaScript 런타임 환경에서 포토샵 파일을 다뤄야 할 때 대부분 사용하고 있다. 하지만 PSD.js는 다음과 같은 항목이 우리의 요구 사항에 부합하지 않아 사용할 수 없었다.\n\n\n한글 미지원: 알파벳 문자만 지원하며 한국어 및 특수문자로 된 데이터를 파싱할 수 없음\n퍼포먼스 이슈: 대용량 이미지 데이터를 처리할 때 퍼포먼스 이슈 발생\n대용량 파일 미지원: 포토샵 대용량 파일(.psb)을 파싱할 수 없음\n소스코드 파일 크기: 다양한 라이브러리에 의존성이 있어 최종 번들링된 파일이 상대적으로 큼\n\n\n특히 한글(한자) 텍스트 데이터는 동양권 작가가 편집한 포토샵 파일에서 반드시 추출해야 하는 정보였기에 한글 미지원 문제는 반드시 해결해야 했고, 결국 직접 라이브러리를 개발해야 한다는 결론에 다다랐다.\n\n포토샵 파일 구조\n\n.psd 또는 .psb 확장자의 바이너리 파일은 다음과 같이 다섯 가지 섹션으로 나뉘어 정보를 담고 있다. 각 섹션에 대한 자세한 정보와 세부 데이터 내용은 Adobe에서 공개한 File Formats Specification 문서에서 확인할 수 있다.\n\n\n\n\nFileHeader: 정상적인 포토샵 파일인지 판별할 수 있는 signature 정보와 이미지의 가로, 세로 길이 색상 타입 등 메타데이터 정보를 담고 있다.\nColorModeData: Duotone 컬러 또는 인덱싱된 컬러값 정보를 담고 있다.\nImageResources: 포토샵에서 활용하는 편집 상태 값 정보를 담고 있다.(예: GuideLine, Slices, EXIF Data 등)\nLayerAndMaskInformation: 레이어(그룹)와 레이어 이미지 픽셀, 그리고 레이어(그룹)에 적용된 효과 정보를 담고 있다.\nImageData: 포토샵 파일을 저장할 때 '호환성 최대화' 옵션을 사용한 경우 최종 합성된 포토샵 파일의 미리보기 이미지 데이터가 담긴다.\n\n\n만약 포토샵 파일의 미리보기 이미지를 추출하기 위해 검색하다가 이 글을 발견했다면, ImageData 섹션을 찾아서 추출하기 바란다. 간단하게 최종 합성된 미리보기 이미지를 획득할 수 있다.\n\n바이너리 파일 읽기\n\n브라우저에서 파일을 열었을 때 ArrayBuffer 바이너리 데이터 객체가 주어지는데, 이 객체는 Typed Array API의 DataView 클래스를 사용해 탐색할 수 있다. DataView는 다양한 형식의 값을 읽고 쓸 수 있으며 엔디안을 직접 선택할 수 있기 때문에 PSD와 같은 바이너리 파일을 읽기에 알맞다. 반면 Typed Arrays API의 Uint8Array, Uint16Array와 같은 자료 구조는 한 가지 타입을 읽고 쓰는 용도로 최적화되어 있으며 현재 플랫폼의 엔디안을 따르기 때문에 형식이 정해진 바이너리 파일을 읽고 쓰기에는 부적합하다.\n\n아래 내용부터는 데이터를 읽는 과정을 표현할 때 편의상 '배열'을 읽었다고 하겠다.\n\n각 섹션에 어떤 정보가 저장되어 있고 어떻게 읽는지 알아보자. 간단히 FileHeader 섹션을 읽어보겠다. PSD File Formats Specification 문서에 따르면 FileHeader 섹션의 구조는 다음과 같다.\n\n\n\n위 표의 일부분을 배열로 표현하면 다음과 같다. 아래 그림에서 첫 번째 줄은 각 바이트가 담고 있는 블록을 도식화한 배열이고 두 번째 줄은 각 바이트에 담긴 값의 예다. 마지막 세 번째 줄은 첫 번째 바이트에 담겨있는 데이터를 비트 단위로 표현한 예다.\n\n\n\nsignature 블록 읽기(문자열 블록)\n\nsignature 블록은 4바이트로 구성되어 있으며 문자열 타입으로 읽어야 한다. 각 바이트에 저장된 값을 ASCII 코드표에 대입하여 문자열을 완성할 수 있다. JavaScript 언어에서는 String 객체에 내장 함수를 제공하여 간단히 ASCII 코드를 그에 해당하는 문자열로 변환할 수 있다.\n\nconst signature = [56, 66, 80, 83];  \nconst value = signature  \n  .map((num) => String.fromCharCode(num))\n  .join(‘’);\n\nconsole.log(value); // \"8BPS\"  \n\n\n만약 위 4바이트 블록을 읽은 결과물이 문자열로 \"8BPS\"가 아니라면 해당 바이너리 파일은 포토샵 파일이 아니므로 적절히 예외로 처리하는 코드를 파싱 라이브러리에 추가한다.\n\nheight 블록 읽기(숫자 블록)\n\nsignature 블록은 문자열을 읽으면 되므로 각 바이트를 ASCII 테이블에 대입, 문자열 하나로 변환했다. 하지만 동일한 4바이트를 숫자로 읽으려면 다른 방식으로 읽어야 한다. 연속된 4바이트에 기록된 숫자를 읽을 땐 시프트 연산자를 사용한다. 배열의 각 칸을 방문하면서 칸의 인덱스와 숫자 값을 수식에 대입해 전체 숫자를 계산할 수 있다.\n\nconst height = [0,0,5,0];  \nconst value = height  \n  .map((num, idx, {length}) => num << (length - idx - 1) * 8)\n  .reduce((acc, cur) => acc + cur, 0);\n\nconsole.log(value); // 1280  \n\n\n시프트 연산을 하는 수식에서 8을 곱하는 이유는 1바이트가 8비트이기 때문이다.\n\n참고로, height 블록을 읽을 때는 음수를 고려하지 않았다. 높이, 너비는 음수일 수 없기 때문에 height 블록에 담겨있는 비트는 Unsigned type으로 읽었다. 하지만 X, Y 좌표와 같이 음수일 가능성이 있는 블록에 담겨있는 값은 Signed type으로 취급해야 한다. Signed type은 비트 배열에서 가장 앞에 위치한 비트를 기준으로 양수/음수를 판별할 수 있으며 0이면 양수, 1이면 음수임을 의미한다. 예를 들어, \"10100101\"이라는 값은 Signed type으로 취급하느냐, Unsigned type으로 취급하느냐에 따라 다른 값으로 읽을 수 있다.\n\n\n\nparseInt(\"10100101\"); // 151  \nparseInt(\"01011011\"); // 91  \n\n\n이진수 \"01011011\"을 십진수로 변환한 값은 91이며, 가장 앞자리 비트의 값이 1이었으므로 최종 값은 -91이 된다.\n\n\n  2의 보수에 대한 자세한 설명은 위키백과의 2의 보수를 참고한다.\n\n\n다음과 같이 메서드를 공통화하여 작성해두면 바이트 단위로 숫자를 읽을 때 호출하여 간단히 십진수 값을 구할 수 있다.\n\nconst unsignedToSigned = (x, bitLength)=> {  \n  if(x >= Math.pow(2, bitLength - 1))\n    return x - Math.pow(2, bitLength);\n\n  return xl\n};\n\n\n길이가 유동적인 블록 읽기\n\n앞서 살펴본 블럭들은 각각 차지하는 바이트 길이가 고정되어, 배열에서 해당 길이만큼 가져와 읽기 동작을 수행하면 되었다. 하지만 작가가 직접 입력하는 데이터인 '레이어 이름'과 같은 항목은 길이가 유동적일 수밖에 없다. 레이어 이름의 최대 길이는 정해져 있지만 짧은 문자열을 입력해도 최대 길이만큼 비트를 비워두는 것은 비효율적이다.\n\n문서에서 길이가 유동적인 데이터는 다음과 같은 형태로 안내하고 있다.\n\n\n\n먼저 길이가 정해진 숫자 블록이 있고 이 블록은 뒤따라오는 블록의 크기 값을 저장하고 있다. 따라서 먼저 앞 블록을 읽어서 크기 정보를 알아낸 뒤 해당 길이만큼 뒤 칸의 정보를 읽어내면 레이어 이름을 알 수 있다.\n\n위 표를 그림으로 그려보면 다음과 같다.\n\n\n\n먼저 2바이트로 길이가 고정된 블록인 length 블록을 읽어서 길잇값 10을 얻는다. 그리고 그 뒤에 길이가 유동적인 블록 data 블록을 10바이트 읽어서 문자열 \"layer name\"을 얻을 수 있다.\n\nCursor 객체 사용하기\n\n앞서 signature 블록, height 블록, 길이가 유동적인 블록을 읽는 방법을 살펴보았다. 이처럼 데이터를 읽는 과정은 문서를 참고하여 특정 블록을 떼어와 의미있는 정보로 변환하는 작업의 연속이다. 하지만 개발자가 직접 배열에 접근하여 i 번째 위치부터 j 번째 위치까지 N개의 비트를 떼어오는 과정을 하나하나 지정하기는 너무 번거로우며 번거로운 작업에서는 필연적으로 버그가 발생한다.\n\n따라서 배열에서 현재까지 읽은 위칫값을 저장하고 데이터를 읽을 때마다 위칫값을 갱신해주는 Cursor 객체를 둔다면 보다 수월하게 바이너리 데이터를 읽을 수 있다.\n\n하드디스크 장치를 열어보면 디스크에 저장된 데이터를 읽어오기 위해서 head라는 부품이 플레이트에 얹어져 자성을 읽도록 되어있는데, 이러한 구조를 소프트웨어적으로 모방했다고 보면 이해가 쉽다.\n\n\n\nclass Cursor {  \n  constructor(\n    public arr: Array<number>,\n    public position: number\n  ) { }\n\n  read(type: \"i8\" | \"u8\"): number {\n    ... position += 1;\n  }\n\n  readString(length: number): string {\n    ... position += length;\n  }\n}\n\n\nCursor 객체를 위와 같이 만들어 위치 정보를 갖게 한다. 메서드가 호출되었을 때 현재 위치부터 지정된 길이까지 데이터 블록을 읽고 위치를 갱신한 뒤 변환된 데이터를 반환한다. 개발자는 배열 속 현재 위치에 신경 쓰지 않고 문서에 나열된 순서에 따라 포토샵 파일 정보를 읽고 변환하는 코드를 작성할 수 있다.\n\nreadNumber 또는 readString 메서드를 호출하여 같은 1바이트를 읽더라도 Unsigned number type으로 읽을지, Signed number type으로 읽을지, String 타입으로 읽을지 선택할 수 있으며, 각각의 메서드 반환 값이 다르다.\n\n\n\n이미지 데이터 디코딩하기\n\n포토샵 파일을 읽는 목적은 궁극적으로 파일에 담긴 각 이미지 데이터를 얻는 것이다. 포토샵 파일에는 각 레이어 이미지 데이터와 미리보기 이미지 데이터가 존재한다. 이미지 데이터는 효율적으로 저장 공간을 차지하기 위해 기본적으로 런 렝스 부호화(run-length encoding) 압축 기술을 사용하여 저장된다.\n\n런 렝스 부호화는 데이터에서 같은 값이 연속되어 나타날 경우 그 값과 반복되는 횟수로 표현하는 방법이다. 가령, \"AAABB\" 문자열을 런 렝스 부호화로 압축할 경우 \"3A2B\" 으로 압축할 수 있다. 이미지 데이터는 RGBA 값으로 표현되는데, 각각 red(R), green(G), blue(B), alpha(A)를 나타낸다. 연속된 숫자, 즉 동일한 색상이 많을수록 반복 횟수로 표현할 수 있는 데이터가 많아지고 압축률이 높아진다.\n\n포토샵 파일은 이미지를 구성하는 각 픽셀의 R, G, B, A 값을 별도의 채널로 모아서 압축하여 보관한다. 따라서 각 채널의 내용을 해독하여 R, G, B, A 값을 하나로 모아 각 픽셀을 복원하는 과정을 거쳐야 우리가 원하는 이미지 데이터를 얻을 수 있다.\n\n\n\nR이 모두 출현한 뒤 G, B, 그리고 A가 모여있는 형태의 배열에서 RGBARGBA 값들이 반복되도록 이미지 픽셀 데이터를 복구한다.\n\n이미지 데이터를 디코딩하는 과정은 반복문을 순회하면서 RGBA 데이터를 취합하고 연결하는 작업의 연속이다. 이런 반복 작업은 WebAssembly를 사용하면 성능을 더욱 끌어올릴 수 있는데, 해당 내용은 2편에 이어서 작성하겠다.\n\n마치며\n\n지금까지 포토샵 파일을 웹 애플리케이션 환경에서 읽어내는 과정을 살펴보았다. 라이브러리를 개발하며 처음 언급했던 문제를 모두 해결할 수 있었다.\n\n의존성 라이브러리 없이 개발했기에 최종 번들링된 소스코드 파일 크기도 작고, 한글과 특수문자, 이모티콘 문자열도 모두 지원한다. 또한 대용량 포토샵 파일(.psb)도 적절히 분기 처리해 완벽히 데이터를 읽을 수 있다. 무엇보다도, 데이터를 읽는 속도와 디코딩하는 속도가 빠르다.\n\n\n\nv0.1.2 기준으로 벤치마킹을 실행해 보았더니 타 라이브러리와 비교했을 때 파일 크기는 대략 17분의 1 크기로 줄었고, 데이터 읽기 속도는 대략 7배 빨라졌다. 특히 이미지를 디코딩하는 속도가 대폭 개선된 것을 확인했다.\n\n이미지 데이터와 레이어 메타데이터를 파싱하는 기능만 오픈소스로 배포했지만, 계속해서 폰트 데이터를 비롯한 다양한 데이터를 파싱할 수 있도록 기능을 추가할 계획이다. 이 포스트를 읽는 분 중 바이너리 파일을 다루는 데에 관심이 있는 분이 있었다면 도움이 되었길 바란다.\n\n포토샵 파일을 다루는 상황에 있다면 @webtoon/psd 라이브러리 사용을 적극 추천한다. 부족한 기능이 있다면 직접 구현도 해보자. Pull Request는 언제나 환영이다!}","rawText":"@webtoon/psd 라이브러리는 TypeScript로 작성한 Adobe Photoshop(이하 포토샵) 파일 파싱 라이브러리로, 브라우저 및 NodeJS 환경에서 포토샵 파일 정보를 읽어와 레이어 이미지를 비롯한 다양한 메타데이터를 추출할 수 있습니다.\n\n필자는 네이버 웹툰에서 포토샵 파일을 활용하는 웹 애플리케이션을 개발하고 있습니다. 그 과정에서 요구 조건을 만족하는 라이브러리가 없어서 직접 개발했습니다. 이 글에서는 라이브러리를 개발하면서 얻은 지식과 경험을 공유합니다.\n\n@webtoon/psd 라이브러리 코드는 GitHub에 공개되어 있으며 NPM 또는 Yarn에서 다운로드할 수 있습니다.\n\n    \n\n라이브러리 개발 배경\n\n웹툰 작가가 작품을 창작할 때 사용하는 도구에는 여러 가지가 있지만 그중 포토샵을 빼놓을 수 없다. .psd 확장자 파일은 포토샵에서 작업한 결과물을 저장할 때 생성되는 파일로, 이미지 데이터를 비롯한 다양한 메타데이터를 포함하고 있다.\n\n웹 애플리케이션에서 포토샵 파일 정보를 활용하고 싶다면 두 가지 방법이 있다.\n\n\n로컬에서 선택한 파일을 서버에 업로드하여 분석, 이미지 및 메타데이터를 추출한 뒤 다운로드\n브라우저에서 바로 포토샵 파일을 분석, 이미지 및 메타데이터 추출\n\n\n작가가 작업한 포토샵 파일은 크게는 몇백 MB로, 파일을 서버에 업로드하여 분석하는 과정을 거친다면 파일 정보 파악에 시간이 오래 걸린다. 따라서 웹 애플리케이션에서 직접 포토샵 파일을 열어 데이터를 분석해야 한다.\n\n오픈소스로 공개된 라이브러리 중에는 이미 JavaScript 기반 포토샵 파일 파싱 라이브러리가 있다. 바로 PSD.js라는 라이브러리로, JavaScript 런타임 환경에서 포토샵 파일을 다뤄야 할 때 대부분 사용하고 있다. 하지만 PSD.js는 다음과 같은 항목이 우리의 요구 사항에 부합하지 않아 사용할 수 없었다.\n\n\n한글 미지원: 알파벳 문자만 지원하며 한국어 및 특수문자로 된 데이터를 파싱할 수 없음\n퍼포먼스 이슈: 대용량 이미지 데이터를 처리할 때 퍼포먼스 이슈 발생\n대용량 파일 미지원: 포토샵 대용량 파일(.psb)을 파싱할 수 없음\n소스코드 파일 크기: 다양한 라이브러리에 의존성이 있어 최종 번들링된 파일이 상대적으로 큼\n\n\n특히 한글(한자) 텍스트 데이터는 동양권 작가가 편집한 포토샵 파일에서 반드시 추출해야 하는 정보였기에 한글 미지원 문제는 반드시 해결해야 했고, 결국 직접 라이브러리를 개발해야 한다는 결론에 다다랐다.\n\n포토샵 파일 구조\n\n.psd 또는 .psb 확장자의 바이너리 파일은 다음과 같이 다섯 가지 섹션으로 나뉘어 정보를 담고 있다. 각 섹션에 대한 자세한 정보와 세부 데이터 내용은 Adobe에서 공개한 File Formats Specification 문서에서 확인할 수 있다.\n\n\n\n\nFileHeader: 정상적인 포토샵 파일인지 판별할 수 있는 signature 정보와 이미지의 가로, 세로 길이 색상 타입 등 메타데이터 정보를 담고 있다.\nColorModeData: Duotone 컬러 또는 인덱싱된 컬러값 정보를 담고 있다.\nImageResources: 포토샵에서 활용하는 편집 상태 값 정보를 담고 있다.(예: GuideLine, Slices, EXIF Data 등)\nLayerAndMaskInformation: 레이어(그룹)와 레이어 이미지 픽셀, 그리고 레이어(그룹)에 적용된 효과 정보를 담고 있다.\nImageData: 포토샵 파일을 저장할 때 '호환성 최대화' 옵션을 사용한 경우 최종 합성된 포토샵 파일의 미리보기 이미지 데이터가 담긴다.\n\n\n만약 포토샵 파일의 미리보기 이미지를 추출하기 위해 검색하다가 이 글을 발견했다면, ImageData 섹션을 찾아서 추출하기 바란다. 간단하게 최종 합성된 미리보기 이미지를 획득할 수 있다.\n\n바이너리 파일 읽기\n\n브라우저에서 파일을 열었을 때 ArrayBuffer 바이너리 데이터 객체가 주어지는데, 이 객체는 Typed Array API의 DataView 클래스를 사용해 탐색할 수 있다. DataView는 다양한 형식의 값을 읽고 쓸 수 있으며 엔디안을 직접 선택할 수 있기 때문에 PSD와 같은 바이너리 파일을 읽기에 알맞다. 반면 Typed Arrays API의 Uint8Array, Uint16Array와 같은 자료 구조는 한 가지 타입을 읽고 쓰는 용도로 최적화되어 있으며 현재 플랫폼의 엔디안을 따르기 때문에 형식이 정해진 바이너리 파일을 읽고 쓰기에는 부적합하다.\n\n아래 내용부터는 데이터를 읽는 과정을 표현할 때 편의상 '배열'을 읽었다고 하겠다.\n\n각 섹션에 어떤 정보가 저장되어 있고 어떻게 읽는지 알아보자. 간단히 FileHeader 섹션을 읽어보겠다. PSD File Formats Specification 문서에 따르면 FileHeader 섹션의 구조는 다음과 같다.\n\n\n\n위 표의 일부분을 배열로 표현하면 다음과 같다. 아래 그림에서 첫 번째 줄은 각 바이트가 담고 있는 블록을 도식화한 배열이고 두 번째 줄은 각 바이트에 담긴 값의 예다. 마지막 세 번째 줄은 첫 번째 바이트에 담겨있는 데이터를 비트 단위로 표현한 예다.\n\n\n\nsignature 블록 읽기(문자열 블록)\n\nsignature 블록은 4바이트로 구성되어 있으며 문자열 타입으로 읽어야 한다. 각 바이트에 저장된 값을 ASCII 코드표에 대입하여 문자열을 완성할 수 있다. JavaScript 언어에서는 String 객체에 내장 함수를 제공하여 간단히 ASCII 코드를 그에 해당하는 문자열로 변환할 수 있다.\n\nconst signature = [56, 66, 80, 83];  \nconst value = signature  \n  .map((num) => String.fromCharCode(num))\n  .join(‘’);\n\nconsole.log(value); // \"8BPS\"  \n\n\n만약 위 4바이트 블록을 읽은 결과물이 문자열로 \"8BPS\"가 아니라면 해당 바이너리 파일은 포토샵 파일이 아니므로 적절히 예외로 처리하는 코드를 파싱 라이브러리에 추가한다.\n\nheight 블록 읽기(숫자 블록)\n\nsignature 블록은 문자열을 읽으면 되므로 각 바이트를 ASCII 테이블에 대입, 문자열 하나로 변환했다. 하지만 동일한 4바이트를 숫자로 읽으려면 다른 방식으로 읽어야 한다. 연속된 4바이트에 기록된 숫자를 읽을 땐 시프트 연산자를 사용한다. 배열의 각 칸을 방문하면서 칸의 인덱스와 숫자 값을 수식에 대입해 전체 숫자를 계산할 수 있다.\n\nconst height = [0,0,5,0];  \nconst value = height  \n  .map((num, idx, {length}) => num << (length - idx - 1) * 8)\n  .reduce((acc, cur) => acc + cur, 0);\n\nconsole.log(value); // 1280  \n\n\n시프트 연산을 하는 수식에서 8을 곱하는 이유는 1바이트가 8비트이기 때문이다.\n\n참고로, height 블록을 읽을 때는 음수를 고려하지 않았다. 높이, 너비는 음수일 수 없기 때문에 height 블록에 담겨있는 비트는 Unsigned type으로 읽었다. 하지만 X, Y 좌표와 같이 음수일 가능성이 있는 블록에 담겨있는 값은 Signed type으로 취급해야 한다. Signed type은 비트 배열에서 가장 앞에 위치한 비트를 기준으로 양수/음수를 판별할 수 있으며 0이면 양수, 1이면 음수임을 의미한다. 예를 들어, \"10100101\"이라는 값은 Signed type으로 취급하느냐, Unsigned type으로 취급하느냐에 따라 다른 값으로 읽을 수 있다.\n\n\n\nparseInt(\"10100101\"); // 151  \nparseInt(\"01011011\"); // 91  \n\n\n이진수 \"01011011\"을 십진수로 변환한 값은 91이며, 가장 앞자리 비트의 값이 1이었으므로 최종 값은 -91이 된다.\n\n\n  2의 보수에 대한 자세한 설명은 위키백과의 2의 보수를 참고한다.\n\n\n다음과 같이 메서드를 공통화하여 작성해두면 바이트 단위로 숫자를 읽을 때 호출하여 간단히 십진수 값을 구할 수 있다.\n\nconst unsignedToSigned = (x, bitLength)=> {  \n  if(x >= Math.pow(2, bitLength - 1))\n    return x - Math.pow(2, bitLength);\n\n  return xl\n};\n\n\n길이가 유동적인 블록 읽기\n\n앞서 살펴본 블럭들은 각각 차지하는 바이트 길이가 고정되어, 배열에서 해당 길이만큼 가져와 읽기 동작을 수행하면 되었다. 하지만 작가가 직접 입력하는 데이터인 '레이어 이름'과 같은 항목은 길이가 유동적일 수밖에 없다. 레이어 이름의 최대 길이는 정해져 있지만 짧은 문자열을 입력해도 최대 길이만큼 비트를 비워두는 것은 비효율적이다.\n\n문서에서 길이가 유동적인 데이터는 다음과 같은 형태로 안내하고 있다.\n\n\n\n먼저 길이가 정해진 숫자 블록이 있고 이 블록은 뒤따라오는 블록의 크기 값을 저장하고 있다. 따라서 먼저 앞 블록을 읽어서 크기 정보를 알아낸 뒤 해당 길이만큼 뒤 칸의 정보를 읽어내면 레이어 이름을 알 수 있다.\n\n위 표를 그림으로 그려보면 다음과 같다.\n\n\n\n먼저 2바이트로 길이가 고정된 블록인 length 블록을 읽어서 길잇값 10을 얻는다. 그리고 그 뒤에 길이가 유동적인 블록 data 블록을 10바이트 읽어서 문자열 \"layer name\"을 얻을 수 있다.\n\nCursor 객체 사용하기\n\n앞서 signature 블록, height 블록, 길이가 유동적인 블록을 읽는 방법을 살펴보았다. 이처럼 데이터를 읽는 과정은 문서를 참고하여 특정 블록을 떼어와 의미있는 정보로 변환하는 작업의 연속이다. 하지만 개발자가 직접 배열에 접근하여 i 번째 위치부터 j 번째 위치까지 N개의 비트를 떼어오는 과정을 하나하나 지정하기는 너무 번거로우며 번거로운 작업에서는 필연적으로 버그가 발생한다.\n\n따라서 배열에서 현재까지 읽은 위칫값을 저장하고 데이터를 읽을 때마다 위칫값을 갱신해주는 Cursor 객체를 둔다면 보다 수월하게 바이너리 데이터를 읽을 수 있다.\n\n하드디스크 장치를 열어보면 디스크에 저장된 데이터를 읽어오기 위해서 head라는 부품이 플레이트에 얹어져 자성을 읽도록 되어있는데, 이러한 구조를 소프트웨어적으로 모방했다고 보면 이해가 쉽다.\n\n\n\nclass Cursor {  \n  constructor(\n    public arr: Array<number>,\n    public position: number\n  ) { }\n\n  read(type: \"i8\" | \"u8\"): number {\n    ... position += 1;\n  }\n\n  readString(length: number): string {\n    ... position += length;\n  }\n}\n\n\nCursor 객체를 위와 같이 만들어 위치 정보를 갖게 한다. 메서드가 호출되었을 때 현재 위치부터 지정된 길이까지 데이터 블록을 읽고 위치를 갱신한 뒤 변환된 데이터를 반환한다. 개발자는 배열 속 현재 위치에 신경 쓰지 않고 문서에 나열된 순서에 따라 포토샵 파일 정보를 읽고 변환하는 코드를 작성할 수 있다.\n\nreadNumber 또는 readString 메서드를 호출하여 같은 1바이트를 읽더라도 Unsigned number type으로 읽을지, Signed number type으로 읽을지, String 타입으로 읽을지 선택할 수 있으며, 각각의 메서드 반환 값이 다르다.\n\n\n\n이미지 데이터 디코딩하기\n\n포토샵 파일을 읽는 목적은 궁극적으로 파일에 담긴 각 이미지 데이터를 얻는 것이다. 포토샵 파일에는 각 레이어 이미지 데이터와 미리보기 이미지 데이터가 존재한다. 이미지 데이터는 효율적으로 저장 공간을 차지하기 위해 기본적으로 런 렝스 부호화(run-length encoding) 압축 기술을 사용하여 저장된다.\n\n런 렝스 부호화는 데이터에서 같은 값이 연속되어 나타날 경우 그 값과 반복되는 횟수로 표현하는 방법이다. 가령, \"AAABB\" 문자열을 런 렝스 부호화로 압축할 경우 \"3A2B\" 으로 압축할 수 있다. 이미지 데이터는 RGBA 값으로 표현되는데, 각각 red(R), green(G), blue(B), alpha(A)를 나타낸다. 연속된 숫자, 즉 동일한 색상이 많을수록 반복 횟수로 표현할 수 있는 데이터가 많아지고 압축률이 높아진다.\n\n포토샵 파일은 이미지를 구성하는 각 픽셀의 R, G, B, A 값을 별도의 채널로 모아서 압축하여 보관한다. 따라서 각 채널의 내용을 해독하여 R, G, B, A 값을 하나로 모아 각 픽셀을 복원하는 과정을 거쳐야 우리가 원하는 이미지 데이터를 얻을 수 있다.\n\n\n\nR이 모두 출현한 뒤 G, B, 그리고 A가 모여있는 형태의 배열에서 RGBARGBA 값들이 반복되도록 이미지 픽셀 데이터를 복구한다.\n\n이미지 데이터를 디코딩하는 과정은 반복문을 순회하면서 RGBA 데이터를 취합하고 연결하는 작업의 연속이다. 이런 반복 작업은 WebAssembly를 사용하면 성능을 더욱 끌어올릴 수 있는데, 해당 내용은 2편에 이어서 작성하겠다.\n\n마치며\n\n지금까지 포토샵 파일을 웹 애플리케이션 환경에서 읽어내는 과정을 살펴보았다. 라이브러리를 개발하며 처음 언급했던 문제를 모두 해결할 수 있었다.\n\n의존성 라이브러리 없이 개발했기에 최종 번들링된 소스코드 파일 크기도 작고, 한글과 특수문자, 이모티콘 문자열도 모두 지원한다. 또한 대용량 포토샵 파일(.psb)도 적절히 분기 처리해 완벽히 데이터를 읽을 수 있다. 무엇보다도, 데이터를 읽는 속도와 디코딩하는 속도가 빠르다.\n\n\n\nv0.1.2 기준으로 벤치마킹을 실행해 보았더니 타 라이브러리와 비교했을 때 파일 크기는 대략 17분의 1 크기로 줄었고, 데이터 읽기 속도는 대략 7배 빨라졌다. 특히 이미지를 디코딩하는 속도가 대폭 개선된 것을 확인했다.\n\n이미지 데이터와 레이어 메타데이터를 파싱하는 기능만 오픈소스로 배포했지만, 계속해서 폰트 데이터를 비롯한 다양한 데이터를 파싱할 수 있도록 기능을 추가할 계획이다. 이 포스트를 읽는 분 중 바이너리 파일을 다루는 데에 관심이 있는 분이 있었다면 도움이 되었길 바란다.\n\n포토샵 파일을 다루는 상황에 있다면 @webtoon/psd 라이브러리 사용을 적극 추천한다. 부족한 기능이 있다면 직접 구현도 해보자. Pull Request는 언제나 환영이다!}","href":"https://d2.naver.com/d2.atom@webtoon/psd 라이브러리 개발기"}