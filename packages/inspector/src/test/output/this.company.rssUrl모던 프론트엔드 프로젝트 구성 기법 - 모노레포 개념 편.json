{"company":{"imageUrl":"/companyImages/naver.ico","name":"네이버","href":"https://d2.naver.com/d2.atom","basePath":"https://d2.naver.com","rssUrl":"https://d2.naver.com/d2.atom"},"title":"모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편","createdAt":"2022-05-04T15:13:33Z","description":"<p>새로운 프로젝트를 설계하거나 기존 프로젝트가 성장하면서 규모가 커질 때 우리는 효율적인 프로젝트 구조를 고민합니다. <a href=\"https://github.com/pinpoint-apm/pinpoint\">핀포인트 프로젝트</a>의 프론트엔드 구조를 개선하면서 검토하고 조사했던 모노레포(monorepo)의 개념과 프로젝트 구성 기법들을 두 편으로 나누어 공유하고자 합니다.</p>\n\n<p><a href=\"https://qeunit.com/blog/how-google-does-monorepo/\">Google</a>, <a href=\"https://buck.build/\">Facebook</a>, <a href=\"https://rushjs.io/\">Microsoft</a>, Uber, Airbnb, 그리고 <a href=\"https://www.pantsbuild.org/docs/welcome-to-pants\">Twitter</a> 등 글로벌 테크 회사들은 이미 각자 자신들의 운영 전략 아래 대규모 모노레포를 운영하고 있습니다.</p>\n\n<p>이번 개념 편에서는 다음과 같은 내용을 알아보겠습니다.</p>\n\n<ol>\n<li><a href=\"#ch1\">모노레포의 등장 배경</a>  </li>\n<li><a href=\"#ch2\">모노레포가 해결하는 문제</a>  </li>\n<li><a href=\"#ch3\">모노레포를 구축할 때 고려할 측면</a>  </li>\n<li><a href=\"#ch4\">모노레포 구축을 도와주는 도구</a></li>\n</ol>\n\n<p>그리고 다음 도구 편에서는 각 도구의 사용법을 예시를 통해 자세히 알아보겠습니다.</p>\n\n<p><a id=\"ch1\"></a></p>\n\n<h2 id=\"1\">1. 모노레포의 등장 배경</h2>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Monorepo\">위키백과</a>에 따르면 모노레포의 정의는 다음과 같다.</p>\n\n<blockquote>\n  <p>모노레포란 버전 관리 시스템에서 두 개 이상의 프로젝트 코드가 동일한 저장소에 저장되는 소프트웨어 개발 전략</p>\n</blockquote>\n\n<p>이 개발 전략은 고전적 소프트웨어 개발 방식인 <a href=\"https://en.wikipedia.org/wiki/Monolithic_application\">모놀리식 애플리케이션(monolithic application)</a>의 한계에 대한 비판에서 출발한다.</p>\n\n<h3 id=\"\">모놀리식 애플리케이션의 한계</h3>\n\n<blockquote>\n  <p>\"<em>소프트웨어 엔지니어링에서 모놀리식 애플리케이션은 모듈화 없이 설계된 소프트웨어 애플리케이션을 말한다.</em>\"</p>\n</blockquote>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e0ae025d1b.png\" alt=\"\" /></p>\n\n<p>우리가 네이버와 같은 거대 서비스를 개발할 때, 소스 코드가 모듈화 없이 하나의 프로젝트로 구성된다면 어떻게 될까? 코드가 서로 직접적으로 의존하며 단 하나의 버전으로 관리되면서 <a href=\"https://ko.wikipedia.org/wiki/%EA%B4%80%EC%8B%AC%EC%82%AC_%EB%B6%84%EB%A6%AC\">관심 분리(separation of concerns)</a>가 어려워지고, 설계, 리팩터링, 배포 등의 작업을 매번 거대한 단위로 처리해야 하므로 개발상 많은 제약과 비효율이 있을 것이다.</p>\n\n<h3 id=\"\">모듈화와 재사용성</h3>\n\n<p>이러한 모놀리식 구조의 한계는 <a href=\"https://en.wikipedia.org/wiki/Modularity\">모듈화(modularity)</a>를 통해 해결할 수 있다. 일반적으로 <a href=\"https://en.wikipedia.org/wiki/Modular_programming\">모듈식 프로그래밍(modular programming)</a>은 애플리케이션 로직의 일부를 재사용할 수 있도록 지원하고 전체 교체 없이 애플리케이션의 일부를 수정 또는 교체할 수 있게 해 유지 관리를 용이하게 한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e0fa095e41.png\" alt=\"\" /></p>\n\n<p>그런데 이렇게 만든 모듈이 다른 애플리케이션에도 사용될 수 있다면 소스를 어디에 위치시켜야 할까? 아마도 해당 모듈을 위한 독자적인 저장소가 있다면 좀 더 관리하기 쉬울 것이다. 이 구조가 바로 멀티레포(multirepo)다.</p>\n\n<h3 id=\"\">멀티레포</h3>\n\n<p>멀티레포 구조는 폴리레포(polyrepo) 구조라고도 부른다. 앞선 예시의 분리된 각 모듈은 멀티레포 구조에서 고유한 저장소가 있는 독자적 프로젝트가 된다. 각 프로젝트는 자율성이 높으며 독립적인 개발, 린트, 테스트, 빌드, 게시, 배포 파이프라인이 존재한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e13d875e4e.png\" alt=\"\" /></p>\n\n<p>멀티레포는 현재 대부분의 애플리케이션을 개발하는 표준적인 방법이다. 업계는 <strong>팀의 자율성</strong>이라는 큰 이유 때문에 이 방식을 선호한다. 팀은 애플리케이션 개발의 라이프사이클을 스스로 결정하기를 원한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e17ec25e73.png\" alt=\"\" /></p>\n\n<p>좋은 일인데 무엇이 문제일까? 양날의 검처럼 이 <strong><a href=\"https://monorepo.tools/#polyrepo-concept\">자율성은 고립(isolation)에 의해 제공되고 고립은 협업을 방해한다</a></strong>. 멀티레포를 통해 모놀리식 구조의 문제를 해결했지만 다음과 같은 새로운 문제가 생긴다.</p>\n\n<h3 id=\"\">멀티레포의 문제</h3>\n\n<ul>\n<li><p>번거로운 프로젝트 생성</p>\n\n<p>새로운 공유 패키지를 생성할 때마다 다음과 같이 번거로운 과정을 거쳐야 한다.</p>\n\n<p>저장소 생성 > 커미터 추가 > 개발 환경 구축 > CI/CD 구축 > 빌드 > 패키지 저장소에 publish</p></li>\n</ul>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e1c3aa6129-1.png\" alt=\"\" /></p>\n\n<ul>\n<li><p>패키지의 중복 코드 가능성</p>\n\n<p>위의 번거로움을 피하기 위해 각 프로젝트에서 공통 구성 요소를 자체적으로 작성한다면, 초기 시간을 아낄 수 있지만 시간이 지날수록 보안 및 품질 관리 부담을 증가시킨다.</p></li>\n<li><p>관리 포인트 증가</p>\n\n<p>늘어난 프로젝트 저장소의 수만큼 관리 포인트가 늘어난다. 린트, 테스트, 개발 모드 실행, 빌드, 게시, 배포 등의 과정을 저장소의 수만큼 반복해야 한다.</p></li>\n<li><p>일관성 없는 개발자 경험(DX)</p>\n\n<p>각 프로젝트는 테스트 실행, 빌드, 테스트, 린트, 배포 등을 위해 고유한 명령 집합을 사용한다.\n이러한 불일치는 여러 프로젝트에서 사용할 명령을 기억해야 하는 정신적 오버헤드를 만든다.</p></li>\n<li><p>다른 패키지의 변경 사항 파악</p>\n\n<p>관련 패키지의 변화를 지켜보거나 통지받지 않으면 문제가 발생할 수 있다.</p></li>\n<li><p>교차 저장소의 리팩터링 비용</p>\n\n<p>관련 패키지의 변화가 있을 때 여러 저장소에 걸쳐 변화를 반영하는 것은 쉬운 일이 아닐 것이다. 또한 이렇게 리팩터링된 각 패키지의 버전은 어떻게 관리해야 할까.</p></li>\n</ul>\n\n<p>그렇다면 모듈을 적절히 분리하여 관심 분리를 이루면서, 동시에 분리된 모듈을 쉽게 참조하고 테스트, 빌드, 배포 과정도 쉽게 한 번에 할 수는 없을까? 이제 모노레포가 출동할 시간이다.</p>\n\n<p><a id=\"ch2\"></a></p>\n\n<h2 id=\"2\">2. 모노레포가 해결하는 문제</h2>\n\n<h3 id=\"\">모노레포의 특징</h3>\n\n<p>모노레포(monorepo) 구조는 두 개 이상의 프로젝트가 동일한 저장소에 저장되는 소프트웨어 개발 전략이다. 앞선 예시의 분리된 모듈들은 모노레포에서 여전히 독자 프로젝트로 존재하지만 저장소는 같은 곳을 사용한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e20998613f.png\" alt=\"\" /></p>\n\n<p>모노레포의 또 다른 중요한 특징 중 하나는 <strong>프로젝트 간의 관계</strong>다. 단순히 여러 프로젝트가 하나의 저장소를 사용한다고 해서 모노레포 구조라고 부르기에는 부족하다. 흔히 모노레포에서는 프로젝트 사이에 의존성이 존재하거나 같은 제품군이거나 하는 정의된 관계가 존재한다. 아래에서 소개할 모노레포 관리 도구는 모두 이러한 <strong>관계를 효율적으로 관리해 주는 도구</strong>라고 할 수 있다.</p>\n\n<h3 id=\"\">모노레포가 해결하는 멀티레포의 문제</h3>\n\n<ul>\n<li><p>더 쉬운 프로젝트 생성</p>\n\n<p>멀티레포에서 공유 패키지를 만들 때 다음과 같은 과정을 거친다.</p>\n\n<p>저장소 생성 > 커미터 추가 > 개발환경 구축 > CI/CD 구축 > 빌드 > 패키지 저장소에 publish</p>\n\n<p>모노레포에서는 저장소 생성 및 커미터 추가 과정이 필요 없고, 개발 환경, CI/CD, 빌드, 게시 등의 과정에 기존 DevOps를 이용하므로 새 프로젝트 생성에 대한 오버헤드가 없다.</p></li>\n<li><p>더 쉬운 의존성 관리</p>\n\n<p>의존성 패키지가 같은 저장소에 있으므로 버전이 지정된 패키지를 npm registry와 같은 곳에 publish할 필요가 없다.</p></li>\n<li><p>단일화된 관리 포인트</p>\n\n<p>개발환경 및 DevOps에 대한 업데이트를 한 번에 반영할 수 있다.</p></li>\n<li><p>일관된 개발자 경험 제공</p>\n\n<p>애플리케이션을 일관되게 구축하고 테스트할 수 있다. 개발자는 다른 팀의 애플리케이션에 자신 있게 기여하고 변경 사항이 안전한지 확인할 수 있다.</p></li>\n<li><p>프로젝트들에 걸친 원자적 커밋</p>\n\n<p>커밋할 때마다 모든 것이 함께 작동한다. 변경 사항의 영향을 받는 조직에서 쉽게 변화를 확인할 수 있다.</p></li>\n<li><p>서로 의존하는 저장소들의 리팩터링 비용 감소</p>\n\n<p>모노레포는 대규모 변경을 훨씬 더 간단하게 만든다. 100개의 라이브러리로 만든 10개의 앱을 리팩터링하고 변경을 커밋하기 전에 모두 작동하는지 확인할 수 있다.</p></li>\n</ul>\n\n<h3 id=\"\">그 밖의 모노레포의 특징</h3>\n\n<ul>\n<li><p>테스트 및 빌드 범위 최소화</p>\n\n<p>소스 변경 시 모든 프로젝트를 다시 빌드하거나 다시 테스트하지 않는다. 대신 변경 사항의 영향을 받는 프로젝트만 다시 테스트하고 빌드한다.</p></li>\n</ul>\n\n<h3 id=\"\">모노레포에 대한 오해</h3>\n\n<ul>\n<li><p>다른 팀이 내가 모르는 사이에 내 코드를 변경한다면?</p>\n\n<p>GitHub에는 <a href=\"https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners\">CODEOWNERS</a>와 같은 기능을 사용하여 폴더 기반으로 소유권을 구성할 수 있다.</p></li>\n</ul>\n\n<pre><code>@global-owner1 @global-owner2 ## 이 저장소에 대한 모든 PR을 소유자에게 리뷰받아야 머지할 수 있다.\npackages/todo-api/* @john @jane ## todo-api 경로는 john과 jane에게 리뷰받아야 한다.  \npackages/i18n/* @michael ## i18n은 michael에게 리뷰받아야 한다.  \n</code></pre>\n\n<ul>\n<li><p>모노레포가 멀티레포보다 항상 나은 방법인가?</p>\n\n<p>그렇지 않다. 멀티레포의 단점이 모노레포의 장점이고 장단점이 교차하기 때문에 적절한 상황에서 사용해야 한다.</p>\n\n<p>모노레포의 핵심적 특징은 프로젝트 사이의 관계이고, 모노레포가 적절한 상황은 다음과 같다.</p>\n\n<ul><li>유사한 제품의 집합</li>\n<li>여러 프로젝트의 변화를 한눈에 파악해야 할 때</li>\n<li>호스트 애플리케이션을 플러그인 등으로 확장할 때</li>\n<li>공통 기능을 재사용하는 관련된 프로젝트의 집합</li>\n<li>유사한 DevOps로 구성된 프로젝트의 집합</li></ul></li>\n</ul>\n\n<p><a id=\"ch3\"></a></p>\n\n<h2 id=\"3\">3. 모노레포를 구축할 때 고려할 측면</h2>\n\n<p>모노레포를 구축하려고 할 때 <strong>관리 용이성</strong>, <strong>속도</strong> 그리고 <strong>프로젝트 구조 관리</strong> 측면에서 다음과 같은 사항을 고려해야 한다.</p>\n\n<blockquote>\n  <p>분류 기준은 <a href=\"https://monorepo.tools/#monorepo-features\">Monorepo features</a>를 참고했다.</p>\n</blockquote>\n\n<h3 id=\"\">관리 측면</h3>\n\n<ul>\n<li><p>코드 공유: 서로 다른 프로젝트 간에 쉽게 소스 코드를 공유</p></li>\n<li><p>일관성 있는 도구: 서로 다른 프로젝트들(심지어 서로 다른 프레임워크를 사용하더라도)에서 일관된 개발 경험을 제공</p></li>\n<li><p>스케폴딩: 새로운 프로젝트를 생성할 때 초기 코드를 쉽게 생성</p></li>\n<li><p>프로젝트 제약 및 가시성(visibility): 저장소 내에서 의존 관계를 제한하는 규칙 정의 지원. 예를 들어, 일부 프로젝트를 팀 전용으로 표시하거나 특정 프레임워크을 사용 중임을 기술.</p></li>\n</ul>\n\n<h3 id=\"\">속도 측면</h3>\n\n<ul>\n<li><p>로컬 캐싱: 같은 머신에서 같은 것을 두 번 빌드하거나 테스트하지 않음</p></li>\n<li><p>분산 캐싱: 다양한 환경에서 캐시 아티팩트를 공유. 즉, 조직 단위로 여러 CI 환경에 걸쳐 같은 것을 두 번 빌드, 테스트하지 않음</p></li>\n<li><p>로컬 작업 오케스트레이션: 빌드 및 테스트 등의 작업을 순서에 맞게 병렬로 실행</p></li>\n<li><p>분산 작업 실행: 단일 시스템에서 실행되어 여러 시스템에 명령을 전달</p></li>\n<li><p>변화에 영향을 받는 프로젝트 감지: 변경의 영향을 받을 수 있는 항목을 결정하여 영향을 받는 프로젝트만 빌드/테스트</p></li>\n</ul>\n\n<h3 id=\"\">구조 파악 측면</h3>\n\n<ul>\n<li><p>워크스페이스 분석: 추가 구성 없이 주어진 워크 스페이스의 의존성 관계를 분석</p></li>\n<li><p>의존성 그래프 시각화: 프로젝트 및 작업 간의 종속 관계를 시각화</p></li>\n</ul>\n\n<p><a id=\"ch4\"></a></p>\n\n<h2 id=\"4\">4. 모노레포 구축을 도와주는 도구</h2>\n\n<p>그럼 어떤 도구를 통해 위에 고려한 측면을 구축하고 지원받을 수 있을까? <a href=\"https://2021.stateofjs.com/en-US/libraries/monorepo-tools\">2021.stateofjs.com</a> 기준으로 인기있는 도구를 살펴보면 다음과 같다.</p>\n\n<h3 id=\"\">얼마나 사용되는가</h3>\n\n<p>Lerna, Yarn, npm, pnpm, Nx 등이 많이 사용되었다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e2763b61e3.png\" alt=\"\" /></p>\n\n<h3 id=\"\">얼마나 만족하는가</h3>\n\n<p>pnpm, Turborepo, Nx, npm, Yarn 등을 훌륭하게 평가하였다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e2aa2861ea.png\" alt=\"\" /></p>\n\n<h3 id=\"\">누가 사용하는가</h3>\n\n<ul>\n<li>Yarn\n<ul><li><a href=\"https://github.com/facebook/react/blob/b9de50d2f9ad6ff8caae0729976c3cc9a69c176e/package.json#L3-L5\">React</a></li>\n<li><a href=\"https://github.com/remix-run/react-router/blob/7dca9dc38c837ed94796325b1e0582aa72a9313f/package.json#L63-L73\">React-router</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/24f0944e2d5b83dac4cba80e1b33c8098c613dc7/package.json#L20\">Babel</a> (Yarn Berry)</li></ul></li>\n<li>Lerna + Yarn\n<ul><li><a href=\"https://github.com/vercel/next.js/blob/21994ce591be70b03176a2512c7304381d52e629/lerna.json#L1-L20\">Next.js</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/v7.12.12/lerna.json\">Babel</a> (v7.12.12)</li>\n<li><a href=\"https://github.com/facebook/jest/blob/54420eb51baecaba7dff293770f8cb2579825731/lerna.json#L1-L7\">Jest</a></li>\n<li><a href=\"https://github.com/facebook/create-react-app/blob/fd8c5f7b1b1d19d10d24cc2f9fdfc110585dc030/lerna.json#L1-L19\">Create React App</a></li>\n<li><a href=\"https://github.com/storybookjs/storybook/blob/275406ad764d9d02ff41ad7eb8983b52cf22faa0/lerna.json\">Storybook</a></li>\n<li><a href=\"https://github.com/vuejs/vue-cli/blob/f7dc46d0692c2d8a07f5c8b0580177de81c150b0/lerna.json#L2\">Vue-cli</a></li>\n<li><a href=\"https://github.com/nuxt/framework/blob/a55c7874e6c22a8a927027cbf5f4149a8711525a/lerna.json#L3\">Nuxt.js</a></li>\n<li><a href=\"https://github.com/webpack/webpack-cli/blob/2f5e331f8786fbb21e349df3a7518886ac6deaa1/lerna.json#L5\">Webpack-cli</a></li>\n<li><a href=\"https://lerna.js.org/#users\">모든 레퍼런스</a></li></ul></li>\n<li>Lerna + Npm\n<ul><li><a href=\"https://github.com/apollographql/apollo-server/blob/90069be053f28deb9fc6b605f2008fc54909c255/lerna.json#L2\">Apollo-server</a></li></ul></li>\n<li>Nx\n<ul><li><a href=\"https://github.com/storybookjs/storybook/blob/275406ad764d9d02ff41ad7eb8983b52cf22faa0/nx.json#L1\">Storybook</a></li>\n<li><a href=\"https://github.com/microsoft/fluentui/blob/605d53a436a9dfb24075fdb39bb4c4823ee0b9ba/nx.json#L1\">FluentUI</a></li>\n<li><a href=\"https://github.com/ngrx/platform/blob/1d3e33735f5e438eab27e36681e04c0649ce48ac/nx.json#L1\">NgRx</a></li></ul></li>\n<li>Turborepo\n<ul><li><a href=\"https://vercel.com/\">Vercel</a></li>\n<li><a href=\"https://lattice.com/\">Lattice</a></li>\n<li><a href=\"https://spri.ng/\">TeeSpring</a></li>\n<li><a href=\"https://makeswift.com/\">MakeSwift</a></li>\n<li><a href=\"https://beondeck.com/\">On Deck</a></li>\n<li><a href=\"https://astro.build/\">Astro</a></li>\n<li><a href=\"https://github.com/vercel/turborepo/discussions/103\">모든 레퍼런스</a></li></ul></li>\n<li>Pnpm\n<ul><li><a href=\"https://github.com/vuejs/core/blob/1070f127a78bfe7da6fe550cc272ef11a1f434a0/pnpm-workspace.yaml#L1\">Vue 3</a></li>\n<li><a href=\"https://pnpm.io/users\">모든 레퍼런스</a></li></ul></li>\n</ul>\n\n<h2 id=\"\">마치며</h2>\n\n<p>다음 편에서는 위의 도구 중 Yarn, Lerna, Nx 그리고 Turborepo에 대해 자세히 알아보겠다.</p>","rawText":"<p>새로운 프로젝트를 설계하거나 기존 프로젝트가 성장하면서 규모가 커질 때 우리는 효율적인 프로젝트 구조를 고민합니다. <a href=\"https://github.com/pinpoint-apm/pinpoint\">핀포인트 프로젝트</a>의 프론트엔드 구조를 개선하면서 검토하고 조사했던 모노레포(monorepo)의 개념과 프로젝트 구성 기법들을 두 편으로 나누어 공유하고자 합니다.</p>\n\n<p><a href=\"https://qeunit.com/blog/how-google-does-monorepo/\">Google</a>, <a href=\"https://buck.build/\">Facebook</a>, <a href=\"https://rushjs.io/\">Microsoft</a>, Uber, Airbnb, 그리고 <a href=\"https://www.pantsbuild.org/docs/welcome-to-pants\">Twitter</a> 등 글로벌 테크 회사들은 이미 각자 자신들의 운영 전략 아래 대규모 모노레포를 운영하고 있습니다.</p>\n\n<p>이번 개념 편에서는 다음과 같은 내용을 알아보겠습니다.</p>\n\n<ol>\n<li><a href=\"#ch1\">모노레포의 등장 배경</a>  </li>\n<li><a href=\"#ch2\">모노레포가 해결하는 문제</a>  </li>\n<li><a href=\"#ch3\">모노레포를 구축할 때 고려할 측면</a>  </li>\n<li><a href=\"#ch4\">모노레포 구축을 도와주는 도구</a></li>\n</ol>\n\n<p>그리고 다음 도구 편에서는 각 도구의 사용법을 예시를 통해 자세히 알아보겠습니다.</p>\n\n<p><a id=\"ch1\"></a></p>\n\n<h2 id=\"1\">1. 모노레포의 등장 배경</h2>\n\n<p><a href=\"https://en.wikipedia.org/wiki/Monorepo\">위키백과</a>에 따르면 모노레포의 정의는 다음과 같다.</p>\n\n<blockquote>\n  <p>모노레포란 버전 관리 시스템에서 두 개 이상의 프로젝트 코드가 동일한 저장소에 저장되는 소프트웨어 개발 전략</p>\n</blockquote>\n\n<p>이 개발 전략은 고전적 소프트웨어 개발 방식인 <a href=\"https://en.wikipedia.org/wiki/Monolithic_application\">모놀리식 애플리케이션(monolithic application)</a>의 한계에 대한 비판에서 출발한다.</p>\n\n<h3 id=\"\">모놀리식 애플리케이션의 한계</h3>\n\n<blockquote>\n  <p>\"<em>소프트웨어 엔지니어링에서 모놀리식 애플리케이션은 모듈화 없이 설계된 소프트웨어 애플리케이션을 말한다.</em>\"</p>\n</blockquote>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e0ae025d1b.png\" alt=\"\" /></p>\n\n<p>우리가 네이버와 같은 거대 서비스를 개발할 때, 소스 코드가 모듈화 없이 하나의 프로젝트로 구성된다면 어떻게 될까? 코드가 서로 직접적으로 의존하며 단 하나의 버전으로 관리되면서 <a href=\"https://ko.wikipedia.org/wiki/%EA%B4%80%EC%8B%AC%EC%82%AC_%EB%B6%84%EB%A6%AC\">관심 분리(separation of concerns)</a>가 어려워지고, 설계, 리팩터링, 배포 등의 작업을 매번 거대한 단위로 처리해야 하므로 개발상 많은 제약과 비효율이 있을 것이다.</p>\n\n<h3 id=\"\">모듈화와 재사용성</h3>\n\n<p>이러한 모놀리식 구조의 한계는 <a href=\"https://en.wikipedia.org/wiki/Modularity\">모듈화(modularity)</a>를 통해 해결할 수 있다. 일반적으로 <a href=\"https://en.wikipedia.org/wiki/Modular_programming\">모듈식 프로그래밍(modular programming)</a>은 애플리케이션 로직의 일부를 재사용할 수 있도록 지원하고 전체 교체 없이 애플리케이션의 일부를 수정 또는 교체할 수 있게 해 유지 관리를 용이하게 한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e0fa095e41.png\" alt=\"\" /></p>\n\n<p>그런데 이렇게 만든 모듈이 다른 애플리케이션에도 사용될 수 있다면 소스를 어디에 위치시켜야 할까? 아마도 해당 모듈을 위한 독자적인 저장소가 있다면 좀 더 관리하기 쉬울 것이다. 이 구조가 바로 멀티레포(multirepo)다.</p>\n\n<h3 id=\"\">멀티레포</h3>\n\n<p>멀티레포 구조는 폴리레포(polyrepo) 구조라고도 부른다. 앞선 예시의 분리된 각 모듈은 멀티레포 구조에서 고유한 저장소가 있는 독자적 프로젝트가 된다. 각 프로젝트는 자율성이 높으며 독립적인 개발, 린트, 테스트, 빌드, 게시, 배포 파이프라인이 존재한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e13d875e4e.png\" alt=\"\" /></p>\n\n<p>멀티레포는 현재 대부분의 애플리케이션을 개발하는 표준적인 방법이다. 업계는 <strong>팀의 자율성</strong>이라는 큰 이유 때문에 이 방식을 선호한다. 팀은 애플리케이션 개발의 라이프사이클을 스스로 결정하기를 원한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e17ec25e73.png\" alt=\"\" /></p>\n\n<p>좋은 일인데 무엇이 문제일까? 양날의 검처럼 이 <strong><a href=\"https://monorepo.tools/#polyrepo-concept\">자율성은 고립(isolation)에 의해 제공되고 고립은 협업을 방해한다</a></strong>. 멀티레포를 통해 모놀리식 구조의 문제를 해결했지만 다음과 같은 새로운 문제가 생긴다.</p>\n\n<h3 id=\"\">멀티레포의 문제</h3>\n\n<ul>\n<li><p>번거로운 프로젝트 생성</p>\n\n<p>새로운 공유 패키지를 생성할 때마다 다음과 같이 번거로운 과정을 거쳐야 한다.</p>\n\n<p>저장소 생성 > 커미터 추가 > 개발 환경 구축 > CI/CD 구축 > 빌드 > 패키지 저장소에 publish</p></li>\n</ul>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e1c3aa6129-1.png\" alt=\"\" /></p>\n\n<ul>\n<li><p>패키지의 중복 코드 가능성</p>\n\n<p>위의 번거로움을 피하기 위해 각 프로젝트에서 공통 구성 요소를 자체적으로 작성한다면, 초기 시간을 아낄 수 있지만 시간이 지날수록 보안 및 품질 관리 부담을 증가시킨다.</p></li>\n<li><p>관리 포인트 증가</p>\n\n<p>늘어난 프로젝트 저장소의 수만큼 관리 포인트가 늘어난다. 린트, 테스트, 개발 모드 실행, 빌드, 게시, 배포 등의 과정을 저장소의 수만큼 반복해야 한다.</p></li>\n<li><p>일관성 없는 개발자 경험(DX)</p>\n\n<p>각 프로젝트는 테스트 실행, 빌드, 테스트, 린트, 배포 등을 위해 고유한 명령 집합을 사용한다.\n이러한 불일치는 여러 프로젝트에서 사용할 명령을 기억해야 하는 정신적 오버헤드를 만든다.</p></li>\n<li><p>다른 패키지의 변경 사항 파악</p>\n\n<p>관련 패키지의 변화를 지켜보거나 통지받지 않으면 문제가 발생할 수 있다.</p></li>\n<li><p>교차 저장소의 리팩터링 비용</p>\n\n<p>관련 패키지의 변화가 있을 때 여러 저장소에 걸쳐 변화를 반영하는 것은 쉬운 일이 아닐 것이다. 또한 이렇게 리팩터링된 각 패키지의 버전은 어떻게 관리해야 할까.</p></li>\n</ul>\n\n<p>그렇다면 모듈을 적절히 분리하여 관심 분리를 이루면서, 동시에 분리된 모듈을 쉽게 참조하고 테스트, 빌드, 배포 과정도 쉽게 한 번에 할 수는 없을까? 이제 모노레포가 출동할 시간이다.</p>\n\n<p><a id=\"ch2\"></a></p>\n\n<h2 id=\"2\">2. 모노레포가 해결하는 문제</h2>\n\n<h3 id=\"\">모노레포의 특징</h3>\n\n<p>모노레포(monorepo) 구조는 두 개 이상의 프로젝트가 동일한 저장소에 저장되는 소프트웨어 개발 전략이다. 앞선 예시의 분리된 모듈들은 모노레포에서 여전히 독자 프로젝트로 존재하지만 저장소는 같은 곳을 사용한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e20998613f.png\" alt=\"\" /></p>\n\n<p>모노레포의 또 다른 중요한 특징 중 하나는 <strong>프로젝트 간의 관계</strong>다. 단순히 여러 프로젝트가 하나의 저장소를 사용한다고 해서 모노레포 구조라고 부르기에는 부족하다. 흔히 모노레포에서는 프로젝트 사이에 의존성이 존재하거나 같은 제품군이거나 하는 정의된 관계가 존재한다. 아래에서 소개할 모노레포 관리 도구는 모두 이러한 <strong>관계를 효율적으로 관리해 주는 도구</strong>라고 할 수 있다.</p>\n\n<h3 id=\"\">모노레포가 해결하는 멀티레포의 문제</h3>\n\n<ul>\n<li><p>더 쉬운 프로젝트 생성</p>\n\n<p>멀티레포에서 공유 패키지를 만들 때 다음과 같은 과정을 거친다.</p>\n\n<p>저장소 생성 > 커미터 추가 > 개발환경 구축 > CI/CD 구축 > 빌드 > 패키지 저장소에 publish</p>\n\n<p>모노레포에서는 저장소 생성 및 커미터 추가 과정이 필요 없고, 개발 환경, CI/CD, 빌드, 게시 등의 과정에 기존 DevOps를 이용하므로 새 프로젝트 생성에 대한 오버헤드가 없다.</p></li>\n<li><p>더 쉬운 의존성 관리</p>\n\n<p>의존성 패키지가 같은 저장소에 있으므로 버전이 지정된 패키지를 npm registry와 같은 곳에 publish할 필요가 없다.</p></li>\n<li><p>단일화된 관리 포인트</p>\n\n<p>개발환경 및 DevOps에 대한 업데이트를 한 번에 반영할 수 있다.</p></li>\n<li><p>일관된 개발자 경험 제공</p>\n\n<p>애플리케이션을 일관되게 구축하고 테스트할 수 있다. 개발자는 다른 팀의 애플리케이션에 자신 있게 기여하고 변경 사항이 안전한지 확인할 수 있다.</p></li>\n<li><p>프로젝트들에 걸친 원자적 커밋</p>\n\n<p>커밋할 때마다 모든 것이 함께 작동한다. 변경 사항의 영향을 받는 조직에서 쉽게 변화를 확인할 수 있다.</p></li>\n<li><p>서로 의존하는 저장소들의 리팩터링 비용 감소</p>\n\n<p>모노레포는 대규모 변경을 훨씬 더 간단하게 만든다. 100개의 라이브러리로 만든 10개의 앱을 리팩터링하고 변경을 커밋하기 전에 모두 작동하는지 확인할 수 있다.</p></li>\n</ul>\n\n<h3 id=\"\">그 밖의 모노레포의 특징</h3>\n\n<ul>\n<li><p>테스트 및 빌드 범위 최소화</p>\n\n<p>소스 변경 시 모든 프로젝트를 다시 빌드하거나 다시 테스트하지 않는다. 대신 변경 사항의 영향을 받는 프로젝트만 다시 테스트하고 빌드한다.</p></li>\n</ul>\n\n<h3 id=\"\">모노레포에 대한 오해</h3>\n\n<ul>\n<li><p>다른 팀이 내가 모르는 사이에 내 코드를 변경한다면?</p>\n\n<p>GitHub에는 <a href=\"https://docs.github.com/en/repositories/managing-your-repositorys-settings-and-features/customizing-your-repository/about-code-owners\">CODEOWNERS</a>와 같은 기능을 사용하여 폴더 기반으로 소유권을 구성할 수 있다.</p></li>\n</ul>\n\n<pre><code>@global-owner1 @global-owner2 ## 이 저장소에 대한 모든 PR을 소유자에게 리뷰받아야 머지할 수 있다.\npackages/todo-api/* @john @jane ## todo-api 경로는 john과 jane에게 리뷰받아야 한다.  \npackages/i18n/* @michael ## i18n은 michael에게 리뷰받아야 한다.  \n</code></pre>\n\n<ul>\n<li><p>모노레포가 멀티레포보다 항상 나은 방법인가?</p>\n\n<p>그렇지 않다. 멀티레포의 단점이 모노레포의 장점이고 장단점이 교차하기 때문에 적절한 상황에서 사용해야 한다.</p>\n\n<p>모노레포의 핵심적 특징은 프로젝트 사이의 관계이고, 모노레포가 적절한 상황은 다음과 같다.</p>\n\n<ul><li>유사한 제품의 집합</li>\n<li>여러 프로젝트의 변화를 한눈에 파악해야 할 때</li>\n<li>호스트 애플리케이션을 플러그인 등으로 확장할 때</li>\n<li>공통 기능을 재사용하는 관련된 프로젝트의 집합</li>\n<li>유사한 DevOps로 구성된 프로젝트의 집합</li></ul></li>\n</ul>\n\n<p><a id=\"ch3\"></a></p>\n\n<h2 id=\"3\">3. 모노레포를 구축할 때 고려할 측면</h2>\n\n<p>모노레포를 구축하려고 할 때 <strong>관리 용이성</strong>, <strong>속도</strong> 그리고 <strong>프로젝트 구조 관리</strong> 측면에서 다음과 같은 사항을 고려해야 한다.</p>\n\n<blockquote>\n  <p>분류 기준은 <a href=\"https://monorepo.tools/#monorepo-features\">Monorepo features</a>를 참고했다.</p>\n</blockquote>\n\n<h3 id=\"\">관리 측면</h3>\n\n<ul>\n<li><p>코드 공유: 서로 다른 프로젝트 간에 쉽게 소스 코드를 공유</p></li>\n<li><p>일관성 있는 도구: 서로 다른 프로젝트들(심지어 서로 다른 프레임워크를 사용하더라도)에서 일관된 개발 경험을 제공</p></li>\n<li><p>스케폴딩: 새로운 프로젝트를 생성할 때 초기 코드를 쉽게 생성</p></li>\n<li><p>프로젝트 제약 및 가시성(visibility): 저장소 내에서 의존 관계를 제한하는 규칙 정의 지원. 예를 들어, 일부 프로젝트를 팀 전용으로 표시하거나 특정 프레임워크을 사용 중임을 기술.</p></li>\n</ul>\n\n<h3 id=\"\">속도 측면</h3>\n\n<ul>\n<li><p>로컬 캐싱: 같은 머신에서 같은 것을 두 번 빌드하거나 테스트하지 않음</p></li>\n<li><p>분산 캐싱: 다양한 환경에서 캐시 아티팩트를 공유. 즉, 조직 단위로 여러 CI 환경에 걸쳐 같은 것을 두 번 빌드, 테스트하지 않음</p></li>\n<li><p>로컬 작업 오케스트레이션: 빌드 및 테스트 등의 작업을 순서에 맞게 병렬로 실행</p></li>\n<li><p>분산 작업 실행: 단일 시스템에서 실행되어 여러 시스템에 명령을 전달</p></li>\n<li><p>변화에 영향을 받는 프로젝트 감지: 변경의 영향을 받을 수 있는 항목을 결정하여 영향을 받는 프로젝트만 빌드/테스트</p></li>\n</ul>\n\n<h3 id=\"\">구조 파악 측면</h3>\n\n<ul>\n<li><p>워크스페이스 분석: 추가 구성 없이 주어진 워크 스페이스의 의존성 관계를 분석</p></li>\n<li><p>의존성 그래프 시각화: 프로젝트 및 작업 간의 종속 관계를 시각화</p></li>\n</ul>\n\n<p><a id=\"ch4\"></a></p>\n\n<h2 id=\"4\">4. 모노레포 구축을 도와주는 도구</h2>\n\n<p>그럼 어떤 도구를 통해 위에 고려한 측면을 구축하고 지원받을 수 있을까? <a href=\"https://2021.stateofjs.com/en-US/libraries/monorepo-tools\">2021.stateofjs.com</a> 기준으로 인기있는 도구를 살펴보면 다음과 같다.</p>\n\n<h3 id=\"\">얼마나 사용되는가</h3>\n\n<p>Lerna, Yarn, npm, pnpm, Nx 등이 많이 사용되었다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e2763b61e3.png\" alt=\"\" /></p>\n\n<h3 id=\"\">얼마나 만족하는가</h3>\n\n<p>pnpm, Turborepo, Nx, npm, Yarn 등을 훌륭하게 평가하였다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710ba9-7e47-1064-817f-86e2aa2861ea.png\" alt=\"\" /></p>\n\n<h3 id=\"\">누가 사용하는가</h3>\n\n<ul>\n<li>Yarn\n<ul><li><a href=\"https://github.com/facebook/react/blob/b9de50d2f9ad6ff8caae0729976c3cc9a69c176e/package.json#L3-L5\">React</a></li>\n<li><a href=\"https://github.com/remix-run/react-router/blob/7dca9dc38c837ed94796325b1e0582aa72a9313f/package.json#L63-L73\">React-router</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/24f0944e2d5b83dac4cba80e1b33c8098c613dc7/package.json#L20\">Babel</a> (Yarn Berry)</li></ul></li>\n<li>Lerna + Yarn\n<ul><li><a href=\"https://github.com/vercel/next.js/blob/21994ce591be70b03176a2512c7304381d52e629/lerna.json#L1-L20\">Next.js</a></li>\n<li><a href=\"https://github.com/babel/babel/blob/v7.12.12/lerna.json\">Babel</a> (v7.12.12)</li>\n<li><a href=\"https://github.com/facebook/jest/blob/54420eb51baecaba7dff293770f8cb2579825731/lerna.json#L1-L7\">Jest</a></li>\n<li><a href=\"https://github.com/facebook/create-react-app/blob/fd8c5f7b1b1d19d10d24cc2f9fdfc110585dc030/lerna.json#L1-L19\">Create React App</a></li>\n<li><a href=\"https://github.com/storybookjs/storybook/blob/275406ad764d9d02ff41ad7eb8983b52cf22faa0/lerna.json\">Storybook</a></li>\n<li><a href=\"https://github.com/vuejs/vue-cli/blob/f7dc46d0692c2d8a07f5c8b0580177de81c150b0/lerna.json#L2\">Vue-cli</a></li>\n<li><a href=\"https://github.com/nuxt/framework/blob/a55c7874e6c22a8a927027cbf5f4149a8711525a/lerna.json#L3\">Nuxt.js</a></li>\n<li><a href=\"https://github.com/webpack/webpack-cli/blob/2f5e331f8786fbb21e349df3a7518886ac6deaa1/lerna.json#L5\">Webpack-cli</a></li>\n<li><a href=\"https://lerna.js.org/#users\">모든 레퍼런스</a></li></ul></li>\n<li>Lerna + Npm\n<ul><li><a href=\"https://github.com/apollographql/apollo-server/blob/90069be053f28deb9fc6b605f2008fc54909c255/lerna.json#L2\">Apollo-server</a></li></ul></li>\n<li>Nx\n<ul><li><a href=\"https://github.com/storybookjs/storybook/blob/275406ad764d9d02ff41ad7eb8983b52cf22faa0/nx.json#L1\">Storybook</a></li>\n<li><a href=\"https://github.com/microsoft/fluentui/blob/605d53a436a9dfb24075fdb39bb4c4823ee0b9ba/nx.json#L1\">FluentUI</a></li>\n<li><a href=\"https://github.com/ngrx/platform/blob/1d3e33735f5e438eab27e36681e04c0649ce48ac/nx.json#L1\">NgRx</a></li></ul></li>\n<li>Turborepo\n<ul><li><a href=\"https://vercel.com/\">Vercel</a></li>\n<li><a href=\"https://lattice.com/\">Lattice</a></li>\n<li><a href=\"https://spri.ng/\">TeeSpring</a></li>\n<li><a href=\"https://makeswift.com/\">MakeSwift</a></li>\n<li><a href=\"https://beondeck.com/\">On Deck</a></li>\n<li><a href=\"https://astro.build/\">Astro</a></li>\n<li><a href=\"https://github.com/vercel/turborepo/discussions/103\">모든 레퍼런스</a></li></ul></li>\n<li>Pnpm\n<ul><li><a href=\"https://github.com/vuejs/core/blob/1070f127a78bfe7da6fe550cc272ef11a1f434a0/pnpm-workspace.yaml#L1\">Vue 3</a></li>\n<li><a href=\"https://pnpm.io/users\">모든 레퍼런스</a></li></ul></li>\n</ul>\n\n<h2 id=\"\">마치며</h2>\n\n<p>다음 편에서는 위의 도구 중 Yarn, Lerna, Nx 그리고 Turborepo에 대해 자세히 알아보겠다.</p>","href":"this.company.rssUrl모던 프론트엔드 프로젝트 구성 기법 - 모노레포 개념 편"}