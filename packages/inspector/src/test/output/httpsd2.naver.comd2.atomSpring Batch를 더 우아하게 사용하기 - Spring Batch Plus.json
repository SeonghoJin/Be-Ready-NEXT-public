{"company":{"imageUrl":"/companyImages/naver.ico","name":"네이버","rssUrl":"https://d2.naver.com/d2.atom","href":"https://d2.naver.com/d2.atom","basePath":"https://d2.naver.com"},"title":"Spring Batch를 더 우아하게 사용하기 - Spring Batch Plus","createdAt":"2023-01-02T17:46:48Z","description":"\n개발 배경\n분산된 ItemReader ItemProcessor ItemWriter\n많은 종류의 Job\nItemStreamReaderProcessorWriter\nDomain Specific Language (DSL)\nType-safe Builder\nType-safe Builder를 구성하는 Kotlin 기능\nKotlin을 사용한 Internal DSL\nSpring Batch Kotlin DSL\n구조 분석\n설계 및 구현\n네이버페이 정산 프로젝트에 적용\n오픈 과정\n마치며\n\n\n\n\nSpring Batch Plus는 Spring Batch를 조금 더 편리하게 사용할 수 있게 유용한 기능을 제공하는 헬퍼 라이브러리입니다. Spring Batch Plus는 Kotlin 언어 사용 시 Spring Batch를 간결하게 설정하도록 도와주는 Spring Batch Kotlin DSL과 하나의 클래스에서 ItemReader, ItemProcessor, ItemWriter 모두를 작성하게 해주는 등의 다양한 기능을 제공합니다.\n\n저희는 매년 급속히 성장 중인 네이버페이를 개선하는 프로젝트를 진행하고 있습니다. 이 중에서 정산 플랫폼을 개선하는 프로젝트를 Kotlin 기반으로 Spring Batch를 활용하여 진행했습니다. 진행 과정에서 수십 개의 배치 Job을 작성해야 했는데 Spring Batch 기능을 그대로 사용하기에는 보일러플레이트 코드가 많고 파일도 많아지는 문제점이 있었습니다. 이를 해결하기 위해 여러 트릭을 사용했고 이를 담고 있는 라이브러리가 Spring Batch Plus입니다.\n\n이 글에서는 연간 52조 규모의 네이버페이 정산 플랫폼을 신규 시스템으로 전환하는 과정에서 탄생한 Spring Batch Plus의 개발 배경과 구현 과정에 대해서 알아보겠습니다.\n\n  \n\n개발 배경\n\n  \n\n분산된 ItemReader ItemProcessor ItemWriter\n\nSpring Batch 공식 문서에 따르면 Spring Batch의 Step은 ItemReader, ItemProcessor, ItemWriter로 구성되어 있다. ItemReader, ItemProcessor, ItemWriter는 각각 다음과 같이 정의한다.\n\n// ItemReader example\nclass TestItemReader : ItemReader<Int> {  \n    override fun read(): Int? {\n        return 3\n    }\n}\n\n\n// ItemProcessor example\nclass TestItemProcessor : ItemProcessor<Int, String> {  \n    override fun process(item: Int): String? {\n        return item.toString()\n    }\n}\n\n\n// ItemWriter example\nclass TestItemWriter : ItemWriter<String> {  \n    override fun write(items: MutableList<out String>) {\n        println(items)\n    }\n}\n\n\n이를 Step을 정의할 때 사용할 수 있다.\n\n@Bean\nopen fun testStep(  \n    stepBuilderFactory: StepBuilderFactory\n): Step {\n    return stepBuilderFactory.get(\"testStep\")\n        .chunk<Int, String>(3)\n        .reader(TestItemReader())\n        .processor(TestItemProcessor())\n        .writer(TestItemWriter())\n        .build()\n}\n\n\nSpring Batch는 ItemReader, ItemProcessor, ItemWriter를 각각 독립적으로 재활용할 수 있다고 가정하고 ItemReader, ItemProcessor, ItemWriter를 별도의 파일로 정의하도록 가이드 한다. 예를 들어 XML에서 데이터를 읽는 코드는 대부분 비슷할 테니 StaxEventItemReader로 미리 정의하고 필요할 때마다 재활용하는 식이다. 그런데 Spring Batch로 복잡한 데이터를 처리해야 할 경우 각 클래스는 특정한 도메인 로직을 처리하기 위해 사용하기 때문에 한 Step에서만 사용되도록 특수하게 구현하는 경우가 많다. 이럴 경우 특정 도메인을 처리하는 배치의 흐름을 알기 위해서는 ItemReader, ItemProcessor, ItemWriter 각각의 파일을 다 살펴봐야 해서 응집도가 낮아지는 문제점이 있다. 또한 ItemReader, ItemProcessor, ItemWriter 간 데이터 공유도 어렵다.\n\n  \n\n많은 종류의 Job\n\nSpring Batch는 Job이라는 단위로 배치 작업을 분류한다. 한 개의 Job은 한 개 또는 여러 개의 Step으로 구성된다.\n\n@Bean\nopen fun testJob(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory\n): Job {\n    return jobBuilderFactory.get(\"testJob\")\n        .start(\n            stepBuilderFactory.get(\"testStep1\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep2\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep3\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep4\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .build()\n}\n\n\n네이버페이 정산 시스템은  금액 집계, 지급 요청 등 서로 다른 역할을 하는 수십 개의 Job으로 구성된다. 그런데 이 Job은 상호 의존한다. 이를테면 정산 금액을 집계하지도 않았는데 판매자에게 정산 금액을 지급할 수는 없는 일이다. Spring Batch는 Job 간 의존관계를 설정할 수 있는 JobStep 기능을 제공한다. JobStep을 사용하면 한 Job에서 다른 Job을 Step처럼 사용할 수 있다. 네이버페이 정산 개편 프로젝트는 이를 활용하여 Job 간 의존관계를 정의했다.\n\n@Bean\nopen fun testJob(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory,\n    subJob1: Job,\n    subJob2: Job,\n): Job {\n    return jobBuilderFactory.get(\"testJob\")\n        .start(\n            stepBuilderFactory.get(\"subJob1Step\")\n                .job(subJob1)\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"subJob2Step\")\n                .job(subJob2)\n                .build()\n        )\n        .build()\n}\n\n@Bean\nopen fun subJob1(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory\n): Job {\n    return jobBuilderFactory.get(\"subJob1\")\n        .start(\n            stepBuilderFactory.get(\"subJob1 - step1\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"subJob1 - step2\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .build()\n}\n\n@Bean\nopen fun subJob2(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory\n): Job {\n    return jobBuilderFactory.get(\"subJob2\")\n        .start(\n            stepBuilderFactory.get(\"subJob2 - step1\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"subJob2 - step2\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .build()\n}\n\n\n그런데 이 코드에는 문제가 있다. 의존하는 Job을 모두 인자로 받아야 하고 build 등 불필요한 보일러플레이트 코드가 많다. 무엇보다 Kotlin스럽지 않은 객체 생성을 요구한다. Kotlin 생태계에서는 Type-safe builder를 활용하여 선언형으로 객체를 생성한다. 다음은 Kotlin 공식 문서에 있는 HTML 정보 생성 예시 코드이다.\n\nval htmlContent = html {  \n    head {\n        title {+\"XML encoding with Kotlin\"}\n    }\n    body {\n        h1 {+\"XML encoding with Kotlin\"}\n        p  {+\"this format can be used as an alternative markup to XML\"}\n        a(href = \"https://kotlinlang.org\") {+\"Kotlin\"}\n        ...\n    }\n}\n\n\n  \n\nItemStreamReaderProcessorWriter\n\n먼저 분산된 ItemReader, ItemProcessor, ItemWriter를 어떻게 통합했는지 살펴보자. 해결 과정은 의외로 간단했다. ItemReader, ItemProcessor, ItmeWriter 3개 모두 처리할 수 있는 클래스를 구현해서 Adaptor를 통해 기존 ItemReader, ItemProcessor, ItemWriter에 맞춰주었다. 프로젝트 진행 과정에서 stream 기능을 활용했기 때문에 실제로 사용한 객체는 ItemStreamReader, ItemProcessor, ItemStreamWriter였다. 이를 각각 위임해서 호출할 수 있는 인터페이스를 설계하고 단일 interface에 모두 담았다.\n\n// delegation for ItemStreamReader\npublic interface ItemStreamReaderDelegate<T> {\n\n    default void onOpenRead(@NonNull ExecutionContext executionContext) {\n    }\n\n    @NonNull\n    Flux<T> readFlux(@NonNull ExecutionContext executionContext);\n\n    default void onUpdateRead(@NonNull ExecutionContext executionContext) {\n    }\n\n    default void onCloseRead() {\n    }\n}\n\n\n// delegation for ItemProcessor\npublic interface ItemProcessorDelegate<I, O> {\n\n    @Nullable\n    O process(@NonNull I item);\n}\n\n\n// delegation for ItemStreamWriter\npublic interface ItemStreamWriterDelegate<T> {\n\n    default void onOpenWrite(@NonNull ExecutionContext executionContext) {\n    }\n\n    void write(@NonNull List<? extends T> items);\n\n    default void onUpdateWrite(@NonNull ExecutionContext executionContext) {\n    }\n\n    default void onCloseWrite() {\n    }\n}\n\n\n// holds all\npublic interface ItemStreamReaderProcessorWriter<I, O>  \n    extends ItemStreamReaderDelegate<I>, ItemProcessorDelegate<I, O>, ItemStreamWriterDelegate<O> {\n}\n\n\nItemStreamReaderDelegate의 경우 stream이라는 취지에 맞게 Spring 생태계에서 사용하는 Reactor의 Flux로 반환하게 했다.\n\n이렇게 정의한 ItemStreamReaderProcessorWriter를 기존 ItemStreamReader, ItemProcessor, ItemWriter에 맞추는 Adaptor를 정의해 사용했다.\n\n// single class example\n@Component\n@StepScope\nopen class SampleTasklet(  \n    @Value(\"#{jobParameters['totalCount']}\") private var totalCount: Long\n) : ItemStreamReaderProcessorWriter<Int, String> {\n    private var count = 0\n\n    override fun readFlux(executionContext: ExecutionContext): Flux<Int> {\n        println(\"totalCount: $totalCount\")\n        return Flux.generate { sink ->\n            if (count < totalCount) {\n                sink.next(count)\n                ++count\n            } else {\n                sink.complete()\n            }\n        }\n    }\n\n    override fun process(item: Int): String? {\n        return \"'$item'\"\n    }\n\n    override fun write(items: List<String>) {\n        println(items)\n    }\n}\n\n\n@Bean\nopen fun testStep(  \n    stepBuilderFactory: StepBuilderFactory,\n    sampleTasklet: SampleTasklet,\n): Step {\n    return stepBuilderFactory.get(\"testStep\")\n        .chunk<Int, String>(3)\n        .reader(sampleTasklet.asItemStreamReader()) // uses adaptor\n        .processor(sampleTasklet.asItemProcessor())\n        .writer(sampleTasklet.asItemStreamWriter())\n        .build()\n}\n\n\n  \n\nDomain Specific Language (DSL)\n\nSpring Batch Kotlin DSL 개발 과정을 알아보기 전에 DSL에 대해 먼저 살펴볼 필요가 있다. DSL(Domain Specific Language)은 특정 도메인에 대한 언어이다. 이는 컴퓨터로 해결 가능한 모든 문제를 정의하는 General Purpose Langauge와 대비된다. DSL의 대표 예시로는 SQL이 있다. SQL은 Structured Query Language의 약자로 데이터를 조작/정의하기 위한 언어이다. 다음은 나이가 20 이상의 사람 중 top 100명의 나이, 신장을 추출하는 SQL의 예시이다.\n\nSELECT  \n    height,\n    age\nFROM human  \nWHERE  \n    age >= 20\nORDER BY age DESC  \nLIMIT 100  \n\n\nDSL과 General Purpose Language(이하 GPL)와의 명확한 경계는 없다. 사실 우리는 적절한 이름의 함수를 추출해서 DSL을 만들고 있다고도 볼 수 있다. 하지만 DSL와 GPL 간에는 구조의 차이가 있다. GPL은 컴퓨터로 해결 가능한 모든 문제를 풀기 위한 자체 구문과 문법이 있다. 반면에 DSL은 특정 도메인에 특화된 구조가 있다. 이를테면 위의 SQL 예시에서 SELECT, WHERE의 순서를 바꾸면 동작하지 않는다.\n\nDSL은 External DSL과 Internal DSL로 구분된다. External DSL은 GPL과 별도의 구문이 있으며 자체 파서가 필요하다. 위 예시의 SQL이 External DSL이라고 할 수 있다. Internal DSL은 GPL을 이용하여 도메인 특화 언어처럼 느껴지게 하는 언어이다. GPL을 이용하면 기반 언어의 구문 체크, IDE 지원 등을 그대로 이용할 수 있다. 대표적인 예로 Gradle Kotlin DSL이 있다. 다음은 Kotlin Java Build라는 도메인을 설명하는 언어를 Kotlin으로 정의한 예이다.\n\nplugins {  \n    `java`\n}\n\ndependencies {  \n    api(\"junit:junit:4.13\")\n    implementation(\"junit:junit:4.13\")\n    testImplementation(\"junit:junit:4.13\")\n}\n\njava {  \n    sourceCompatibility = JavaVersion.VERSION_11\n    targetCompatibility = JavaVersion.VERSION_11\n}\n\n\n  \n\nType-safe Builder\n\nKotlin은 Type-safe builder라는 이름으로 Internal DSL을 생성하는 기능을 제공한다. Type-safe builder는 Kotlin의 여러 기능을 조합해서 만든다.\n\n\nHigher order function\nLambda expression\nTrailing Lambda\nFunction literals with Receiver\nInvoke operator\n\n\n  \n\nType-safe Builder를 구성하는 Kotlin 기능\n\nHigher order function은 함수를 인자로 받는 함수로, 함수 호출 시 다른 함수를 인자로 넘길 수 있다. 다음은 fold라는 함수를 정의하여 combine 함수를 인자로 받는 예이다.\n\n// definition\nfun <T, R> Collection<T>.fold(  \n    initial: R,\n    combine: (acc: R, nextElement: T) -> R\n): R {\n    var accumulator: R = initial\n    for (element : T in this) {\n        accumulator = combine(accumulator, element)\n    }\n    return accumulator\n}\n\n// usage\nval items = listOf(1, 2, 3, 4, 5)  \nval result = items.fold(0, fun(acc: Int, i: Int): Int {  \n    return acc + i\n})\n\n\nLambda expression은 익명 함수로, 쉽게 말해 함수 정의를 { ... }로 감싸서 처리하는 기능이다. 위의 예를 익명 함수를 사용하여 다시 구현하면 다음과 같다.\n\nval items = listOf(1, 2, 3, 4, 5)  \nval result = items.fold(0, { acc, i -> acc + i }) // usage  \n\n\nTrailing Lambda는 함수 마지막의 인자가 함수라면 Lambda expression을 ) 이후로 적게 해준다. 앞의 예에서 Trailing Lambda를 fold 함수에 사용하면 다음과 같아진다.\n\nval items = listOf(1, 2, 3, 4, 5)  \nval result = items.fold(0) { acc, i -> acc + i } // usage  \n\n\nFunction literals with Receiver는 조금 특별한 기능으로, receiver의 멤버를 this 키워드 없이 바로 호출할 수 있다. 아래 예시는 Function literals with Receiver (TestClass.() -> Unit)를 두 번째 인자로 사용하는 test라는 함수를 정의하여 호출 시 TestClass::doSomething2()를 this 키워드 없이 사용하는 예이다. 앞서 설명한 Trailing Lambda 기능을 활용하여 block 함수를 ) 이후에 넘기는 것을 볼 수 있다. 여기서 TestClass를 receiver 타입이라고 부른다.\n\nclass TestClass {  \n    fun doSomething1(): Int = 1\n\n    fun doSomething2(): Int = 2\n}\n\n// definition\nfun test(i: Int, block: TestClass.() -> Unit) {  \n    val testClass = TestClass()\n    testClass.apply(block)\n}\n\n// usage\ntest(3) {  \n    this.doSomething1()\n    doSomething2() // no need to use 'this'\n}\n\n\nInvoke operator는 해당 객체 자체를 호출하는 operator로 invoke라는 함수를 operator 키워드로 정의해서 사용 가능하다. 이는 실제 invoke 메서드를 호출하여 동작한다.\n\n// definition\nclass TestClass {  \n    operator fun invoke(block: TestClass.() -> Int) {\n        block()\n    }\n\n    fun doSomething1(): Int = 1\n\n    fun doSomething2(): Int = 2\n}\n\n// usage\nval testClass = TestClass()  \ntestClass {  \n    doSomething1()\n    doSomething2()\n}\n\n// actual action\ntestClass.invoke {  \n    doSomething1()\n    doSomething2()\n}\n\n\n  \n\nKotlin을 사용한 Internal DSL\n\n앞서 설명한 Kotlin의 다양한 기능을 종합하여 Type-safe Builder를 만들 수 있다. Type-safe Builder를 활용하여 Html을 생성하는 DSL을 만들면 다음과 같다.\n\n// entry point\nfun html(init: Html.() -> Unit): Html {  \n    val html = Html()\n    html.init()\n    return html\n}\n\nclass Html {  \n    fun head(init: Head.() -> Unit) {\n        val head = Head()\n        head.init()\n\n        // ...\n    }\n}\n\nclass Head {  \n    fun title(text: String) {\n        val title = Title(text)\n\n        // ...\n    }\n}\n\nclass Title(private val text: String)  \n\n\nHtml, Head, Title 클래스는 각각 Html, Head, Title 태그를 위한 클래스다. 위의 예에서 실제 태그를 저장하는 기능 등은 생략했다. 여기서는 html 함수가 Builder의 시작점이다. html 함수의 body를 보면 Html 클래스를 만들고 인자로 받은 Function literals with Receiver인 init을 호출하고 반환한다. html 함수를 활용하여 실제 HTML을 다음과 같이 만들 수 있다.\n\nval html = html {  \n    head {\n        title(\"title\")\n    }\n}\n\n\n얼핏 보면 구조가 겹쳐져 있어서 실제 어떻게 동작하는지 감을 잡기 힘들지 모르겠지만 사실 의외로 간단하다. Trailing Lambda를 활용하여 Function literals with Receiver를 계속 넘긴다. html 함수는 Html 클래스를 receiver 타입으로 하는 Function literal with Receiver를 인자로 받는다. 이를 통해 html 함수를 호출할 때 Html 클래스의 head 함수를 호출하는 Lambda expression을 Trailing Lambda를 활용하여 넘긴다. 실제 호출 구조는 다음과 같다.\n\nval html = html(  \n    fun Html.() {\n        this.head { // this : Html class\n            title(\"233\")\n        }\n    }\n)\n\n\n비슷하게 Html의 head 함수는 Head 클래스를 receiver 타입으로 하는 Function literal with Receiver를 인자로 받는다. 이를 통해 head 함수를 호출할 때 Head 클래스의 title 함수를 호출하는 Lambda expression을 Trailing Lambda를 활용하여 넘긴다. 이 경우에도 실제 호출 구조는 이전과 유사하다.\n\nval html = html {  \n    head(\n        fun Head.() {\n            this.title(\"233\") // this : Head class\n        }\n    )\n}\n\n\n그런데 이렇게 Lambda expression이 중첩되는 경우 head 안에서 다시 head를 호출할 수도 있다. head { ... } scope가 결국 html { ... } scope 안에 있기 때문에 head { ... } scope 안에서 다시 html { ... } scope 안에 있는 head 함수를 호출할 수도 있다. 즉, 문법상 다음과 같이 호출해도 문제는 없다.\n\nval html = html {  \n    head {\n        head { } // can call 'head' method of Html class\n    }\n}\n\n\n이 구조는 실제 HTML 구조와 맞지 않는다. Kotlin에서는 이런 경우를 방지하기 위해 @DslMarker를 제공한다. Builder 대상 클래스에 @DslMarker 애너테이션을 붙인 애너테이션을 만들어 scope를 제어하면 위와 같은 상황에 구문 오류를 발생시킨다.\n\n// @DslMarker usage\n@DslMarker\nannotation class HtmlTagMarker\n\n@HtmlTagMarker\nclass Html(...)\n\n@HtmlTagMarker\nclass Head(...)\n\n// usage\nval html = html {  \n    head {\n        head { } // error\n    }\n}\n\n\n  \n\nSpring Batch Kotlin DSL\n\n지금까지 DSL과 Kotlin에서 제공하는 기능인 Type-safe builder에 대해 알아보았다. 이 기능을 활용하여 Spring Batch Kotlin DSL을 어떻게 개발했는지 살펴보자.\n\n  \n\n구조 분석\n\nSpring Batch Kotlin DSL은 대상 도메인이 Spring Batch의 Builder이다. Spring Batch 4.3.x 기준에서 Builder는 크게 JobBuilder, StepBuilder, FlowBuilder로 나뉜다.\n\nJobBuilder의 구조는 다음과 같다. JobBuilderFactory가 JobBuilder를 생성한다. JobBuilder는 SimpleJobBuilder, FlowJobBuilder를 생성한다. SimpleJobBuilder, FlowJobBuilder는 JobFlowBuilder를 생성한다.\n\n\n\nFlowBuilder의 구조는 다음과 같다. FlowBuilder가 UnterminatedFlowBuilder, TransitionBuilder, SplitBuilder를 생성한다. JobFlowBuilder는 FlowBuilder를 상속한다.\n\n\n\nStepBuilder의 구조는 다음과 같다. StepBuilderFactory가 StepBuilder를 생성한다. StepBuilder는 SimpleStepBuilder, TaskletStepBuilder, JobStepBuilder, FlowStepBuiler, PartitionStepBuilder를 생성한다. FaultTolerantStepBuilder는 SimpleStepBuilder를 상속한다.\n\n\n\n  \n\n설계 및 구현\n\nSpring Batch Kotlin DSL이 다루는 것은 Spring Batch Builder이다. 그래서 구조를 기존과 유사하도록 설계했다. BatchDsl이라는 시작 클래스가 JobBuilderDsl, StepBuilderDsl, FlowBuilderDsl을 생성하고 각각 DSL에서 세부 Builder인 SimpleJobBuilderDsl, TaskletStepBuilderDsl 등을 생성할 수 있게 설계했다.\n\n\n\n구현을 어떻게 할지 정하기 위해 스프링 생태계에서 기존에 어떻게 하는지 살펴보았다. Spring Bean DSL에서는 다음과 같은 방식으로 DSL을 구성했다. beans라는 함수를 사용해서 Function literals with Receiver를 활용해서 bean이라는 함수를 연달아 정의하는 것을 확인할 수 있었다.\n\n// definition\nfun beans() = beans {  \n    bean<UserHandler>()\n    bean<Routes>()\n    ...\n}\n\nval context = GenericApplicationContext().apply {  \n    beans().invoke(this) // to register bean\n    refresh()\n}\n\n\n코드를 살펴보니 앞서 소개한 Html을 생성하는 DSL과 유사하게 구현되어 있는 것을 확인할 수 있었다.\n\nfun beans(init: BeanDefinitionDsl.() -> Unit) = BeanDefinitionDsl(init)\n\n...\n\nopen class BeanDefinitionDsl {  \n    ...\n\n    inline fun <reified T : Any> bean(name: String? = null,\n                                      scope: Scope? = null,\n                                      isLazyInit: Boolean? = null,\n                                      isPrimary: Boolean? = null,\n                                      isAutowireCandidate: Boolean? = null,\n                                      initMethodName: String? = null,\n                                      destroyMethodName: String? = null,\n                                      description: String? = null,\n                                      role: Role? = null) {\n    ...\n}\n\n\n또 다른 Spring 컴포넌트인 Spring Security에도 Kotlin DSL이 이미 있다. 다음은 Spring Security에서 ServerHttpSecurity를 생성하는 예이다.\n\n @Bean\n fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n        return http {\n            authorizeExchange {\n                authorize(\"/public\", permitAll)\n                authorize(anyExchange, authenticated)\n            }\n        }\n    }\n}\n\n\n이번에는 조금 다르게 Bean으로 객체를 받아서 호출한다. 코드를 살펴보니 invoke 함수를 호출하는 것을 확인할 수 있었다.\n\noperator fun ServerHttpSecurity.invoke(httpConfiguration: ServerHttpSecurityDsl.() -> Unit): SecurityWebFilterChain =  \n        ServerHttpSecurityDsl(this, httpConfiguration).build()\n\n\nSpring Batch Kotlin DSL에서 어떤 방식을 채택할지 고민이 많았다. 각 방식은 장단점이 있었다. Bean DSL 방식은 간단하게 함수 호출만으로 깔끔하게 작성할 수 있지만 실제 ApplicationContext와 연동하는 코드가 필요했다. Spring Security 방식은 가독성은 Bean DSL에 비해 떨어지지만 Bean으로 받은 객체의 값을 활용할 수 있다는 장점이 있었다.\n\nSpring Batch Kotlin DSL을 만들려고 할 때 고려 사항이 다음과 같았다.\n\n\nJobBuilderFactory, StepBuilderFactory를 직접 쓰지 않는다.\nBean에서도 이름으로 값을 가져오고 싶다.\nNested된 경우에도 유연하게 잘 처리될 수 있게 한다.\n기존에 되던 설정은 다 되게 한다.\n\n\nSpring Batch는 보통 Bean으로 등록된 JobBuilderFactory, StepBuilderFactory를 가져와서 사용한다. 또한 Bean을 가져오기 위해서는 BeanFactory를 사용해야 한다. 이런 이유로 Spring Batch Kotlin DSL에서는 Bean으로 등록된 객체를 invoke하는 Spring Security 방식을 채택했다. 다음과 같은 모습을 생각하고 구현했다.\n\n// before\n@Bean\nopen fun testJob(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory\n): Job {\n    return jobBuilderFactory.get(\"testJob\")\n        .start(\n            stepBuilderFactory.get(\"testStep1\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep2\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep3\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep4\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .build()\n}\n\n// after\n@Bean\nopen fun testJob(  \n    batch: BatchDsl\n): Job = batch {\n    job(\"testJob\") {\n        step(\"testStep1\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"testStep2\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"testStep3\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"testStep4\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n    }\n}\n\n\n구현은 Spring Batch에서 제공하는 Builder 클래스의 구조를 따라가면 되어 의외로 간단했다. 핵심 클래스인 BatchDsl의 코드를 살펴보면 다음과 같다.\n\n@BatchDslMarker\nclass BatchDsl internal constructor(  \n    private val dslContext: DslContext,\n) {\n    constructor(\n        beanFactory: BeanFactory,\n        jobBuilderFactory: JobBuilderFactory,\n        stepBuilderFactory: StepBuilderFactory\n    ) : this(\n        DslContext(\n            beanFactory,\n            jobBuilderFactory,\n            stepBuilderFactory\n        )\n    )\n\n    operator fun <T : Any> invoke(init: BatchDsl.() -> T): T = init()\n\n    fun job(name: String, init: JobBuilderDsl.() -> Unit): Job {\n        val jobBuilderFactory = this.dslContext.jobBuilderFactory\n        val jobBuilder = jobBuilderFactory.get(name)\n        return JobBuilderDsl(this.dslContext, jobBuilder).apply(init).build()\n    }\n\n    fun step(name: String, init: StepBuilderDsl.() -> Step): Step {\n        val stepBuilderFactory = this.dslContext.stepBuilderFactory\n        val stepBuilder = stepBuilderFactory.get(name)\n        return StepBuilderDsl(this.dslContext, stepBuilder).let(init)\n    }\n\n    fun flow(name: String, init: FlowBuilderDsl<Flow>.() -> Unit): Flow {\n        val flowBuilder = FlowBuilder<Flow>(name)\n        return ConcreteFlowBuilderDsl(this.dslContext, flowBuilder).apply(init).build()\n    }\n}\n\n\nBeanFactory, JobBuilderFactory, StepBuilderFactory를 담기 위해 DslContext라는 클래스를 만들었다. invoke 함수를 정의해서 BatchDsl 자체를 호출할 수 있게 했다. invoke 함수의 인자로는 BatchDsl 클래스를 receiver 타입으로 하는 Function literals with Receiver를 받아서 job, step, flow를 호출할 수 있게 했다.\n\n  \n\n네이버페이 정산 프로젝트에 적용\n\n앞서 정산 프로젝트의 subJob의 문제를 살펴보았다. Kotlin DSL을 활용하여 Job-subJob 구조를 정의하면 다음과 같다.\n\nopen fun testJob(batch: BatchDsl): Job = batch {  \n    job(\"testJob\") {\n        step(\"subJob1Step\") {\n            jobBean(\"subJob1\")\n        }\n        step(\"subJob2Step\") {\n            jobBean(\"subJob2\")\n        }\n    }\n}\n\n@Bean\nopen fun subJob1(batch: BatchDsl): Job = batch {  \n    job(\"subJob1\") {\n        step(\"subJob1 - step1\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"subJob1 - step2\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n    }\n}\n\n@Bean\nopen fun subJob2(batch: BatchDsl): Job = batch {  \n    job(\"subJob2\") {\n        step(\"subJob2 - step1\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"subJob2 - step2\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n    }\n}\n\n\nKotlin DSL을 통해 build, JobStepBuilderFactory, StepBuilderFactory 같은 보일러플레이트 코드를 제거하고 Kotlin스럽게 선언형으로 작성했다.\n\n  \n\n오픈 과정\n\n어느 정도 안정화가 된 후 DSL의 경우 Spring Batch에 직접 기여하면 되지 않을까 해서 Issue를 생성해서 Spring Batch Maintainer에게 의견을 물었다. 하지만 Maintainer는 내부 논의 결과 이런 기능은 포함시키지 않기로 이전에 결정했다고 Spring Batch Extension에 등록하라고 답변했다.\n\n\n\n그래서 정산 배치 모듈에 있는 Spring Batch 개선 코드를 정리하여 Spring Batch Extension에 PR을 등록했다.\n\n하지만 1년이 지나도 해당 GitHub 저장소 운영자의 응답이 없었고 결국 별도의 오픈소스 프로젝트로 진행하기로 했다. 이름은 조직 내에서 이미 나온 Spring Jdbc Plus의 이름을 따서 Spring Batch Plus로 지었다. Spring Batch Plus라는 이름답게 Kotlin DSL, ItemStreamReaderProcessorWriter뿐만 아니라 프로젝트 진행 과정에서 사용한 다른 기능도 포함시켰다. 자세한 기능은 공식 문서에서 확인할 수 있다.\n\n  \n\n마치며\n\nSpring Batch Plus가 무엇을 해결하고자 했고 어떤 과정을 통해 세상에 나왔는지 살펴보았다. Spring Batch Plus를 작성함으로써 네이버페이 정산 플랫폼을 신규 시스템으로 전환하는 코드 작성을 보다 깔끔하게 할 수 있었다.\n\nSpring Batch Plus는 연간 52조 규모의 거래액을 다루는 네이버페이 정산의 83개 Job과, 네이버페이 포인트의 29개 Job에 실제 사용된 라이브러리이다. Spring Batch의 Builder를 Kotlin스럽게 작성하고 싶거나 단일 클래스에서 ItemReader, ItemProcessor, ItemWriter를 작성하고 싶다면 Spring Batch Plus 사용을 고려해 볼 수 있다. 이 글 작성 기준으로 Spring Batch Plus는 Spring Batch 4.3.x 버전과 호환되고, 간단히 다음을 참고하여 의존성만 추가하면 사용 가능하다. 자세한 호환 정보는 Compatibility를 참고하길 바란다.\n\nimplementation(\"org.springframework.batch:spring-batch-core:4.3.7\")  \nimplementation(\"com.navercorp.spring:spring-boot-starter-batch-plus-kotlin:0.2.0\")  \n\n\nSpring Batch Plus는 이름에서 알 수 있듯이 Spring Batch에 여러 유용한 기능을 추가한다는 취지의 라이브러리이다. Spring Batch를 사용면서 이런 기능이 있으면 좋겠는데 Spring Batch에 넣기는 애매하다 싶으면 Spring Batch Plus GitHub 저장소에 PR이나 Issue를 등록해주길 바란다.}","rawText":"\n개발 배경\n분산된 ItemReader ItemProcessor ItemWriter\n많은 종류의 Job\nItemStreamReaderProcessorWriter\nDomain Specific Language (DSL)\nType-safe Builder\nType-safe Builder를 구성하는 Kotlin 기능\nKotlin을 사용한 Internal DSL\nSpring Batch Kotlin DSL\n구조 분석\n설계 및 구현\n네이버페이 정산 프로젝트에 적용\n오픈 과정\n마치며\n\n\n\n\nSpring Batch Plus는 Spring Batch를 조금 더 편리하게 사용할 수 있게 유용한 기능을 제공하는 헬퍼 라이브러리입니다. Spring Batch Plus는 Kotlin 언어 사용 시 Spring Batch를 간결하게 설정하도록 도와주는 Spring Batch Kotlin DSL과 하나의 클래스에서 ItemReader, ItemProcessor, ItemWriter 모두를 작성하게 해주는 등의 다양한 기능을 제공합니다.\n\n저희는 매년 급속히 성장 중인 네이버페이를 개선하는 프로젝트를 진행하고 있습니다. 이 중에서 정산 플랫폼을 개선하는 프로젝트를 Kotlin 기반으로 Spring Batch를 활용하여 진행했습니다. 진행 과정에서 수십 개의 배치 Job을 작성해야 했는데 Spring Batch 기능을 그대로 사용하기에는 보일러플레이트 코드가 많고 파일도 많아지는 문제점이 있었습니다. 이를 해결하기 위해 여러 트릭을 사용했고 이를 담고 있는 라이브러리가 Spring Batch Plus입니다.\n\n이 글에서는 연간 52조 규모의 네이버페이 정산 플랫폼을 신규 시스템으로 전환하는 과정에서 탄생한 Spring Batch Plus의 개발 배경과 구현 과정에 대해서 알아보겠습니다.\n\n  \n\n개발 배경\n\n  \n\n분산된 ItemReader ItemProcessor ItemWriter\n\nSpring Batch 공식 문서에 따르면 Spring Batch의 Step은 ItemReader, ItemProcessor, ItemWriter로 구성되어 있다. ItemReader, ItemProcessor, ItemWriter는 각각 다음과 같이 정의한다.\n\n// ItemReader example\nclass TestItemReader : ItemReader<Int> {  \n    override fun read(): Int? {\n        return 3\n    }\n}\n\n\n// ItemProcessor example\nclass TestItemProcessor : ItemProcessor<Int, String> {  \n    override fun process(item: Int): String? {\n        return item.toString()\n    }\n}\n\n\n// ItemWriter example\nclass TestItemWriter : ItemWriter<String> {  \n    override fun write(items: MutableList<out String>) {\n        println(items)\n    }\n}\n\n\n이를 Step을 정의할 때 사용할 수 있다.\n\n@Bean\nopen fun testStep(  \n    stepBuilderFactory: StepBuilderFactory\n): Step {\n    return stepBuilderFactory.get(\"testStep\")\n        .chunk<Int, String>(3)\n        .reader(TestItemReader())\n        .processor(TestItemProcessor())\n        .writer(TestItemWriter())\n        .build()\n}\n\n\nSpring Batch는 ItemReader, ItemProcessor, ItemWriter를 각각 독립적으로 재활용할 수 있다고 가정하고 ItemReader, ItemProcessor, ItemWriter를 별도의 파일로 정의하도록 가이드 한다. 예를 들어 XML에서 데이터를 읽는 코드는 대부분 비슷할 테니 StaxEventItemReader로 미리 정의하고 필요할 때마다 재활용하는 식이다. 그런데 Spring Batch로 복잡한 데이터를 처리해야 할 경우 각 클래스는 특정한 도메인 로직을 처리하기 위해 사용하기 때문에 한 Step에서만 사용되도록 특수하게 구현하는 경우가 많다. 이럴 경우 특정 도메인을 처리하는 배치의 흐름을 알기 위해서는 ItemReader, ItemProcessor, ItemWriter 각각의 파일을 다 살펴봐야 해서 응집도가 낮아지는 문제점이 있다. 또한 ItemReader, ItemProcessor, ItemWriter 간 데이터 공유도 어렵다.\n\n  \n\n많은 종류의 Job\n\nSpring Batch는 Job이라는 단위로 배치 작업을 분류한다. 한 개의 Job은 한 개 또는 여러 개의 Step으로 구성된다.\n\n@Bean\nopen fun testJob(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory\n): Job {\n    return jobBuilderFactory.get(\"testJob\")\n        .start(\n            stepBuilderFactory.get(\"testStep1\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep2\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep3\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep4\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .build()\n}\n\n\n네이버페이 정산 시스템은  금액 집계, 지급 요청 등 서로 다른 역할을 하는 수십 개의 Job으로 구성된다. 그런데 이 Job은 상호 의존한다. 이를테면 정산 금액을 집계하지도 않았는데 판매자에게 정산 금액을 지급할 수는 없는 일이다. Spring Batch는 Job 간 의존관계를 설정할 수 있는 JobStep 기능을 제공한다. JobStep을 사용하면 한 Job에서 다른 Job을 Step처럼 사용할 수 있다. 네이버페이 정산 개편 프로젝트는 이를 활용하여 Job 간 의존관계를 정의했다.\n\n@Bean\nopen fun testJob(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory,\n    subJob1: Job,\n    subJob2: Job,\n): Job {\n    return jobBuilderFactory.get(\"testJob\")\n        .start(\n            stepBuilderFactory.get(\"subJob1Step\")\n                .job(subJob1)\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"subJob2Step\")\n                .job(subJob2)\n                .build()\n        )\n        .build()\n}\n\n@Bean\nopen fun subJob1(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory\n): Job {\n    return jobBuilderFactory.get(\"subJob1\")\n        .start(\n            stepBuilderFactory.get(\"subJob1 - step1\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"subJob1 - step2\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .build()\n}\n\n@Bean\nopen fun subJob2(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory\n): Job {\n    return jobBuilderFactory.get(\"subJob2\")\n        .start(\n            stepBuilderFactory.get(\"subJob2 - step1\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"subJob2 - step2\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .build()\n}\n\n\n그런데 이 코드에는 문제가 있다. 의존하는 Job을 모두 인자로 받아야 하고 build 등 불필요한 보일러플레이트 코드가 많다. 무엇보다 Kotlin스럽지 않은 객체 생성을 요구한다. Kotlin 생태계에서는 Type-safe builder를 활용하여 선언형으로 객체를 생성한다. 다음은 Kotlin 공식 문서에 있는 HTML 정보 생성 예시 코드이다.\n\nval htmlContent = html {  \n    head {\n        title {+\"XML encoding with Kotlin\"}\n    }\n    body {\n        h1 {+\"XML encoding with Kotlin\"}\n        p  {+\"this format can be used as an alternative markup to XML\"}\n        a(href = \"https://kotlinlang.org\") {+\"Kotlin\"}\n        ...\n    }\n}\n\n\n  \n\nItemStreamReaderProcessorWriter\n\n먼저 분산된 ItemReader, ItemProcessor, ItemWriter를 어떻게 통합했는지 살펴보자. 해결 과정은 의외로 간단했다. ItemReader, ItemProcessor, ItmeWriter 3개 모두 처리할 수 있는 클래스를 구현해서 Adaptor를 통해 기존 ItemReader, ItemProcessor, ItemWriter에 맞춰주었다. 프로젝트 진행 과정에서 stream 기능을 활용했기 때문에 실제로 사용한 객체는 ItemStreamReader, ItemProcessor, ItemStreamWriter였다. 이를 각각 위임해서 호출할 수 있는 인터페이스를 설계하고 단일 interface에 모두 담았다.\n\n// delegation for ItemStreamReader\npublic interface ItemStreamReaderDelegate<T> {\n\n    default void onOpenRead(@NonNull ExecutionContext executionContext) {\n    }\n\n    @NonNull\n    Flux<T> readFlux(@NonNull ExecutionContext executionContext);\n\n    default void onUpdateRead(@NonNull ExecutionContext executionContext) {\n    }\n\n    default void onCloseRead() {\n    }\n}\n\n\n// delegation for ItemProcessor\npublic interface ItemProcessorDelegate<I, O> {\n\n    @Nullable\n    O process(@NonNull I item);\n}\n\n\n// delegation for ItemStreamWriter\npublic interface ItemStreamWriterDelegate<T> {\n\n    default void onOpenWrite(@NonNull ExecutionContext executionContext) {\n    }\n\n    void write(@NonNull List<? extends T> items);\n\n    default void onUpdateWrite(@NonNull ExecutionContext executionContext) {\n    }\n\n    default void onCloseWrite() {\n    }\n}\n\n\n// holds all\npublic interface ItemStreamReaderProcessorWriter<I, O>  \n    extends ItemStreamReaderDelegate<I>, ItemProcessorDelegate<I, O>, ItemStreamWriterDelegate<O> {\n}\n\n\nItemStreamReaderDelegate의 경우 stream이라는 취지에 맞게 Spring 생태계에서 사용하는 Reactor의 Flux로 반환하게 했다.\n\n이렇게 정의한 ItemStreamReaderProcessorWriter를 기존 ItemStreamReader, ItemProcessor, ItemWriter에 맞추는 Adaptor를 정의해 사용했다.\n\n// single class example\n@Component\n@StepScope\nopen class SampleTasklet(  \n    @Value(\"#{jobParameters['totalCount']}\") private var totalCount: Long\n) : ItemStreamReaderProcessorWriter<Int, String> {\n    private var count = 0\n\n    override fun readFlux(executionContext: ExecutionContext): Flux<Int> {\n        println(\"totalCount: $totalCount\")\n        return Flux.generate { sink ->\n            if (count < totalCount) {\n                sink.next(count)\n                ++count\n            } else {\n                sink.complete()\n            }\n        }\n    }\n\n    override fun process(item: Int): String? {\n        return \"'$item'\"\n    }\n\n    override fun write(items: List<String>) {\n        println(items)\n    }\n}\n\n\n@Bean\nopen fun testStep(  \n    stepBuilderFactory: StepBuilderFactory,\n    sampleTasklet: SampleTasklet,\n): Step {\n    return stepBuilderFactory.get(\"testStep\")\n        .chunk<Int, String>(3)\n        .reader(sampleTasklet.asItemStreamReader()) // uses adaptor\n        .processor(sampleTasklet.asItemProcessor())\n        .writer(sampleTasklet.asItemStreamWriter())\n        .build()\n}\n\n\n  \n\nDomain Specific Language (DSL)\n\nSpring Batch Kotlin DSL 개발 과정을 알아보기 전에 DSL에 대해 먼저 살펴볼 필요가 있다. DSL(Domain Specific Language)은 특정 도메인에 대한 언어이다. 이는 컴퓨터로 해결 가능한 모든 문제를 정의하는 General Purpose Langauge와 대비된다. DSL의 대표 예시로는 SQL이 있다. SQL은 Structured Query Language의 약자로 데이터를 조작/정의하기 위한 언어이다. 다음은 나이가 20 이상의 사람 중 top 100명의 나이, 신장을 추출하는 SQL의 예시이다.\n\nSELECT  \n    height,\n    age\nFROM human  \nWHERE  \n    age >= 20\nORDER BY age DESC  \nLIMIT 100  \n\n\nDSL과 General Purpose Language(이하 GPL)와의 명확한 경계는 없다. 사실 우리는 적절한 이름의 함수를 추출해서 DSL을 만들고 있다고도 볼 수 있다. 하지만 DSL와 GPL 간에는 구조의 차이가 있다. GPL은 컴퓨터로 해결 가능한 모든 문제를 풀기 위한 자체 구문과 문법이 있다. 반면에 DSL은 특정 도메인에 특화된 구조가 있다. 이를테면 위의 SQL 예시에서 SELECT, WHERE의 순서를 바꾸면 동작하지 않는다.\n\nDSL은 External DSL과 Internal DSL로 구분된다. External DSL은 GPL과 별도의 구문이 있으며 자체 파서가 필요하다. 위 예시의 SQL이 External DSL이라고 할 수 있다. Internal DSL은 GPL을 이용하여 도메인 특화 언어처럼 느껴지게 하는 언어이다. GPL을 이용하면 기반 언어의 구문 체크, IDE 지원 등을 그대로 이용할 수 있다. 대표적인 예로 Gradle Kotlin DSL이 있다. 다음은 Kotlin Java Build라는 도메인을 설명하는 언어를 Kotlin으로 정의한 예이다.\n\nplugins {  \n    `java`\n}\n\ndependencies {  \n    api(\"junit:junit:4.13\")\n    implementation(\"junit:junit:4.13\")\n    testImplementation(\"junit:junit:4.13\")\n}\n\njava {  \n    sourceCompatibility = JavaVersion.VERSION_11\n    targetCompatibility = JavaVersion.VERSION_11\n}\n\n\n  \n\nType-safe Builder\n\nKotlin은 Type-safe builder라는 이름으로 Internal DSL을 생성하는 기능을 제공한다. Type-safe builder는 Kotlin의 여러 기능을 조합해서 만든다.\n\n\nHigher order function\nLambda expression\nTrailing Lambda\nFunction literals with Receiver\nInvoke operator\n\n\n  \n\nType-safe Builder를 구성하는 Kotlin 기능\n\nHigher order function은 함수를 인자로 받는 함수로, 함수 호출 시 다른 함수를 인자로 넘길 수 있다. 다음은 fold라는 함수를 정의하여 combine 함수를 인자로 받는 예이다.\n\n// definition\nfun <T, R> Collection<T>.fold(  \n    initial: R,\n    combine: (acc: R, nextElement: T) -> R\n): R {\n    var accumulator: R = initial\n    for (element : T in this) {\n        accumulator = combine(accumulator, element)\n    }\n    return accumulator\n}\n\n// usage\nval items = listOf(1, 2, 3, 4, 5)  \nval result = items.fold(0, fun(acc: Int, i: Int): Int {  \n    return acc + i\n})\n\n\nLambda expression은 익명 함수로, 쉽게 말해 함수 정의를 { ... }로 감싸서 처리하는 기능이다. 위의 예를 익명 함수를 사용하여 다시 구현하면 다음과 같다.\n\nval items = listOf(1, 2, 3, 4, 5)  \nval result = items.fold(0, { acc, i -> acc + i }) // usage  \n\n\nTrailing Lambda는 함수 마지막의 인자가 함수라면 Lambda expression을 ) 이후로 적게 해준다. 앞의 예에서 Trailing Lambda를 fold 함수에 사용하면 다음과 같아진다.\n\nval items = listOf(1, 2, 3, 4, 5)  \nval result = items.fold(0) { acc, i -> acc + i } // usage  \n\n\nFunction literals with Receiver는 조금 특별한 기능으로, receiver의 멤버를 this 키워드 없이 바로 호출할 수 있다. 아래 예시는 Function literals with Receiver (TestClass.() -> Unit)를 두 번째 인자로 사용하는 test라는 함수를 정의하여 호출 시 TestClass::doSomething2()를 this 키워드 없이 사용하는 예이다. 앞서 설명한 Trailing Lambda 기능을 활용하여 block 함수를 ) 이후에 넘기는 것을 볼 수 있다. 여기서 TestClass를 receiver 타입이라고 부른다.\n\nclass TestClass {  \n    fun doSomething1(): Int = 1\n\n    fun doSomething2(): Int = 2\n}\n\n// definition\nfun test(i: Int, block: TestClass.() -> Unit) {  \n    val testClass = TestClass()\n    testClass.apply(block)\n}\n\n// usage\ntest(3) {  \n    this.doSomething1()\n    doSomething2() // no need to use 'this'\n}\n\n\nInvoke operator는 해당 객체 자체를 호출하는 operator로 invoke라는 함수를 operator 키워드로 정의해서 사용 가능하다. 이는 실제 invoke 메서드를 호출하여 동작한다.\n\n// definition\nclass TestClass {  \n    operator fun invoke(block: TestClass.() -> Int) {\n        block()\n    }\n\n    fun doSomething1(): Int = 1\n\n    fun doSomething2(): Int = 2\n}\n\n// usage\nval testClass = TestClass()  \ntestClass {  \n    doSomething1()\n    doSomething2()\n}\n\n// actual action\ntestClass.invoke {  \n    doSomething1()\n    doSomething2()\n}\n\n\n  \n\nKotlin을 사용한 Internal DSL\n\n앞서 설명한 Kotlin의 다양한 기능을 종합하여 Type-safe Builder를 만들 수 있다. Type-safe Builder를 활용하여 Html을 생성하는 DSL을 만들면 다음과 같다.\n\n// entry point\nfun html(init: Html.() -> Unit): Html {  \n    val html = Html()\n    html.init()\n    return html\n}\n\nclass Html {  \n    fun head(init: Head.() -> Unit) {\n        val head = Head()\n        head.init()\n\n        // ...\n    }\n}\n\nclass Head {  \n    fun title(text: String) {\n        val title = Title(text)\n\n        // ...\n    }\n}\n\nclass Title(private val text: String)  \n\n\nHtml, Head, Title 클래스는 각각 Html, Head, Title 태그를 위한 클래스다. 위의 예에서 실제 태그를 저장하는 기능 등은 생략했다. 여기서는 html 함수가 Builder의 시작점이다. html 함수의 body를 보면 Html 클래스를 만들고 인자로 받은 Function literals with Receiver인 init을 호출하고 반환한다. html 함수를 활용하여 실제 HTML을 다음과 같이 만들 수 있다.\n\nval html = html {  \n    head {\n        title(\"title\")\n    }\n}\n\n\n얼핏 보면 구조가 겹쳐져 있어서 실제 어떻게 동작하는지 감을 잡기 힘들지 모르겠지만 사실 의외로 간단하다. Trailing Lambda를 활용하여 Function literals with Receiver를 계속 넘긴다. html 함수는 Html 클래스를 receiver 타입으로 하는 Function literal with Receiver를 인자로 받는다. 이를 통해 html 함수를 호출할 때 Html 클래스의 head 함수를 호출하는 Lambda expression을 Trailing Lambda를 활용하여 넘긴다. 실제 호출 구조는 다음과 같다.\n\nval html = html(  \n    fun Html.() {\n        this.head { // this : Html class\n            title(\"233\")\n        }\n    }\n)\n\n\n비슷하게 Html의 head 함수는 Head 클래스를 receiver 타입으로 하는 Function literal with Receiver를 인자로 받는다. 이를 통해 head 함수를 호출할 때 Head 클래스의 title 함수를 호출하는 Lambda expression을 Trailing Lambda를 활용하여 넘긴다. 이 경우에도 실제 호출 구조는 이전과 유사하다.\n\nval html = html {  \n    head(\n        fun Head.() {\n            this.title(\"233\") // this : Head class\n        }\n    )\n}\n\n\n그런데 이렇게 Lambda expression이 중첩되는 경우 head 안에서 다시 head를 호출할 수도 있다. head { ... } scope가 결국 html { ... } scope 안에 있기 때문에 head { ... } scope 안에서 다시 html { ... } scope 안에 있는 head 함수를 호출할 수도 있다. 즉, 문법상 다음과 같이 호출해도 문제는 없다.\n\nval html = html {  \n    head {\n        head { } // can call 'head' method of Html class\n    }\n}\n\n\n이 구조는 실제 HTML 구조와 맞지 않는다. Kotlin에서는 이런 경우를 방지하기 위해 @DslMarker를 제공한다. Builder 대상 클래스에 @DslMarker 애너테이션을 붙인 애너테이션을 만들어 scope를 제어하면 위와 같은 상황에 구문 오류를 발생시킨다.\n\n// @DslMarker usage\n@DslMarker\nannotation class HtmlTagMarker\n\n@HtmlTagMarker\nclass Html(...)\n\n@HtmlTagMarker\nclass Head(...)\n\n// usage\nval html = html {  \n    head {\n        head { } // error\n    }\n}\n\n\n  \n\nSpring Batch Kotlin DSL\n\n지금까지 DSL과 Kotlin에서 제공하는 기능인 Type-safe builder에 대해 알아보았다. 이 기능을 활용하여 Spring Batch Kotlin DSL을 어떻게 개발했는지 살펴보자.\n\n  \n\n구조 분석\n\nSpring Batch Kotlin DSL은 대상 도메인이 Spring Batch의 Builder이다. Spring Batch 4.3.x 기준에서 Builder는 크게 JobBuilder, StepBuilder, FlowBuilder로 나뉜다.\n\nJobBuilder의 구조는 다음과 같다. JobBuilderFactory가 JobBuilder를 생성한다. JobBuilder는 SimpleJobBuilder, FlowJobBuilder를 생성한다. SimpleJobBuilder, FlowJobBuilder는 JobFlowBuilder를 생성한다.\n\n\n\nFlowBuilder의 구조는 다음과 같다. FlowBuilder가 UnterminatedFlowBuilder, TransitionBuilder, SplitBuilder를 생성한다. JobFlowBuilder는 FlowBuilder를 상속한다.\n\n\n\nStepBuilder의 구조는 다음과 같다. StepBuilderFactory가 StepBuilder를 생성한다. StepBuilder는 SimpleStepBuilder, TaskletStepBuilder, JobStepBuilder, FlowStepBuiler, PartitionStepBuilder를 생성한다. FaultTolerantStepBuilder는 SimpleStepBuilder를 상속한다.\n\n\n\n  \n\n설계 및 구현\n\nSpring Batch Kotlin DSL이 다루는 것은 Spring Batch Builder이다. 그래서 구조를 기존과 유사하도록 설계했다. BatchDsl이라는 시작 클래스가 JobBuilderDsl, StepBuilderDsl, FlowBuilderDsl을 생성하고 각각 DSL에서 세부 Builder인 SimpleJobBuilderDsl, TaskletStepBuilderDsl 등을 생성할 수 있게 설계했다.\n\n\n\n구현을 어떻게 할지 정하기 위해 스프링 생태계에서 기존에 어떻게 하는지 살펴보았다. Spring Bean DSL에서는 다음과 같은 방식으로 DSL을 구성했다. beans라는 함수를 사용해서 Function literals with Receiver를 활용해서 bean이라는 함수를 연달아 정의하는 것을 확인할 수 있었다.\n\n// definition\nfun beans() = beans {  \n    bean<UserHandler>()\n    bean<Routes>()\n    ...\n}\n\nval context = GenericApplicationContext().apply {  \n    beans().invoke(this) // to register bean\n    refresh()\n}\n\n\n코드를 살펴보니 앞서 소개한 Html을 생성하는 DSL과 유사하게 구현되어 있는 것을 확인할 수 있었다.\n\nfun beans(init: BeanDefinitionDsl.() -> Unit) = BeanDefinitionDsl(init)\n\n...\n\nopen class BeanDefinitionDsl {  \n    ...\n\n    inline fun <reified T : Any> bean(name: String? = null,\n                                      scope: Scope? = null,\n                                      isLazyInit: Boolean? = null,\n                                      isPrimary: Boolean? = null,\n                                      isAutowireCandidate: Boolean? = null,\n                                      initMethodName: String? = null,\n                                      destroyMethodName: String? = null,\n                                      description: String? = null,\n                                      role: Role? = null) {\n    ...\n}\n\n\n또 다른 Spring 컴포넌트인 Spring Security에도 Kotlin DSL이 이미 있다. 다음은 Spring Security에서 ServerHttpSecurity를 생성하는 예이다.\n\n @Bean\n fun springWebFilterChain(http: ServerHttpSecurity): SecurityWebFilterChain {\n        return http {\n            authorizeExchange {\n                authorize(\"/public\", permitAll)\n                authorize(anyExchange, authenticated)\n            }\n        }\n    }\n}\n\n\n이번에는 조금 다르게 Bean으로 객체를 받아서 호출한다. 코드를 살펴보니 invoke 함수를 호출하는 것을 확인할 수 있었다.\n\noperator fun ServerHttpSecurity.invoke(httpConfiguration: ServerHttpSecurityDsl.() -> Unit): SecurityWebFilterChain =  \n        ServerHttpSecurityDsl(this, httpConfiguration).build()\n\n\nSpring Batch Kotlin DSL에서 어떤 방식을 채택할지 고민이 많았다. 각 방식은 장단점이 있었다. Bean DSL 방식은 간단하게 함수 호출만으로 깔끔하게 작성할 수 있지만 실제 ApplicationContext와 연동하는 코드가 필요했다. Spring Security 방식은 가독성은 Bean DSL에 비해 떨어지지만 Bean으로 받은 객체의 값을 활용할 수 있다는 장점이 있었다.\n\nSpring Batch Kotlin DSL을 만들려고 할 때 고려 사항이 다음과 같았다.\n\n\nJobBuilderFactory, StepBuilderFactory를 직접 쓰지 않는다.\nBean에서도 이름으로 값을 가져오고 싶다.\nNested된 경우에도 유연하게 잘 처리될 수 있게 한다.\n기존에 되던 설정은 다 되게 한다.\n\n\nSpring Batch는 보통 Bean으로 등록된 JobBuilderFactory, StepBuilderFactory를 가져와서 사용한다. 또한 Bean을 가져오기 위해서는 BeanFactory를 사용해야 한다. 이런 이유로 Spring Batch Kotlin DSL에서는 Bean으로 등록된 객체를 invoke하는 Spring Security 방식을 채택했다. 다음과 같은 모습을 생각하고 구현했다.\n\n// before\n@Bean\nopen fun testJob(  \n    jobBuilderFactory: JobBuilderFactory,\n    stepBuilderFactory: StepBuilderFactory\n): Job {\n    return jobBuilderFactory.get(\"testJob\")\n        .start(\n            stepBuilderFactory.get(\"testStep1\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep2\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep3\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .next(\n            stepBuilderFactory.get(\"testStep4\")\n                .tasklet { _, _ -> RepeatStatus.FINISHED }\n                .build()\n        )\n        .build()\n}\n\n// after\n@Bean\nopen fun testJob(  \n    batch: BatchDsl\n): Job = batch {\n    job(\"testJob\") {\n        step(\"testStep1\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"testStep2\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"testStep3\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"testStep4\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n    }\n}\n\n\n구현은 Spring Batch에서 제공하는 Builder 클래스의 구조를 따라가면 되어 의외로 간단했다. 핵심 클래스인 BatchDsl의 코드를 살펴보면 다음과 같다.\n\n@BatchDslMarker\nclass BatchDsl internal constructor(  \n    private val dslContext: DslContext,\n) {\n    constructor(\n        beanFactory: BeanFactory,\n        jobBuilderFactory: JobBuilderFactory,\n        stepBuilderFactory: StepBuilderFactory\n    ) : this(\n        DslContext(\n            beanFactory,\n            jobBuilderFactory,\n            stepBuilderFactory\n        )\n    )\n\n    operator fun <T : Any> invoke(init: BatchDsl.() -> T): T = init()\n\n    fun job(name: String, init: JobBuilderDsl.() -> Unit): Job {\n        val jobBuilderFactory = this.dslContext.jobBuilderFactory\n        val jobBuilder = jobBuilderFactory.get(name)\n        return JobBuilderDsl(this.dslContext, jobBuilder).apply(init).build()\n    }\n\n    fun step(name: String, init: StepBuilderDsl.() -> Step): Step {\n        val stepBuilderFactory = this.dslContext.stepBuilderFactory\n        val stepBuilder = stepBuilderFactory.get(name)\n        return StepBuilderDsl(this.dslContext, stepBuilder).let(init)\n    }\n\n    fun flow(name: String, init: FlowBuilderDsl<Flow>.() -> Unit): Flow {\n        val flowBuilder = FlowBuilder<Flow>(name)\n        return ConcreteFlowBuilderDsl(this.dslContext, flowBuilder).apply(init).build()\n    }\n}\n\n\nBeanFactory, JobBuilderFactory, StepBuilderFactory를 담기 위해 DslContext라는 클래스를 만들었다. invoke 함수를 정의해서 BatchDsl 자체를 호출할 수 있게 했다. invoke 함수의 인자로는 BatchDsl 클래스를 receiver 타입으로 하는 Function literals with Receiver를 받아서 job, step, flow를 호출할 수 있게 했다.\n\n  \n\n네이버페이 정산 프로젝트에 적용\n\n앞서 정산 프로젝트의 subJob의 문제를 살펴보았다. Kotlin DSL을 활용하여 Job-subJob 구조를 정의하면 다음과 같다.\n\nopen fun testJob(batch: BatchDsl): Job = batch {  \n    job(\"testJob\") {\n        step(\"subJob1Step\") {\n            jobBean(\"subJob1\")\n        }\n        step(\"subJob2Step\") {\n            jobBean(\"subJob2\")\n        }\n    }\n}\n\n@Bean\nopen fun subJob1(batch: BatchDsl): Job = batch {  \n    job(\"subJob1\") {\n        step(\"subJob1 - step1\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"subJob1 - step2\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n    }\n}\n\n@Bean\nopen fun subJob2(batch: BatchDsl): Job = batch {  \n    job(\"subJob2\") {\n        step(\"subJob2 - step1\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n        step(\"subJob2 - step2\") {\n            tasklet { _, _ -> RepeatStatus.FINISHED }\n        }\n    }\n}\n\n\nKotlin DSL을 통해 build, JobStepBuilderFactory, StepBuilderFactory 같은 보일러플레이트 코드를 제거하고 Kotlin스럽게 선언형으로 작성했다.\n\n  \n\n오픈 과정\n\n어느 정도 안정화가 된 후 DSL의 경우 Spring Batch에 직접 기여하면 되지 않을까 해서 Issue를 생성해서 Spring Batch Maintainer에게 의견을 물었다. 하지만 Maintainer는 내부 논의 결과 이런 기능은 포함시키지 않기로 이전에 결정했다고 Spring Batch Extension에 등록하라고 답변했다.\n\n\n\n그래서 정산 배치 모듈에 있는 Spring Batch 개선 코드를 정리하여 Spring Batch Extension에 PR을 등록했다.\n\n하지만 1년이 지나도 해당 GitHub 저장소 운영자의 응답이 없었고 결국 별도의 오픈소스 프로젝트로 진행하기로 했다. 이름은 조직 내에서 이미 나온 Spring Jdbc Plus의 이름을 따서 Spring Batch Plus로 지었다. Spring Batch Plus라는 이름답게 Kotlin DSL, ItemStreamReaderProcessorWriter뿐만 아니라 프로젝트 진행 과정에서 사용한 다른 기능도 포함시켰다. 자세한 기능은 공식 문서에서 확인할 수 있다.\n\n  \n\n마치며\n\nSpring Batch Plus가 무엇을 해결하고자 했고 어떤 과정을 통해 세상에 나왔는지 살펴보았다. Spring Batch Plus를 작성함으로써 네이버페이 정산 플랫폼을 신규 시스템으로 전환하는 코드 작성을 보다 깔끔하게 할 수 있었다.\n\nSpring Batch Plus는 연간 52조 규모의 거래액을 다루는 네이버페이 정산의 83개 Job과, 네이버페이 포인트의 29개 Job에 실제 사용된 라이브러리이다. Spring Batch의 Builder를 Kotlin스럽게 작성하고 싶거나 단일 클래스에서 ItemReader, ItemProcessor, ItemWriter를 작성하고 싶다면 Spring Batch Plus 사용을 고려해 볼 수 있다. 이 글 작성 기준으로 Spring Batch Plus는 Spring Batch 4.3.x 버전과 호환되고, 간단히 다음을 참고하여 의존성만 추가하면 사용 가능하다. 자세한 호환 정보는 Compatibility를 참고하길 바란다.\n\nimplementation(\"org.springframework.batch:spring-batch-core:4.3.7\")  \nimplementation(\"com.navercorp.spring:spring-boot-starter-batch-plus-kotlin:0.2.0\")  \n\n\nSpring Batch Plus는 이름에서 알 수 있듯이 Spring Batch에 여러 유용한 기능을 추가한다는 취지의 라이브러리이다. Spring Batch를 사용면서 이런 기능이 있으면 좋겠는데 Spring Batch에 넣기는 애매하다 싶으면 Spring Batch Plus GitHub 저장소에 PR이나 Issue를 등록해주길 바란다.}","href":"https://d2.naver.com/d2.atomSpring Batch를 더 우아하게 사용하기 - Spring Batch Plus"}