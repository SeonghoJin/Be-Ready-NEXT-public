{"company":{"imageUrl":"/companyImages/naver.ico","name":"네이버","href":"https://d2.naver.com/d2.atom","basePath":"https://d2.naver.com","rssUrl":"https://d2.naver.com/d2.atom"},"title":"모던 프론트엔드 프로젝트 구성 기법 - 모노레포 도구 편","createdAt":"2022-05-09T16:32:42Z","description":"<p>이 글에서는 모노레포 개념 편에 이어 Yarn, Lerna, Nx 그리고 Turborepo 도구에 대해 자세히 소개해 드리려고 합니다.</p>\n\n<ol>\n<li><a href=\"#ch1\">Yarn</a>  </li>\n<li><a href=\"#ch2\">Lerna</a>  </li>\n<li><a href=\"#ch3\">Nx</a>  </li>\n<li><a href=\"#ch4\">Turborepo</a></li>\n</ol>\n\n<p><a id=\"ch1\"></a></p>\n\n<h2 id=\"1yarn\">1. Yarn</h2>\n\n<h3 id=\"yarn1x\">Yarn 1.x</h3>\n\n<p><a href=\"https://classic.yarnpkg.com/en/docs/cli/\">https://classic.yarnpkg.com/en/docs/cli/</a></p>\n\n<p><a href=\"https://classic.yarnpkg.com/lang/en/docs/workspaces/\">Yarn(1.x)</a> 또는 <a href=\"https://docs.npmjs.com/cli/v7/using-npm/workspaces\">npm(7.x)</a>의 <a href=\"https://yarnpkg.com/features/workspaces\">workspaces</a> 필드를 사용해 간단히 <a href=\"https://yarnpkg.com/advanced/lexicon#monorepository\">모노레포</a>를 구성할 수 있다. <a href=\"https://classic.yarnpkg.com/en/docs/cli/link\">yarn link</a> 또는 <a href=\"https://docs.npmjs.com/cli/v8/commands/npm-link\">npm link</a> 기능을 선언적으로 사용하는 것으로 node_modules 디렉터리에 workspace에 대한 <strong>심볼릭 링크</strong>가 생성된다. 이를 통해 하나의 저장소에 있는 여러 프로젝트가 서로 쉽게 상호 참조할 수 있다.</p>\n\n<h4 id=\"\">용어</h4>\n\n<ul>\n<li>project\n<ul><li>= 저장소</li>\n<li>하나 이상의 worktree 포함</li>\n<li>최소 한 개의 workspace(즉, 루트 workspace) 존재</li></ul></li>\n<li>workspace\n<ul><li>= 모노레포 패키지</li></ul></li>\n<li>worktree\n<ul><li>자식 workspace를 갖는 workspace</li></ul></li>\n</ul>\n\n<h4 id=\"worktree\">worktree 선언</h4>\n\n<p>worktree를 구성하는 workspace의 위치를 glob 패턴의 배열로 나타낸다. 예를 들어 packages 폴더 내의 모든 폴더가 workspace가 되도록 하려면 다음과 같이 설정한다.</p>\n\n<pre><code class=\"language-json\">{\n    \"private\": true,\n    \"workspaces\": [\"packages/*\"]\n}\n</code></pre>\n\n<blockquote>\n  <p>Yarn 1.x에서는 <code>private: true</code> 필드값이 필수지만 2.x 이상에서는 필수가 아니다.</p>\n</blockquote>\n\n<h4 id=\"workspace\">workspace 추가</h4>\n\n<p>그림과 같이 <code>client</code>, <code>server</code>, <code>common</code> 세 개의 workspace를 추가하고 루트 경로에서 <code>yarn</code> 명령을 실행하면 루트 경로에 <code>node_modules</code> 디렉터리에 workspace들에 대한 <strong>심볼릭 링크</strong>가 생성된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4a463e5fbd.png\" alt=\"\" /></p>\n\n<h4 id=\"workspace\">workspace에 대한 명령 실행</h4>\n\n<p><a href=\"https://classic.yarnpkg.com/en/docs/cli/workspace\">특정 workspace에 정의된 스크립트를 실행</a>한다.</p>\n\n<pre><code>yarn workspace &lt;WORKSPACE_NAME&gt; &lt;COMMAND_NAME&gt;  \n</code></pre>\n\n<h4 id=\"workspace\">workspace를 의존성으로 추가</h4>\n\n<p><code>client</code> 패키지가 <code>common</code> 패키지를 의존하게 하려면 package.json에 의존성을 명시하거나 바로 위에서 설명한 yarn workspace 명령을 이용하면 된다.</p>\n\n<pre><code>yarn workspace client add common@1.0.0  \n</code></pre>\n\n<p>npm 레지스트리에 publish된 <code>common</code>이란 이름의 패키지가 있다 해도, 의존성 버전을 충족한다면 로컬에 존재하는 <code>common</code> workspace를 우선하여 설치한다.</p>\n\n<p><code>client</code>에서 <code>common</code> 의존성을 잘 부르는지 확인하기 위해 다음 명령을 실행해 보면 <code>common</code>의 <code>hello()</code> 함수가 <code>client</code>에서 잘 호출되는 것을 확인할 수 있다.</p>\n\n<pre><code>yarn workspace client run start  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4ac5e45fcc.png\" alt=\"\" /></p>\n\n<h4 id=\"workspace\">workspace 의존 관계 확인</h4>\n\n<p><a href=\"https://classic.yarnpkg.com/en/docs/cli/workspaces\">yarn workspace info</a> 명령을 실행해 workspace들의 의존 관계를 알아볼 수 있다.</p>\n\n<blockquote>\n  <p>Yarn 2.x 이후에는 <a href=\"https://yarnpkg.com/cli/workspaces/list\">yarn workspaces list</a>를 사용한다.</p>\n</blockquote>\n\n<pre><code>yarn workspaces info  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4b386f670d.png\" alt=\"\" /></p>\n\n<h4 id=\"workspace\">모든 workspace에 대해 명령 실행</h4>\n\n<p><a href=\"https://classic.yarnpkg.com/en/docs/cli/workspaces\">yarn workspaces run \\<command\\></a>를 사용하면 모든 workspace에 대해 명령을 실행할 수 있다. 다음 명령은 모든 workspace들을 순회하며 test 스크립트를 실행한다.</p>\n\n<pre><code>yarn workspaces run test  \n</code></pre>\n\n<blockquote>\n  <p>Yarn 2.x 이후에는 <a href=\"https://yarnpkg.com/cli/workspaces/foreach\">yarn workspaces foreach \\<command\\></a>를 사용한다.</p>\n</blockquote>\n\n<h4 id=\"\">루트 프로젝트에 의존성 추가</h4>\n\n<p>workspace가 아니라 루트 프로젝트에 의존성을 추가하려면 다음 명령을 실행한다.</p>\n\n<pre><code>yarn add &lt;PACKAGE_NAME&gt; -W  \n</code></pre>\n\n<h4 id=\"\">호이스팅(의존성 끌어올리기)</h4>\n\n<p>npm, yarn 등은 중복 의존성 설치를 방지하기 위해 <a href=\"https://classic.yarnpkg.com/blog/2018/02/15/nohoist/\">호이스팅(hosting)</a> 기법을 사용한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4cd0ca7890.png\" alt=\"\" /></p>\n\n<p>(그림 출처: <a href=\"https://classic.yarnpkg.com/blog/2018/02/15/nohoist/\">https://classic.yarnpkg.com/blog/2018/02/15/nohoist/</a>)</p>\n\n<p>모노레포에서의 구조는 다음과 같다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4d9bce0677.png\" alt=\"\" /></p>\n\n<p>일부 모듈 로더는 <a href=\"https://github.com/facebook/metro/issues/1\">심볼릭 링크</a>를 지원하지 않기 때문에 B(2.0)을 탐색할 수 없다. 이때는 <a href=\"https://classic.yarnpkg.com/blog/2018/02/15/nohoist/\">nohoist</a> 필드를 사용하면 된다.</p>\n\n<pre><code class=\"language-json\">{\n    \"workspaces\": {\n        \"packages\": [\"packages/*\"],\n        \"nohoist\": [ \"**/react-native\" ]\n    }\n}\n</code></pre>\n\n<p>그 외의 Yarn 1.x에 대한 명령어는 <a href=\"https://classic.yarnpkg.com/en/docs/cli/\">CLI Introduction</a>에서 확인할 수 있다.</p>\n\n<h3 id=\"yarnberry2x3x\">Yarn Berry (2.x, 3.x)</h3>\n\n<p><a href=\"https://yarnpkg.com/cli\">https://yarnpkg.com/cli</a></p>\n\n<p>Yarn workspace를 도입하려고 할 때 성능면에서 Yarn Berry를 함께 검토해 볼 수 있다. Yarn Berry는 yarn의 두 번째 버전으로, 2018년 9월 yarn의 <a href=\"https://github.com/yarnpkg/rfcs\">RFC 저장소</a>에서 시작되었다. Yarn 1.x의 주요 개발자인 Mael Nison에 의해 TypeScript로 개발되었고 2020년 1월 25일 <a href=\"https://dev.to/arcanis/introducing-yarn-2-4eh1\">정식 버전이 출시</a>되었다. Yarn 1.x는 <a href=\"https://github.com/yarnpkg/yarn\">v1.22.17에서 코드 프리징</a>되었고 <a href=\"https://github.com/yarnpkg/berry\">https://github.com/yarnpkg/berry</a> 에서 2022.03.09 현재 v3.2.0이 출시되었다.</p>\n\n<h4 id=\"node_modules\">node_modules의 문제점</h4>\n\n<ul>\n<li><p>의존성 탐색 알고리즘의 비효율</p>\n\n<p>node.js에서 <code>require()</code> 함수를 실행하면 모듈을 찾을 때까지 상위 node_modules 디렉터리를 순회한다. 이때 <a href=\"https://github.com/nodejs/node/blob/24fc302eadf64d2518733a2ae40355916e6990f7/lib/internal/modules/cjs/loader.js#L321-L336\">느린 디스크 I/O 동작</a>이 경로의 깊이만큼 발생한다.</p></li>\n<li><p>저장 공간과 설치 시간</p>\n\n<p>node_modules 디렉터리는 흔히 매우 큰 공간을 필요로 하고, 그만큼 설치에도 오랜 시간이 걸린다.</p></li>\n<li><p>유령 의존성(phantom dependency)</p>\n\n<p>의존성 중복 방지를 위해 호이스팅 기법을 이용하는데 이것은 의도치 않은 side effect을 발생시킨다. 아래 그림에서 <strong>package-1은 B(1.0)을 설치한 적이 없지만 require('B')가 작동한다</strong>. require('B')를 사용하는 경우 B(1.0)을 의존하던 패키지를 제거하면 B를 찾지 못하는 오류가 발생한다.</p></li>\n</ul>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4f08550681.png\" alt=\"\" /></p>\n\n<h4 id=\"yarnberrypnp\">Yarn Berry의 해결 방법 PnP</h4>\n\n<p>어떤 프로젝트를 구성하는 의존성은 결정적(deterministic)이다. Berry는 node_modules에 패키지 파일을 저장하는 대신 패키지의 압축 파일을 <code>.yarn/cache</code> 폴더에 수평적으로 저장하는 방식으로 위 문제를 해결했다. 이 방식을 Yarn은 Plug’n’Play(PnP)라고 부른다. 압축 파일은 ZipFS를 이용하며 해당 모듈 로드가 필요할 때 메모리에서 압축을 해제하여 접근한다.</p>\n\n<h4 id=\"pnp\">PnP로 얻는 것</h4>\n\n<ul>\n<li><p>빠른 의존성 검색</p>\n\n<p>의존성이 <code>.yarn/cache</code>에 수평적으로 존재하므로 모든 패키지에 대한 접근 시간이 O(1)이 된다. 따라서 <code>require()</code>에 소요되는 시간이 크게 단축된다.</p></li>\n<li><p>빠른 설치</p>\n\n<p>압축 파일 단위로 설치되기 때문에 의존성을 구성하는 파일의 수가 절대적으로 감소한다. 여기에 <a href=\"https://yarnpkg.com/features/zero-installs\">zero-install</a> 전략을 사용하면 아예 설치 과정을 생략할 수 있다.</p></li>\n<li><p>유령 의존성 방지</p>\n\n<p>호이스팅을 사용하지 않기 때문에 의도하지 않은 의존성이 발생하지 않는다.</p></li>\n</ul>\n\n<h4 id=\"zeroinstall\">zero-install 전략</h4>\n\n<p><a href=\"https://github.com/yarnpkg/berry/tree/master/.yarn/cache\">https://github.com/yarnpkg/berry/tree/master/.yarn/cache</a></p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4f85570687.png\" alt=\"\" /></p>\n\n<p>하나의 압축 파일로 의존성을 관리하고 이 파일을 git으로 관리하면 설치 과정을 제거할 수 있는데 이와 같은 전략을 zero-install이라 한다. 이 전략의 장점은 다음과 같다.</p>\n\n<ul>\n<li>다른 브랜치에서 새로운 의존성이 설치되었을 때 설치 과정 없이 바로 사용할 수 있다.</li>\n<li>CI에서 의존성 설치에 드는 시간을 크게 줄일 수 있다.</li>\n</ul>\n\n<h4 id=\"\">오프라인 캐시</h4>\n\n<p>네트워크가 다운되었을 때에도 Yarn이 제대로 작동하도록 하는 기능이다. 자세한 기능은 <a href=\"https://yarnpkg.com/features/offline-cache\">Offline Cache</a>를 참고한다.</p>\n\n<h4 id=\"\">사용 방법</h4>\n\n<p>간단히 사용 방법을 살펴보자.</p>\n\n<pre><code>$ npm install -g yarn\n$ cd ../path/to/your-package\n$ yarn init -y\n$ yarn set version berry\n</code></pre>\n\n<p>아래와 같은 초기 파일이 생성된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4ff99a07dd.png\" alt=\"\" /></p>\n\n<p><strong>해당 디렉터리에서 Yarn 버전을 살펴보면</strong> 1.x가 아닌 것을 확인할 수 있다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa503aca09ad.png\" alt=\"\" /></p>\n\n<p>의존성을 추가하면 <code>.yarn/cache</code> 경로에 추가된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5088b009b5.png\" alt=\"\" /></p>\n\n<h4 id=\"pnpcjs\">.pnp.cjs</h4>\n\n<p><code>.pnp.cjs</code> 파일에는 모든 의존성에 대한 메타 정보(zip 경로, 의존성)와 함께 ZipFS에 대한 처리 코드가 들어있다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa56ebc6393d.png\" alt=\"\" /></p>\n\n<p>따라서 Berry 기반의 프로젝트는 <code>node src/main.js</code>와 같은 명령으로는 실행할 수 없고 <code>yarn node src/main.js</code>와 같이 Yarn을 통해서 실행해야 한다.</p>\n\n<pre><code class=\"language-json\">{\n    \"scripts\": {\n        \"start\": \"node src/main.js\"\n    }\n}\n</code></pre>\n\n<p>위와 같이 package.json에 스크립트 명령을 작성한 경우에는 <code>yarn start</code> 명령을 사용할 수 있다.</p>\n\n<p><a id=\"ch2\"></a></p>\n\n<h2 id=\"2lerna\">2. Lerna</h2>\n\n<p><a href=\"https://lerna.js.org/\">https://lerna.js.org/</a></p>\n\n<p>Lerna는 <a href=\"https://www.npmjs.com/package/lerna/v/1.0.1\">Babel 개발자</a>에 의해 개발되어 2015년부터 <a href=\"https://lerna.js.org/#users\">다수의 프로젝트</a>에서 모노레포 관리 도구로 사용되어 왔다. 2022년 5월 현재 Nx의 개발사인 <a href=\"https://nrwl.io/\">Nrwl</a>이 <a href=\"https://github.com/lerna/lerna/issues/3121\">프로젝트 관리 권한을 인수</a>했다.</p>\n\n<p>Lerna는 저수준의 Yarn, npm 위에 있는 고수준 레이어로 볼 수 있다. Yarn으로 모노레포를 구성할 수는 있지만 여러 workspace의 버전 관리, 테스트, 빌드, 배포, 게시 등의 작업은 일일이 구성해야 한다. Lerna는 이러한 작업을 최적화한다.</p>\n\n<h3 id=\"lerna\">Lerna 기반 프로젝트 생성</h3>\n\n<p>CLI를 쉽게 사용하기 위해 글로벌로 설치한다.</p>\n\n<pre><code>npm install --global lerna  \n</code></pre>\n\n<p>프로젝트를 Lerna로 초기화한다.</p>\n\n<pre><code>cd path/to/your-project  \nlerna init  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5745f246a6.png\" alt=\"\" /></p>\n\n<p>다음과 같이 초기 디렉터리가 구성된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa57954a46ac.png\" alt=\"\" /></p>\n\n<h3 id=\"lernajson\">lerna.json</h3>\n\n<ul>\n<li><code>version</code>: 각 workspace에 대한 버전을 관리할 수 있다. 개별로 관리하고자 할 때는 \"independent\"를 입력한다.</li>\n<li><code>npmClient</code>: \"npm\" 또는 \"yarn\"</li>\n<li><code>useWorkspaces</code>: npmClient의 workspace로 관리되도록 한다.</li>\n</ul>\n\n<h3 id=\"workspace\">workspace 추가</h3>\n\n<p>다음 명령을 실행해 새로운 workspace를 스캐폴딩할 수 있다.</p>\n\n<pre><code>lerna create &lt;PACKAGE-NAME&gt;  \n</code></pre>\n\n<p>다음과 같이 <code>client</code> workspace를 생성할 수 있다.</p>\n\n<pre><code>lerna create client  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa587ca8631f.png\" alt=\"\" /></p>\n\n<h3 id=\"workspace\">workspace에 의존성 추가</h3>\n\n<p>아래와 같이 <code>client</code> workspace에 react 패키지를 설치할 수 있다. <code>--scope</code> 없이 사용하면 모든 workspace에 추가한다. 추가하려는 의존성이 workspace라면 해당 workspace를 제외한 모든 workspace에 추가된다.</p>\n\n<blockquote>\n  <p>현재 <a href=\"https://github.com/lerna/lerna/issues/2004\">여러 의존성을 한번에 추가</a>하는 기능은 지원되지 않는다.</p>\n</blockquote>\n\n<p><code>client</code> workspace에 react 패키지를 추가한다.</p>\n\n<pre><code>lerna add react --scope=client  \n</code></pre>\n\n<p><code>client</code> workspace에 <code>common</code> workspace를 추가한다.</p>\n\n<pre><code>lerna add common@0.0.0 --scope=client  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa58f1f3035c.png\" alt=\"\" /></p>\n\n<h3 id=\"\">루트 프로젝트에 의존성 추가</h3>\n\n<p>아래와 같이 lodash를 루트 프로젝트에 설치할 수 있다.</p>\n\n<pre><code>yarn add lodash --ignore-workspace-root-check  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5951d30362.png\" alt=\"\" /></p>\n\n<h3 id=\"workspacenpm\">모든 workspace에 대해 npm 스크립트 실행</h3>\n\n<p>해당 스크립트가 포함된 각 workspace에서 npm 스크립트를 실행한다.</p>\n\n<pre><code>lerna run &lt;COMMAND_NAME&gt; -- [..args]  \n</code></pre>\n\n<p>다음은 모든 workspace에 대해 test를 실행한다.</p>\n\n<pre><code>lerna run test  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa59fc4d0468.png\" alt=\"\" /></p>\n\n<h3 id=\"workspace\">모든 workspace에 대해 임의 명령 실행</h3>\n\n<pre><code>lerna exec -- &lt;COMMAND&gt; [..args]  \n</code></pre>\n\n<p>다음은 모든 workspace 하위의 node_modules 폴더를 지운다.</p>\n\n<pre><code>lerna exec -- rm -rf ./node_modules  \n</code></pre>\n\n<h3 id=\"npmpublish\">npm publish</h3>\n\n<p>자세한 옵션은 <a href=\"https://github.com/lerna/lerna/tree/main/commands/publish#readme\">공식 문서</a>를 참고한다.</p>\n\n<pre><code>lerna publish               ## 마지막 릴리스 이후 변경된 패키지 publish  \nlerna publish from-git      ## 현재 커밋에 태그가 지정된 패키지를 명시적으로 publish  \nlerna publish from-package  ## 레지스트리에 최신 버전이 없는 패키지를 명시적으로 publish  \n</code></pre>\n\n<h3 id=\"changelog\">버전 관리 및 CHANGELOG 작성 자동화</h3>\n\n<p>workspace에 변경을 가하고 나서 <code>lerna version</code>을 실행하면 각 workspace의 package.json에 명시된 버전을 자동으로 올리고 git에 tag를 남기고 변경에 대한 CHANGELOG도 작성한다.</p>\n\n<blockquote>\n  <p>더 많은 기능은 <a href=\"https://github.com/lerna/lerna-changelog\">lerna-changelog</a>를 참고한다.</p>\n</blockquote>\n\n<pre><code>lerna version  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5a75592126.png\" alt=\"\" />\n<img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5ab28d2276.png\" alt=\"\" />\n<img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5ae6982381.png\" alt=\"\" /></p>\n\n<p><code>changelogPreset</code> 필드를 이용하면 <code>git commit message</code>를 이용해 CHANGELOG를 자동으로 생성할 수 있다. 예시에서는 <a href=\"https://www.npmjs.com/package/conventional-changelog-conventionalcommits\">conventional-changelog-conventionalcommits</a> 프리셋을 이용했다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5b7e6d2423.png\" alt=\"\" /></p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5bb8b2245b-4.png\" alt=\"\" /></p>\n\n<h3 id=\"lerna\">Lerna 명령어</h3>\n\n<p>그 외에도 변경 사항을 알아내거나 workspace 목록을 얻거나 lerna, npmClient, OS 등의 환경을 알아내는 등\n다양한 기능을 제공한다. Lerna의 자세한 명령어는 다음을 참고한다.</p>\n\n<ul>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/publish#readme\"><code>lerna publish</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/version#readme\"><code>lerna version</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/bootstrap#readme\"><code>lerna bootstrap</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/list#readme\"><code>lerna list</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/changed#readme\"><code>lerna changed</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/diff#readme\"><code>lerna diff</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/exec#readme\"><code>lerna exec</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/run#readme\"><code>lerna run</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/init#readme\"><code>lerna init</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/add#readme\"><code>lerna add</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/clean#readme\"><code>lerna clean</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/import#readme\"><code>lerna import</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/link#readme\"><code>lerna link</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/create#readme\"><code>lerna create</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/info#readme\"><code>lerna info</code></a></li>\n</ul>\n\n<p><a id=\"ch3\"></a></p>\n\n<h2 id=\"3nx\">3. Nx</h2>\n\n<p>다음은 구글 개발자들이 만든 오픈소스 프로젝트인 <a href=\"https://nx.dev/\">Nx</a>이다. Nx는 모노레포 구성을 위한 다양한 개발 도구를 제공하고 Angular, React와 같은 프런트엔드 프레임워크 기반의 개발 환경 구성뿐 아니라 Express, <a href=\"https://nestjs.com/\">Nest.js</a>와 같은 백엔드 기술 기반의 개발까지 폭넓게 지원하고 있다. 이뿐만 아니라 workspace 생성 시 Cypress, Jest 등을 기반으로 한 테스트 환경까지 설정해주기 때문에, 초기 모노레포 개발 환경 구축 비용을 크게 줄여준다.</p>\n\n<p>그럼 Nx를 사용해서 간단하게 모노레포를 구성해 보고, 그 특징을 몇 가지 살펴보겠다.</p>\n\n<h3 id=\"nxworkspace\">새로운 Nx workspace 생성하기</h3>\n\n<p>아래의 명령을 입력해 새로운 Nx workspace 생성을 시작할 수 있다.</p>\n\n<pre><code>npx create-nx-workspace  \n</code></pre>\n\n<p>Nx는 workspace 생성을 완료하기 위해, 다음과 같이 추가로 몇 가지 항목을 입력하도록 요구한다.</p>\n\n<blockquote>\n  <p>Nx Cloud의 경우 필수는 아니다.</p>\n</blockquote>\n\n<pre><code>Workspace name (e.g., org name)     My-Workspace  \nWhat to create in the new workspace angular  \nApplication name                    my-app  \nDefault stylesheet format           CSS  \nUse Nx Cloud?                       No  \n</code></pre>\n\n<p>이 항목을 입력하고 나면 다음과 같은 구조의 Nx workspace가 생성된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5c2cd82663.png\" alt=\"\" /></p>\n\n<p>생성된 workspace 구조에서 이를 구성하는 디렉터리의 특징을 간단히 알아보겠다.</p>\n\n<ul>\n<li><code>apps/*</code>: 애플리케이션 프로젝트들이 위치한다. 우리가 처음에 생성한 애플리케이션도 여기에 들어있는 것을 볼 수 있다. Angular 기반으로 workspace를 생성했어도 꼭 Angular 프로젝트만 이 디렉터리에 들어갈 필요는 없으며 React 등 다른 프레임워크 기반의 코드도 공존할 수 있다.</li>\n<li><code>libs/*</code>: 애플리케이션 전반에서 공통으로 사용할 코드를 여기에 작성한다.</li>\n<li><code>tools/*</code>: 개발에 필요한 tooling script가 위치한다.</li>\n</ul>\n\n<p>이제 생성한 애플리케이션을 실행해 보겠다. 애플리케이션은 다음과 같은 명령으로 실행할 수 있다.</p>\n\n<pre><code>npx nx serve &lt;APP_NAME&gt; // 주의: workspace 이름이 아닌 애플리케이션 이름  \n</code></pre>\n\n<p>만약 전역(global)에 Nx가 설치되어 있다면 다음과 같은 명령으로 애플리케이션을 실행할 수도 있다.</p>\n\n<pre><code>nx serve &lt;APP_NAME&gt;  \n</code></pre>\n\n<blockquote>\n  <p>전역에 Nx 설치하기: <code>npm install -g nx</code> 또는 <code>yarn global add nx</code></p>\n</blockquote>\n\n<p>위의 명령 실행이 완료되었다면, <code>localhost:4200</code>에 접속해서 애플리케이션을 확인해 볼 수 있다.</p>\n\n<h4 id=\"nxclivsangularcli\">Nx CLI vs Angular CLI</h4>\n\n<p>Angular 프로젝트 개발 경험이 있다면 Angular CLI(aka. ng)에 익숙할 것이다. 실제로, Angular 기반의 Nx workspace를 생성한 경우 대부분의 Nx 명령어는 <code>ng ...</code> 로 대체가 가능하고(예: <code>ng serve</code>) 그 결과 또한 동일하다.</p>\n\n<p>하지만 Nx에서는 Nx CLI 사용을 권장한다. 그 이유는 Nx가 Nx CLI를 통해 제공하는 몇몇 기능이 있기 때문이다. 그 기능 중 하나인 Computation Cache에 대해선 나중에 살펴보겠다.</p>\n\n<blockquote>\n  <p>\"Use Nx CLI over Angular CLI\" - Nx.dev -</p>\n</blockquote>\n\n<h3 id=\"\">라이브러리 추가해보기</h3>\n\n<p>이번엔 애플리케이션 전반에서 사용할 수 있는 <a href=\"https://nx.dev/angular/library\">라이브러리</a>를 추가해보겠다.</p>\n\n<p>라이브러리는 목적과 특성에 따라 다음과 같이 네 가지로 나눌 수 있다.</p>\n\n<ul>\n<li>feature 라이브러리</li>\n<li>UI 라이브러리</li>\n<li>data-access 라이브러리</li>\n<li>utility 라이브러리</li>\n</ul>\n\n<p>여기서는 간단하게 UI 라이브러리를 추가해 보겠다.</p>\n\n<pre><code>npx nx g @nrwl/angular:lib ui // ui: 라이브러리 이름  \n</code></pre>\n\n<pre><code>npx nx g @nrwl/react:lib ui // React의 경우  \n</code></pre>\n\n<p>위 명령으로 <code>ui</code>라는 이름의 Angular 컴포넌트가 라이브러리에 추가되어 다음과 같은 구조가 만들어진다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5cc8762692.png\" alt=\"\" /></p>\n\n<p>이제 생성된 UI 라이브러리 구조에 실제 View 역할을 할 컴포넌트를 추가하겠다.</p>\n\n<pre><code>npx nx g component first-lib --project=ui --export  \n</code></pre>\n\n<p>다음 그림과 같이 <code>ui</code> 라이브러리 아래에 우리가 선언한 <code>first-lib</code> 컴포넌트 파일이 추가되었다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5e669b2c95.png\" alt=\"\" /></p>\n\n<h3 id=\"ui\">생성한 UI 라이브러리 사용해보기</h3>\n\n<p>그럼 이제 라이브러리를 애플리케이션에서 사용하는 방법을 알아보겠다.</p>\n\n<h4 id=\"1uiappmoduleimport\">1. UI 모듈을 AppModule에 import하기</h4>\n\n<pre><code class=\"language-js\">// in AppModule\n...\n\nimport { UiModule } from '@my-workspace/ui'; // Import UiModule\n\n...\n\n@NgModule({\n  ...\n\n  imports: [BrowserModule, UiModule], // Add UiModule in the importing list\n\n  ...\n})\nexport class AppModule {}  \n</code></pre>\n\n<p>이때 라이브러리를 import하는 구문은 다음과 같다.</p>\n\n<pre><code>import &lt;UI_MODULE_NAME&gt; from @&lt;WORKSPACE_NAME&gt;/&lt;LIBRARY_NAME&gt;  \n</code></pre>\n\n<p>Nx는 라이브러리가 추가될 때마다 <code>tsconfig.base.json</code> 파일에 TS 경로를 매핑하기 때문에 위와 같이 참조할 수 있다.</p>\n\n<h4 id=\"2applicationtemplateui\">2. Application Template에서 UI 라이브러리 컴포넌트 사용하기</h4>\n\n<p>1번에서 모듈을 import했다면, 생성한 라이브러리의 컴포넌트를 Application Template에서 다음과 같이 사용할 수 있다.</p>\n\n<pre><code class=\"language-html\">&lt;!-- in Application Template --&gt;  \n&lt;my-workspace-first-lib&gt;&lt;/my-workspace-first-lib&gt;  \n</code></pre>\n\n<h4 id=\"\">라이브러리 생성 및 사용 시 주의할 점</h4>\n\n<p>에디터로 Visual Studio Code(이하 VS Code)를 사용하는 경우, 라이브러리를 생성 및 참조할 때 컴파일 오류가 발생하는 경우가 있다. 이는 VS Code의 TS 서버가 새로운 라이브러리를 바로 인식하는 데 실패하는 경우로, 이때는 VS Code를 재시작하는 것을 권장한다. 또한 새로운 라이브러리를 추가할 때마다 Nx 서버를 재시작해야 한다는 점을 주의한다.</p>\n\n<h3 id=\"nx\">Nx가 제공하는 도구</h3>\n\n<p>지금까지 Nx workspace의 생성, 라이브러리 추가와 사용에 대해서 간단히 알아보았다. 이어서 Nx가 제공하는 몇 가지 기능을 소개하겠다.</p>\n\n<h4 id=\"1projectgraph\">1. Project Graph</h4>\n\n<p>첫 번째는 Project Graph이다. 대부분의 프로젝트는 성장하면서 수많은 애플리케이션과 라이브러리가 생겨나고 점차 그 구성 요소 간의 의존 관계가 복잡해져 개발자 입장에서는 그 의존 관계를 파악하기가 점점 어려워진다. Nx는 이를 시각화하여 프로젝트 구성 요소 간의 관계를 파악하기 쉽도록 하는 Project Graph를 제공한다.</p>\n\n<pre><code>npx nx graph  \n</code></pre>\n\n<p>위의 명령을 실행하여 현재 workspace의 전체 Project Graph를 확인할 수 있고, Nx가 제공하는 인터페이스를 통해 다양한 필터링도 가능하다. 아래는 위에서 진행한 예시 workspace의 Project Graph이다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa60537a3c8e.png\" alt=\"\" /></p>\n\n<h4 id=\"2computationcaching\">2. Computation Caching</h4>\n\n<p>Nx는 Nx CLI를 통해 내부적으로 Computation Caching을 제공한다. 이를 확인해보기 위해 <code>nx build [appName]</code> 명령을 실행해 보겠다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa609e2d3c9c.png\" alt=\"\" /></p>\n\n<p>빌드가 완료된 후, 위와 동일한 명령을 한 번 더 실행해 보았다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa60f1c13ca6.png\" alt=\"\" /></p>\n\n<p>이번에는 빌드가 바로 완료됨(21ms)을 볼 수 있고, 맨 아래 텍스트에서 볼 수 있는 것처럼 Nx는 로컬 캐시에\n해당 Artifact가 존재하는 경우 가져다 쓰는 걸 알 수 있다. 단, 캐싱은 Nx CLI에서만 동작하기 때문에, Angular CLI를 사용하는 경우엔 Computation Caching이 적용되지 않는다.</p>\n\n<blockquote>\n  <p><a href=\"https://nx.dev/using-nx/caching\">Computation Caching 더 알아보기</a></p>\n</blockquote>\n\n<h4 id=\"3affected\">3. Affected</h4>\n\n<p>다음은 Affected 스크립트이다.</p>\n\n<pre><code>npx nx affected  \n</code></pre>\n\n<p>Nx는 코드를 수정했을 때 workspace의 어떤 부분이 영향을 받는지 알려주는 명령을 제공한다. Affected 스크립트는 필요에 따라 다음과 같이 다양하게 사용할 수 있다.</p>\n\n<ul>\n<li><code>npx nx affected:apps</code>: 수정한 부분이 어떤 애플리케이션에 영향을 주었는지 표시한다.</li>\n<li><code>npx nx affected:libs</code>: 수정한 부분이 어떤 라이브러리에 영향을 주었는지 표시한다.</li>\n<li><code>npx nx affected:test</code>: 코드 수정에 의해 영향을 받은 부분에 대해서만 테스트를 실행한다.</li>\n</ul>\n\n<p>다음은 UI 라이브러리를 수정한 뒤 위 명령을 실행한 모습이다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa614fa13cf6.png\" alt=\"\" /></p>\n\n<h4 id=\"4vscodenxconsole\">4. VS Code용 Nx Console</h4>\n\n<p>마지막으로 Nx Console이다. Nx Console은 VS Code에서 Nx를 쉽게 사용하기 위한 GUI 도구다. Nx Command로 하는 모든 작업을 Nx Console로도 할 수 있도록 구성되어 있다. VS Code를 사용 중이라면 Nx Console을 사용하는 것을 추천한다.</p>\n\n<blockquote>\n  <p><a href=\"https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console\">VS Code에 Nx Console 설치하기</a></p>\n</blockquote>\n\n<p>다음은 VS Code에 Nx Console을 설치한 모습이다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa61bac843a8.png\" alt=\"image-20220321-115005-809.png\" /></p>\n\n<p><a id=\"ch4\"></a></p>\n\n<h2 id=\"4turborepo\">4. Turborepo</h2>\n\n<p>Turborepo는 대규모 모노레포 프로젝트 관리에서 오는 피로감과 부수적인 툴링에 대한 부담을 줄이면서, Google이나 Facebook과 같은 큰 기업에서 사용하는 수준의 개발 경험을 주는 데 포커싱한, Vercel에서(<a href=\"https://vercel.com/blog/vercel-acquires-turborepo\">2021년 12월에 인수</a>) 개발 및 운영하고 있는 JavaScript/TypeScript를 위한 모노레포 빌드 시스템이다.</p>\n\n<p>Turborepo는 증분 빌드(incremental build), 원격 캐싱, 병렬 처리 기법을 통해 빌드 성능을 끌어올리고, <code>Pipeline</code>의 쉬운 설정과 profiling, trace 등 다양한 시각화 기능을 제공해 관리 편의성을 높인 것이 특징이다.</p>\n\n<p>그리고 기존의 모노레포 프로젝트에 점진적으로 Turborepo를 적용할 수 있으며, 쉽게 Turborepo로 구성된 새 모노레포 프로젝트를 생성할 수 있도록 스캐폴딩 기능을 제공한다. 또한 패키지 매니저로 <code>yarn</code>, <code>npm</code>, <code>pnpm</code>와 함께 잘 동작하므로 프로젝트 상황에 맞게 선택해 사용할 수 있다.</p>\n\n<p>Turborepo가 어떻게 구성되어 있는지 먼저 살펴보고, 앞서 언급한 특징을 설명하면서, 어떻게 사용하는지 설명하겠다.</p>\n\n<h3 id=\"createturbo\">create-turbo 구성 확인하기</h3>\n\n<p>아래의 명령어를 통해 새 모노레포 프로젝트를 생성해 보자.</p>\n\n<pre><code>$ npx create-turbo@latest &lt;PACKAGE_NAME&gt;\n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa6222a443d1.png\" alt=\"\" /></p>\n\n<p>위 그림과 같이 <code>/app</code> 하위에 <code>docs</code>, <code>web</code> 앱과 공통 패키지인 <code>/packages</code> 하위의 <code>ui</code>, <code>config</code> 패키지가 있는 프로젝트가 생성된다. 이 구조는 일반적인 모노레포 프로젝트 구조와 유사해 쉽게 Turborepo를 사용할 수 있도록 한다.</p>\n\n<p>Vercel사에서 운영하는 프로젝트답게 앱은 기본적으로 <code>Next.js(react)</code>로 설정된다. 그외에 <code>Express</code>, <code>Remix</code>, <code>pnpm</code> 등 다양한 기술 스택으로 이루어진 <a href=\"https://github.com/vercel/turborepo/tree/main/examples\">예시</a>도 제공하고 있으므로 필요에 따라 참고할 수 있다.</p>\n\n<h3 id=\"\">캐싱</h3>\n\n<p>이미 계산한 것들은 다시는 계산하지 않는다는 핵심 컨셉 아래 캐싱이 이루어지고 있다. 이전에 실행한 파일 및 로그를 캐싱해, 만약 현재 실행 태스크에 이미 완료한 작업이 있다면 이것을 건너뛰기 때문에 작업 실행 시간을 효과적으로 줄일 수 있다.</p>\n\n<p>앞서 만든 프로젝트에서 빌드를 진행해 보자.</p>\n\n<pre><code class=\"language-sh\">$ yarn turbo run build\n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa628ae343e6.png\" alt=\"\" /></p>\n\n<p>그 다음 위 명령어로 다시 빌드를 하면 다음과 같이 시간이 대폭 줄어든 것을 확인할 수 있다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa62cccd43f2.png\" alt=\"\" /></p>\n\n<p>그렇다면 이 캐시들은 어떻게 저장되고 있을까?</p>\n\n<p>빌드를 하면 <code>/app</code> 하위 패키지들의 <code>.turbo</code> 디렉터리에 각각 로그 파일이 생기고 이 로그에는 해당 빌드에 대한 hash가 저장된다.(Turborepo는 빌드해야 할 항목을 파악하기 위해 타임스탬프를 확인하고 활용하는 대신 파일의 내용에 따른 hash 정책을 사용한다.) 이 hash 값들은 아래 이미지와 같이 <code>node_modules/.cache/turbo</code> 하위에 hash로 구분된 스냅샷 폴더와 매칭된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa633331443c.png\" alt=\"\" />\n<img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa6373234447.png\" alt=\"\" /></p>\n\n<p>이렇게 모든 작업에 대한 캐싱을 진행하기 때문에 변화된 부분만 재빌드하고 나머지는 캐싱한 것을 사용하면서 Turborepo는 작업 속도를 높일 수 있다.</p>\n\n<h3 id=\"\">원격 캐싱</h3>\n\n<p>위에서 설명한 캐시는 로컬 환경에서만 유효하다는 한계가 있다. 그러나 Turborepo는 이 한계를 극복하는 <strong>원격 캐싱</strong>이라는 강력한 기능을 제공한다.</p>\n\n<p>더 빠른 빌드를 위해 빌드 캐시를 클라우드에 올려서 팀원 및 CI/CD시스템이 공유해 사용할 수 있어 대규모 프로젝트에서 다수의 팀이 협업하는 환경에서 개발 효율성을 높일 수 있다.</p>\n\n<p>실제로 원격 캐싱을 한 상태에서 빌드를 실행하면 \"Remote computation caching enable\" 문구와 함께 빌드 시간이 9초에서 3초로 비약적으로 감소하는 것을 확인해볼 수 있다.</p>\n\n<ul>\n<li>로컬 캐시가 없는 상태에서의 빌드 시간</li>\n</ul>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa63c2224451.png\" alt=\"\" /></p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa6401b8448b.png\" alt=\"\" /></p>\n\n<ul>\n<li>로컬 캐시는 없고 원격 캐시가 있는 상태에서의 빌드 시간</li>\n</ul>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa6442a6449a.png\" alt=\"\" /></p>\n\n<p>다만 이 기능은 현재 experimental(beta) 상태이며 Vercel 클라우드를 활용하기 때문에 Vercel의 계정이 필요하다.</p>\n\n<blockquote>\n  <p><a href=\"https://turborepo.org/docs/features/remote-caching\">공식 문서</a>를 참고해 원격 캐싱 방법을 참고해 볼 수 있다.</p>\n</blockquote>\n\n<h3 id=\"pipelinepackagetask\">Pipeline Package Task</h3>\n\n<p>Pipeline은 각 패키지의 package.json 스크립트(태스크) 간 작업 관계를 정의한다. 이를 통해 새로 들어온 개발자도 작업 관계를 쉽게 이해할 수 있다.</p>\n\n<p>Pipeline 설정은 Turborepo turbo.json에서 확인할 수 있다.(package.json에도 설정 가능하나 turbo.json에 설정하도록 권장하고 있다.)</p>\n\n<pre><code class=\"language-json\">{\n  \"$schema\": \"https://turborepo.org/schema.json\",\n  \"pipeline\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"^build\"]\n    },\n    \"deploy\": {\n      \"dependsOn\": [\"build\", \"test\", \"lint\"]\n    },\n    \"lint\": {}\n  }\n}\n</code></pre>\n\n<p>위 설정에서 <code>dependOn</code>은 <code>pipeline</code> key에 해당하는 작업이 의존하는 작업을 의미한다. 이 부분에 접두사 <code>^</code>가 붙으면 각 패키지에 있는 작업을 의미한다.</p>\n\n<p><code>lint</code>는 의존 관계와 상관없이 언제나 수행될 수 있으며, <code>deploy</code>는 Pipeline에서 <code>build</code>, <code>test</code>, <code>lint</code>가 선행되어야 수행됨을 의미한다.</p>\n\n<p>Pipeline으로 인해 Turborepo의 스케줄러는 기존의 모노레포에 비해 성능이 강력하다. 한 번에 한 테스크씩 수행되는 기존 방식과 다르게 의존성이 없는 작업은 유휴 CPU에서 실행되기 때문에 빌드 시간이 긴 경우에 작업 성능이 비약적으로 높아진다.</p>\n\n<p>다음 그림을 살펴보자.</p>\n\n<p><img src=\"/content/images/2022/04/227eaf62-bf35-4e48-a45a-aede9108a23f.png\" alt=\"\" /></p>\n\n<p>A, B, C 세 개의 패키지로 구성된 프로젝트가 있다. A와 C는 B에 의존한다.</p>\n\n<p><code>lint</code>, <code>build</code>, <code>test</code>, <code>deploy</code> 작업을 순차적으로 수행한다고 했을 때 Lerna의 경우에 A, C 패키지는 B의 <code>build</code>가 끝날 때까지 <code>build</code>를 수행할 수 없다.</p>\n\n<p>이에 반해 Turborepo는 <code>build</code>에 의존 관계가 없는 <code>test</code> 작업이 병렬적으로 수행된다.</p>\n\n<h3 id=\"profile\">Profile</h3>\n\n<p>위에서 언급한 멀티 스레드를 활용한 병렬 작업 처리가 실제로 어떻게 CPU 스레드를 사용해서 작업을 처리하는지 <code>--profile</code> 플래그를 통해 시각화해 확인할 수 있다.</p>\n\n<pre><code class=\"language- sh\">## 이미 작업을 진행한 경우 더 명확한 profiling을 위해 --force 플래그를 추가한다.\n$ yarn turbo run build lint --profile [--force]\n</code></pre>\n\n<p>위 명령을 실행하면 루트 디렉터리에 <code>****-profile.json</code> 파일이 생성된다. 이 파일을 Chrome 개발자 도구의 Performance 탭에 업로드해 스레드에서 작업이 어떤 순서로 얼마만큼의 시간이 걸리는지 확인할 수 있다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa64a13144a5-1.png\" alt=\"\" /></p>\n\n<p>이 밖에도 <code>--trace</code>,  <code>--heap</code>, <code>--cpuprofile</code> 등의 플래그를 사용해 다양한 부분에서 profiling이 가능하다. 자세한 사용 방법은 <a href=\"https://turborepo.org/docs/reference/command-line-reference#--trace\">공식 문서</a>에서 확인할 수 있다.</p>\n\n<h3 id=\"\">의존성 그래프 시각화</h3>\n\n<p>Nx와 마찬가지로 Turborepo도 프로젝트 내 패키지 간 작업 관계를 쉽게 파악할 수 있게 시각화하는 기능을 제공한다. 기본적으로 JPEG 형식의 이미지로 그래프가 그려지며 SVG, HTML, JSON, PDF 등 다양한 형식의 산출물을 지원한다.</p>\n\n<p>먼저 <a href=\"https://graphviz.org/download/\">graphviz</a>가 설치되어 있어야 한다.</p>\n\n<pre><code>$ turbo run build --graph\n$ turbo run build test lint --graph=my-graph.html\n</code></pre>\n\n<p>다음은 위 명령어를 각각 실행해 얻은, 패키지 간 작업 관계를 시각화한 이미지다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa650f84469d.png\" alt=\"\" /></p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa65565d46b5.png\" alt=\"\" /></p>\n\n<p>이 밖에도 CPU trace, heap trace, CPU profile에 대한 시각화 기능도 제공한다. 자세한 내용은 <a href=\"https://turborepo.org/docs/reference/command-line-reference#--trace\">CLI Reference</a>를 참고한다.</p>\n\n<h2 id=\"5\">5. 마치며</h2>\n\n<p>위에 소개한 Yarn, Lerna, Nx 그리고 Turborepo를 간단히 비교하면 다음 표와 같다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa65aea54d30.png\" alt=\"\" /></p>\n\n<p>표에서 보이는 것처럼 Yarn은 다른 모노레포 도구에 비해 지원하는 것들이 많지는 않지만, 모노레포 사용의 목적이 <strong>단순히 공통 요소를 공유</strong>하는 것이라면 Yarn으로 workspace을 구성해서 개발을 진행하는 것을 추천한다.</p>\n\n<p>하지만 단순한 코드의 공유 외에 <strong>패키지 간 의존성 관리 및 테스트, 배포</strong> 등의 작업에 대한 더 나은 무언가를 필요로 한다면 Lerna를 함께 사용해보는 것도 좋은 선택지가 될 것이다.</p>\n\n<p>그리고 프로젝트가 성장하면서 개발, 관리에 유용한 더 많은 기능이 필요하다면 Nx와 Turborepo를 고려해보면 좋을 것 같다. Nx와 Turborepo는 모두 <strong>캐싱</strong> 기능을 지원해서 빌드 측면에서 우수한 속도를 자랑하고, <strong>의존성 그래프 시각화</strong> 기능을 통해 프로젝트의 구성 요소들이 서로 어떤 의존관계를 갖고있는 지 한눈에 파악이 가능하도록 해준다.</p>\n\n<p>둘 중 좀더 가벼운 시작을 원한다면, <strong>Zero Config</strong>를 지향해 초기 설정이 상대적으로 쉬운 Turborepo를 시도하는 것도 좋을 것이다. 상대적으로 출시된 지 오래되어 관련 레퍼런스, 지원하는 IDE 플러그인 등의 <strong>풍부한 생태계</strong>가 형성되어 있는 Nx 또한 좋은 선택지가 될 수 있다.</p>\n\n<p>위의 네 가지 도구 모두 상황에 따라 좋은 선택지가 될 수 있으니, 현재 프로젝트 상황에 맞는 좋은 도구를 선택하여 즐겁게 개발하길 바란다.</p>","rawText":"<p>이 글에서는 모노레포 개념 편에 이어 Yarn, Lerna, Nx 그리고 Turborepo 도구에 대해 자세히 소개해 드리려고 합니다.</p>\n\n<ol>\n<li><a href=\"#ch1\">Yarn</a>  </li>\n<li><a href=\"#ch2\">Lerna</a>  </li>\n<li><a href=\"#ch3\">Nx</a>  </li>\n<li><a href=\"#ch4\">Turborepo</a></li>\n</ol>\n\n<p><a id=\"ch1\"></a></p>\n\n<h2 id=\"1yarn\">1. Yarn</h2>\n\n<h3 id=\"yarn1x\">Yarn 1.x</h3>\n\n<p><a href=\"https://classic.yarnpkg.com/en/docs/cli/\">https://classic.yarnpkg.com/en/docs/cli/</a></p>\n\n<p><a href=\"https://classic.yarnpkg.com/lang/en/docs/workspaces/\">Yarn(1.x)</a> 또는 <a href=\"https://docs.npmjs.com/cli/v7/using-npm/workspaces\">npm(7.x)</a>의 <a href=\"https://yarnpkg.com/features/workspaces\">workspaces</a> 필드를 사용해 간단히 <a href=\"https://yarnpkg.com/advanced/lexicon#monorepository\">모노레포</a>를 구성할 수 있다. <a href=\"https://classic.yarnpkg.com/en/docs/cli/link\">yarn link</a> 또는 <a href=\"https://docs.npmjs.com/cli/v8/commands/npm-link\">npm link</a> 기능을 선언적으로 사용하는 것으로 node_modules 디렉터리에 workspace에 대한 <strong>심볼릭 링크</strong>가 생성된다. 이를 통해 하나의 저장소에 있는 여러 프로젝트가 서로 쉽게 상호 참조할 수 있다.</p>\n\n<h4 id=\"\">용어</h4>\n\n<ul>\n<li>project\n<ul><li>= 저장소</li>\n<li>하나 이상의 worktree 포함</li>\n<li>최소 한 개의 workspace(즉, 루트 workspace) 존재</li></ul></li>\n<li>workspace\n<ul><li>= 모노레포 패키지</li></ul></li>\n<li>worktree\n<ul><li>자식 workspace를 갖는 workspace</li></ul></li>\n</ul>\n\n<h4 id=\"worktree\">worktree 선언</h4>\n\n<p>worktree를 구성하는 workspace의 위치를 glob 패턴의 배열로 나타낸다. 예를 들어 packages 폴더 내의 모든 폴더가 workspace가 되도록 하려면 다음과 같이 설정한다.</p>\n\n<pre><code class=\"language-json\">{\n    \"private\": true,\n    \"workspaces\": [\"packages/*\"]\n}\n</code></pre>\n\n<blockquote>\n  <p>Yarn 1.x에서는 <code>private: true</code> 필드값이 필수지만 2.x 이상에서는 필수가 아니다.</p>\n</blockquote>\n\n<h4 id=\"workspace\">workspace 추가</h4>\n\n<p>그림과 같이 <code>client</code>, <code>server</code>, <code>common</code> 세 개의 workspace를 추가하고 루트 경로에서 <code>yarn</code> 명령을 실행하면 루트 경로에 <code>node_modules</code> 디렉터리에 workspace들에 대한 <strong>심볼릭 링크</strong>가 생성된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4a463e5fbd.png\" alt=\"\" /></p>\n\n<h4 id=\"workspace\">workspace에 대한 명령 실행</h4>\n\n<p><a href=\"https://classic.yarnpkg.com/en/docs/cli/workspace\">특정 workspace에 정의된 스크립트를 실행</a>한다.</p>\n\n<pre><code>yarn workspace &lt;WORKSPACE_NAME&gt; &lt;COMMAND_NAME&gt;  \n</code></pre>\n\n<h4 id=\"workspace\">workspace를 의존성으로 추가</h4>\n\n<p><code>client</code> 패키지가 <code>common</code> 패키지를 의존하게 하려면 package.json에 의존성을 명시하거나 바로 위에서 설명한 yarn workspace 명령을 이용하면 된다.</p>\n\n<pre><code>yarn workspace client add common@1.0.0  \n</code></pre>\n\n<p>npm 레지스트리에 publish된 <code>common</code>이란 이름의 패키지가 있다 해도, 의존성 버전을 충족한다면 로컬에 존재하는 <code>common</code> workspace를 우선하여 설치한다.</p>\n\n<p><code>client</code>에서 <code>common</code> 의존성을 잘 부르는지 확인하기 위해 다음 명령을 실행해 보면 <code>common</code>의 <code>hello()</code> 함수가 <code>client</code>에서 잘 호출되는 것을 확인할 수 있다.</p>\n\n<pre><code>yarn workspace client run start  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4ac5e45fcc.png\" alt=\"\" /></p>\n\n<h4 id=\"workspace\">workspace 의존 관계 확인</h4>\n\n<p><a href=\"https://classic.yarnpkg.com/en/docs/cli/workspaces\">yarn workspace info</a> 명령을 실행해 workspace들의 의존 관계를 알아볼 수 있다.</p>\n\n<blockquote>\n  <p>Yarn 2.x 이후에는 <a href=\"https://yarnpkg.com/cli/workspaces/list\">yarn workspaces list</a>를 사용한다.</p>\n</blockquote>\n\n<pre><code>yarn workspaces info  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4b386f670d.png\" alt=\"\" /></p>\n\n<h4 id=\"workspace\">모든 workspace에 대해 명령 실행</h4>\n\n<p><a href=\"https://classic.yarnpkg.com/en/docs/cli/workspaces\">yarn workspaces run \\<command\\></a>를 사용하면 모든 workspace에 대해 명령을 실행할 수 있다. 다음 명령은 모든 workspace들을 순회하며 test 스크립트를 실행한다.</p>\n\n<pre><code>yarn workspaces run test  \n</code></pre>\n\n<blockquote>\n  <p>Yarn 2.x 이후에는 <a href=\"https://yarnpkg.com/cli/workspaces/foreach\">yarn workspaces foreach \\<command\\></a>를 사용한다.</p>\n</blockquote>\n\n<h4 id=\"\">루트 프로젝트에 의존성 추가</h4>\n\n<p>workspace가 아니라 루트 프로젝트에 의존성을 추가하려면 다음 명령을 실행한다.</p>\n\n<pre><code>yarn add &lt;PACKAGE_NAME&gt; -W  \n</code></pre>\n\n<h4 id=\"\">호이스팅(의존성 끌어올리기)</h4>\n\n<p>npm, yarn 등은 중복 의존성 설치를 방지하기 위해 <a href=\"https://classic.yarnpkg.com/blog/2018/02/15/nohoist/\">호이스팅(hosting)</a> 기법을 사용한다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4cd0ca7890.png\" alt=\"\" /></p>\n\n<p>(그림 출처: <a href=\"https://classic.yarnpkg.com/blog/2018/02/15/nohoist/\">https://classic.yarnpkg.com/blog/2018/02/15/nohoist/</a>)</p>\n\n<p>모노레포에서의 구조는 다음과 같다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4d9bce0677.png\" alt=\"\" /></p>\n\n<p>일부 모듈 로더는 <a href=\"https://github.com/facebook/metro/issues/1\">심볼릭 링크</a>를 지원하지 않기 때문에 B(2.0)을 탐색할 수 없다. 이때는 <a href=\"https://classic.yarnpkg.com/blog/2018/02/15/nohoist/\">nohoist</a> 필드를 사용하면 된다.</p>\n\n<pre><code class=\"language-json\">{\n    \"workspaces\": {\n        \"packages\": [\"packages/*\"],\n        \"nohoist\": [ \"**/react-native\" ]\n    }\n}\n</code></pre>\n\n<p>그 외의 Yarn 1.x에 대한 명령어는 <a href=\"https://classic.yarnpkg.com/en/docs/cli/\">CLI Introduction</a>에서 확인할 수 있다.</p>\n\n<h3 id=\"yarnberry2x3x\">Yarn Berry (2.x, 3.x)</h3>\n\n<p><a href=\"https://yarnpkg.com/cli\">https://yarnpkg.com/cli</a></p>\n\n<p>Yarn workspace를 도입하려고 할 때 성능면에서 Yarn Berry를 함께 검토해 볼 수 있다. Yarn Berry는 yarn의 두 번째 버전으로, 2018년 9월 yarn의 <a href=\"https://github.com/yarnpkg/rfcs\">RFC 저장소</a>에서 시작되었다. Yarn 1.x의 주요 개발자인 Mael Nison에 의해 TypeScript로 개발되었고 2020년 1월 25일 <a href=\"https://dev.to/arcanis/introducing-yarn-2-4eh1\">정식 버전이 출시</a>되었다. Yarn 1.x는 <a href=\"https://github.com/yarnpkg/yarn\">v1.22.17에서 코드 프리징</a>되었고 <a href=\"https://github.com/yarnpkg/berry\">https://github.com/yarnpkg/berry</a> 에서 2022.03.09 현재 v3.2.0이 출시되었다.</p>\n\n<h4 id=\"node_modules\">node_modules의 문제점</h4>\n\n<ul>\n<li><p>의존성 탐색 알고리즘의 비효율</p>\n\n<p>node.js에서 <code>require()</code> 함수를 실행하면 모듈을 찾을 때까지 상위 node_modules 디렉터리를 순회한다. 이때 <a href=\"https://github.com/nodejs/node/blob/24fc302eadf64d2518733a2ae40355916e6990f7/lib/internal/modules/cjs/loader.js#L321-L336\">느린 디스크 I/O 동작</a>이 경로의 깊이만큼 발생한다.</p></li>\n<li><p>저장 공간과 설치 시간</p>\n\n<p>node_modules 디렉터리는 흔히 매우 큰 공간을 필요로 하고, 그만큼 설치에도 오랜 시간이 걸린다.</p></li>\n<li><p>유령 의존성(phantom dependency)</p>\n\n<p>의존성 중복 방지를 위해 호이스팅 기법을 이용하는데 이것은 의도치 않은 side effect을 발생시킨다. 아래 그림에서 <strong>package-1은 B(1.0)을 설치한 적이 없지만 require('B')가 작동한다</strong>. require('B')를 사용하는 경우 B(1.0)을 의존하던 패키지를 제거하면 B를 찾지 못하는 오류가 발생한다.</p></li>\n</ul>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4f08550681.png\" alt=\"\" /></p>\n\n<h4 id=\"yarnberrypnp\">Yarn Berry의 해결 방법 PnP</h4>\n\n<p>어떤 프로젝트를 구성하는 의존성은 결정적(deterministic)이다. Berry는 node_modules에 패키지 파일을 저장하는 대신 패키지의 압축 파일을 <code>.yarn/cache</code> 폴더에 수평적으로 저장하는 방식으로 위 문제를 해결했다. 이 방식을 Yarn은 Plug’n’Play(PnP)라고 부른다. 압축 파일은 ZipFS를 이용하며 해당 모듈 로드가 필요할 때 메모리에서 압축을 해제하여 접근한다.</p>\n\n<h4 id=\"pnp\">PnP로 얻는 것</h4>\n\n<ul>\n<li><p>빠른 의존성 검색</p>\n\n<p>의존성이 <code>.yarn/cache</code>에 수평적으로 존재하므로 모든 패키지에 대한 접근 시간이 O(1)이 된다. 따라서 <code>require()</code>에 소요되는 시간이 크게 단축된다.</p></li>\n<li><p>빠른 설치</p>\n\n<p>압축 파일 단위로 설치되기 때문에 의존성을 구성하는 파일의 수가 절대적으로 감소한다. 여기에 <a href=\"https://yarnpkg.com/features/zero-installs\">zero-install</a> 전략을 사용하면 아예 설치 과정을 생략할 수 있다.</p></li>\n<li><p>유령 의존성 방지</p>\n\n<p>호이스팅을 사용하지 않기 때문에 의도하지 않은 의존성이 발생하지 않는다.</p></li>\n</ul>\n\n<h4 id=\"zeroinstall\">zero-install 전략</h4>\n\n<p><a href=\"https://github.com/yarnpkg/berry/tree/master/.yarn/cache\">https://github.com/yarnpkg/berry/tree/master/.yarn/cache</a></p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4f85570687.png\" alt=\"\" /></p>\n\n<p>하나의 압축 파일로 의존성을 관리하고 이 파일을 git으로 관리하면 설치 과정을 제거할 수 있는데 이와 같은 전략을 zero-install이라 한다. 이 전략의 장점은 다음과 같다.</p>\n\n<ul>\n<li>다른 브랜치에서 새로운 의존성이 설치되었을 때 설치 과정 없이 바로 사용할 수 있다.</li>\n<li>CI에서 의존성 설치에 드는 시간을 크게 줄일 수 있다.</li>\n</ul>\n\n<h4 id=\"\">오프라인 캐시</h4>\n\n<p>네트워크가 다운되었을 때에도 Yarn이 제대로 작동하도록 하는 기능이다. 자세한 기능은 <a href=\"https://yarnpkg.com/features/offline-cache\">Offline Cache</a>를 참고한다.</p>\n\n<h4 id=\"\">사용 방법</h4>\n\n<p>간단히 사용 방법을 살펴보자.</p>\n\n<pre><code>$ npm install -g yarn\n$ cd ../path/to/your-package\n$ yarn init -y\n$ yarn set version berry\n</code></pre>\n\n<p>아래와 같은 초기 파일이 생성된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa4ff99a07dd.png\" alt=\"\" /></p>\n\n<p><strong>해당 디렉터리에서 Yarn 버전을 살펴보면</strong> 1.x가 아닌 것을 확인할 수 있다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa503aca09ad.png\" alt=\"\" /></p>\n\n<p>의존성을 추가하면 <code>.yarn/cache</code> 경로에 추가된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5088b009b5.png\" alt=\"\" /></p>\n\n<h4 id=\"pnpcjs\">.pnp.cjs</h4>\n\n<p><code>.pnp.cjs</code> 파일에는 모든 의존성에 대한 메타 정보(zip 경로, 의존성)와 함께 ZipFS에 대한 처리 코드가 들어있다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa56ebc6393d.png\" alt=\"\" /></p>\n\n<p>따라서 Berry 기반의 프로젝트는 <code>node src/main.js</code>와 같은 명령으로는 실행할 수 없고 <code>yarn node src/main.js</code>와 같이 Yarn을 통해서 실행해야 한다.</p>\n\n<pre><code class=\"language-json\">{\n    \"scripts\": {\n        \"start\": \"node src/main.js\"\n    }\n}\n</code></pre>\n\n<p>위와 같이 package.json에 스크립트 명령을 작성한 경우에는 <code>yarn start</code> 명령을 사용할 수 있다.</p>\n\n<p><a id=\"ch2\"></a></p>\n\n<h2 id=\"2lerna\">2. Lerna</h2>\n\n<p><a href=\"https://lerna.js.org/\">https://lerna.js.org/</a></p>\n\n<p>Lerna는 <a href=\"https://www.npmjs.com/package/lerna/v/1.0.1\">Babel 개발자</a>에 의해 개발되어 2015년부터 <a href=\"https://lerna.js.org/#users\">다수의 프로젝트</a>에서 모노레포 관리 도구로 사용되어 왔다. 2022년 5월 현재 Nx의 개발사인 <a href=\"https://nrwl.io/\">Nrwl</a>이 <a href=\"https://github.com/lerna/lerna/issues/3121\">프로젝트 관리 권한을 인수</a>했다.</p>\n\n<p>Lerna는 저수준의 Yarn, npm 위에 있는 고수준 레이어로 볼 수 있다. Yarn으로 모노레포를 구성할 수는 있지만 여러 workspace의 버전 관리, 테스트, 빌드, 배포, 게시 등의 작업은 일일이 구성해야 한다. Lerna는 이러한 작업을 최적화한다.</p>\n\n<h3 id=\"lerna\">Lerna 기반 프로젝트 생성</h3>\n\n<p>CLI를 쉽게 사용하기 위해 글로벌로 설치한다.</p>\n\n<pre><code>npm install --global lerna  \n</code></pre>\n\n<p>프로젝트를 Lerna로 초기화한다.</p>\n\n<pre><code>cd path/to/your-project  \nlerna init  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5745f246a6.png\" alt=\"\" /></p>\n\n<p>다음과 같이 초기 디렉터리가 구성된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa57954a46ac.png\" alt=\"\" /></p>\n\n<h3 id=\"lernajson\">lerna.json</h3>\n\n<ul>\n<li><code>version</code>: 각 workspace에 대한 버전을 관리할 수 있다. 개별로 관리하고자 할 때는 \"independent\"를 입력한다.</li>\n<li><code>npmClient</code>: \"npm\" 또는 \"yarn\"</li>\n<li><code>useWorkspaces</code>: npmClient의 workspace로 관리되도록 한다.</li>\n</ul>\n\n<h3 id=\"workspace\">workspace 추가</h3>\n\n<p>다음 명령을 실행해 새로운 workspace를 스캐폴딩할 수 있다.</p>\n\n<pre><code>lerna create &lt;PACKAGE-NAME&gt;  \n</code></pre>\n\n<p>다음과 같이 <code>client</code> workspace를 생성할 수 있다.</p>\n\n<pre><code>lerna create client  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa587ca8631f.png\" alt=\"\" /></p>\n\n<h3 id=\"workspace\">workspace에 의존성 추가</h3>\n\n<p>아래와 같이 <code>client</code> workspace에 react 패키지를 설치할 수 있다. <code>--scope</code> 없이 사용하면 모든 workspace에 추가한다. 추가하려는 의존성이 workspace라면 해당 workspace를 제외한 모든 workspace에 추가된다.</p>\n\n<blockquote>\n  <p>현재 <a href=\"https://github.com/lerna/lerna/issues/2004\">여러 의존성을 한번에 추가</a>하는 기능은 지원되지 않는다.</p>\n</blockquote>\n\n<p><code>client</code> workspace에 react 패키지를 추가한다.</p>\n\n<pre><code>lerna add react --scope=client  \n</code></pre>\n\n<p><code>client</code> workspace에 <code>common</code> workspace를 추가한다.</p>\n\n<pre><code>lerna add common@0.0.0 --scope=client  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa58f1f3035c.png\" alt=\"\" /></p>\n\n<h3 id=\"\">루트 프로젝트에 의존성 추가</h3>\n\n<p>아래와 같이 lodash를 루트 프로젝트에 설치할 수 있다.</p>\n\n<pre><code>yarn add lodash --ignore-workspace-root-check  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5951d30362.png\" alt=\"\" /></p>\n\n<h3 id=\"workspacenpm\">모든 workspace에 대해 npm 스크립트 실행</h3>\n\n<p>해당 스크립트가 포함된 각 workspace에서 npm 스크립트를 실행한다.</p>\n\n<pre><code>lerna run &lt;COMMAND_NAME&gt; -- [..args]  \n</code></pre>\n\n<p>다음은 모든 workspace에 대해 test를 실행한다.</p>\n\n<pre><code>lerna run test  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa59fc4d0468.png\" alt=\"\" /></p>\n\n<h3 id=\"workspace\">모든 workspace에 대해 임의 명령 실행</h3>\n\n<pre><code>lerna exec -- &lt;COMMAND&gt; [..args]  \n</code></pre>\n\n<p>다음은 모든 workspace 하위의 node_modules 폴더를 지운다.</p>\n\n<pre><code>lerna exec -- rm -rf ./node_modules  \n</code></pre>\n\n<h3 id=\"npmpublish\">npm publish</h3>\n\n<p>자세한 옵션은 <a href=\"https://github.com/lerna/lerna/tree/main/commands/publish#readme\">공식 문서</a>를 참고한다.</p>\n\n<pre><code>lerna publish               ## 마지막 릴리스 이후 변경된 패키지 publish  \nlerna publish from-git      ## 현재 커밋에 태그가 지정된 패키지를 명시적으로 publish  \nlerna publish from-package  ## 레지스트리에 최신 버전이 없는 패키지를 명시적으로 publish  \n</code></pre>\n\n<h3 id=\"changelog\">버전 관리 및 CHANGELOG 작성 자동화</h3>\n\n<p>workspace에 변경을 가하고 나서 <code>lerna version</code>을 실행하면 각 workspace의 package.json에 명시된 버전을 자동으로 올리고 git에 tag를 남기고 변경에 대한 CHANGELOG도 작성한다.</p>\n\n<blockquote>\n  <p>더 많은 기능은 <a href=\"https://github.com/lerna/lerna-changelog\">lerna-changelog</a>를 참고한다.</p>\n</blockquote>\n\n<pre><code>lerna version  \n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5a75592126.png\" alt=\"\" />\n<img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5ab28d2276.png\" alt=\"\" />\n<img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5ae6982381.png\" alt=\"\" /></p>\n\n<p><code>changelogPreset</code> 필드를 이용하면 <code>git commit message</code>를 이용해 CHANGELOG를 자동으로 생성할 수 있다. 예시에서는 <a href=\"https://www.npmjs.com/package/conventional-changelog-conventionalcommits\">conventional-changelog-conventionalcommits</a> 프리셋을 이용했다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5b7e6d2423.png\" alt=\"\" /></p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5bb8b2245b-4.png\" alt=\"\" /></p>\n\n<h3 id=\"lerna\">Lerna 명령어</h3>\n\n<p>그 외에도 변경 사항을 알아내거나 workspace 목록을 얻거나 lerna, npmClient, OS 등의 환경을 알아내는 등\n다양한 기능을 제공한다. Lerna의 자세한 명령어는 다음을 참고한다.</p>\n\n<ul>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/publish#readme\"><code>lerna publish</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/version#readme\"><code>lerna version</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/bootstrap#readme\"><code>lerna bootstrap</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/list#readme\"><code>lerna list</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/changed#readme\"><code>lerna changed</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/diff#readme\"><code>lerna diff</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/exec#readme\"><code>lerna exec</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/run#readme\"><code>lerna run</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/init#readme\"><code>lerna init</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/add#readme\"><code>lerna add</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/clean#readme\"><code>lerna clean</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/import#readme\"><code>lerna import</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/link#readme\"><code>lerna link</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/create#readme\"><code>lerna create</code></a></li>\n<li><a href=\"https://github.com/lerna/lerna/tree/main/commands/info#readme\"><code>lerna info</code></a></li>\n</ul>\n\n<p><a id=\"ch3\"></a></p>\n\n<h2 id=\"3nx\">3. Nx</h2>\n\n<p>다음은 구글 개발자들이 만든 오픈소스 프로젝트인 <a href=\"https://nx.dev/\">Nx</a>이다. Nx는 모노레포 구성을 위한 다양한 개발 도구를 제공하고 Angular, React와 같은 프런트엔드 프레임워크 기반의 개발 환경 구성뿐 아니라 Express, <a href=\"https://nestjs.com/\">Nest.js</a>와 같은 백엔드 기술 기반의 개발까지 폭넓게 지원하고 있다. 이뿐만 아니라 workspace 생성 시 Cypress, Jest 등을 기반으로 한 테스트 환경까지 설정해주기 때문에, 초기 모노레포 개발 환경 구축 비용을 크게 줄여준다.</p>\n\n<p>그럼 Nx를 사용해서 간단하게 모노레포를 구성해 보고, 그 특징을 몇 가지 살펴보겠다.</p>\n\n<h3 id=\"nxworkspace\">새로운 Nx workspace 생성하기</h3>\n\n<p>아래의 명령을 입력해 새로운 Nx workspace 생성을 시작할 수 있다.</p>\n\n<pre><code>npx create-nx-workspace  \n</code></pre>\n\n<p>Nx는 workspace 생성을 완료하기 위해, 다음과 같이 추가로 몇 가지 항목을 입력하도록 요구한다.</p>\n\n<blockquote>\n  <p>Nx Cloud의 경우 필수는 아니다.</p>\n</blockquote>\n\n<pre><code>Workspace name (e.g., org name)     My-Workspace  \nWhat to create in the new workspace angular  \nApplication name                    my-app  \nDefault stylesheet format           CSS  \nUse Nx Cloud?                       No  \n</code></pre>\n\n<p>이 항목을 입력하고 나면 다음과 같은 구조의 Nx workspace가 생성된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5c2cd82663.png\" alt=\"\" /></p>\n\n<p>생성된 workspace 구조에서 이를 구성하는 디렉터리의 특징을 간단히 알아보겠다.</p>\n\n<ul>\n<li><code>apps/*</code>: 애플리케이션 프로젝트들이 위치한다. 우리가 처음에 생성한 애플리케이션도 여기에 들어있는 것을 볼 수 있다. Angular 기반으로 workspace를 생성했어도 꼭 Angular 프로젝트만 이 디렉터리에 들어갈 필요는 없으며 React 등 다른 프레임워크 기반의 코드도 공존할 수 있다.</li>\n<li><code>libs/*</code>: 애플리케이션 전반에서 공통으로 사용할 코드를 여기에 작성한다.</li>\n<li><code>tools/*</code>: 개발에 필요한 tooling script가 위치한다.</li>\n</ul>\n\n<p>이제 생성한 애플리케이션을 실행해 보겠다. 애플리케이션은 다음과 같은 명령으로 실행할 수 있다.</p>\n\n<pre><code>npx nx serve &lt;APP_NAME&gt; // 주의: workspace 이름이 아닌 애플리케이션 이름  \n</code></pre>\n\n<p>만약 전역(global)에 Nx가 설치되어 있다면 다음과 같은 명령으로 애플리케이션을 실행할 수도 있다.</p>\n\n<pre><code>nx serve &lt;APP_NAME&gt;  \n</code></pre>\n\n<blockquote>\n  <p>전역에 Nx 설치하기: <code>npm install -g nx</code> 또는 <code>yarn global add nx</code></p>\n</blockquote>\n\n<p>위의 명령 실행이 완료되었다면, <code>localhost:4200</code>에 접속해서 애플리케이션을 확인해 볼 수 있다.</p>\n\n<h4 id=\"nxclivsangularcli\">Nx CLI vs Angular CLI</h4>\n\n<p>Angular 프로젝트 개발 경험이 있다면 Angular CLI(aka. ng)에 익숙할 것이다. 실제로, Angular 기반의 Nx workspace를 생성한 경우 대부분의 Nx 명령어는 <code>ng ...</code> 로 대체가 가능하고(예: <code>ng serve</code>) 그 결과 또한 동일하다.</p>\n\n<p>하지만 Nx에서는 Nx CLI 사용을 권장한다. 그 이유는 Nx가 Nx CLI를 통해 제공하는 몇몇 기능이 있기 때문이다. 그 기능 중 하나인 Computation Cache에 대해선 나중에 살펴보겠다.</p>\n\n<blockquote>\n  <p>\"Use Nx CLI over Angular CLI\" - Nx.dev -</p>\n</blockquote>\n\n<h3 id=\"\">라이브러리 추가해보기</h3>\n\n<p>이번엔 애플리케이션 전반에서 사용할 수 있는 <a href=\"https://nx.dev/angular/library\">라이브러리</a>를 추가해보겠다.</p>\n\n<p>라이브러리는 목적과 특성에 따라 다음과 같이 네 가지로 나눌 수 있다.</p>\n\n<ul>\n<li>feature 라이브러리</li>\n<li>UI 라이브러리</li>\n<li>data-access 라이브러리</li>\n<li>utility 라이브러리</li>\n</ul>\n\n<p>여기서는 간단하게 UI 라이브러리를 추가해 보겠다.</p>\n\n<pre><code>npx nx g @nrwl/angular:lib ui // ui: 라이브러리 이름  \n</code></pre>\n\n<pre><code>npx nx g @nrwl/react:lib ui // React의 경우  \n</code></pre>\n\n<p>위 명령으로 <code>ui</code>라는 이름의 Angular 컴포넌트가 라이브러리에 추가되어 다음과 같은 구조가 만들어진다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5cc8762692.png\" alt=\"\" /></p>\n\n<p>이제 생성된 UI 라이브러리 구조에 실제 View 역할을 할 컴포넌트를 추가하겠다.</p>\n\n<pre><code>npx nx g component first-lib --project=ui --export  \n</code></pre>\n\n<p>다음 그림과 같이 <code>ui</code> 라이브러리 아래에 우리가 선언한 <code>first-lib</code> 컴포넌트 파일이 추가되었다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa5e669b2c95.png\" alt=\"\" /></p>\n\n<h3 id=\"ui\">생성한 UI 라이브러리 사용해보기</h3>\n\n<p>그럼 이제 라이브러리를 애플리케이션에서 사용하는 방법을 알아보겠다.</p>\n\n<h4 id=\"1uiappmoduleimport\">1. UI 모듈을 AppModule에 import하기</h4>\n\n<pre><code class=\"language-js\">// in AppModule\n...\n\nimport { UiModule } from '@my-workspace/ui'; // Import UiModule\n\n...\n\n@NgModule({\n  ...\n\n  imports: [BrowserModule, UiModule], // Add UiModule in the importing list\n\n  ...\n})\nexport class AppModule {}  \n</code></pre>\n\n<p>이때 라이브러리를 import하는 구문은 다음과 같다.</p>\n\n<pre><code>import &lt;UI_MODULE_NAME&gt; from @&lt;WORKSPACE_NAME&gt;/&lt;LIBRARY_NAME&gt;  \n</code></pre>\n\n<p>Nx는 라이브러리가 추가될 때마다 <code>tsconfig.base.json</code> 파일에 TS 경로를 매핑하기 때문에 위와 같이 참조할 수 있다.</p>\n\n<h4 id=\"2applicationtemplateui\">2. Application Template에서 UI 라이브러리 컴포넌트 사용하기</h4>\n\n<p>1번에서 모듈을 import했다면, 생성한 라이브러리의 컴포넌트를 Application Template에서 다음과 같이 사용할 수 있다.</p>\n\n<pre><code class=\"language-html\">&lt;!-- in Application Template --&gt;  \n&lt;my-workspace-first-lib&gt;&lt;/my-workspace-first-lib&gt;  \n</code></pre>\n\n<h4 id=\"\">라이브러리 생성 및 사용 시 주의할 점</h4>\n\n<p>에디터로 Visual Studio Code(이하 VS Code)를 사용하는 경우, 라이브러리를 생성 및 참조할 때 컴파일 오류가 발생하는 경우가 있다. 이는 VS Code의 TS 서버가 새로운 라이브러리를 바로 인식하는 데 실패하는 경우로, 이때는 VS Code를 재시작하는 것을 권장한다. 또한 새로운 라이브러리를 추가할 때마다 Nx 서버를 재시작해야 한다는 점을 주의한다.</p>\n\n<h3 id=\"nx\">Nx가 제공하는 도구</h3>\n\n<p>지금까지 Nx workspace의 생성, 라이브러리 추가와 사용에 대해서 간단히 알아보았다. 이어서 Nx가 제공하는 몇 가지 기능을 소개하겠다.</p>\n\n<h4 id=\"1projectgraph\">1. Project Graph</h4>\n\n<p>첫 번째는 Project Graph이다. 대부분의 프로젝트는 성장하면서 수많은 애플리케이션과 라이브러리가 생겨나고 점차 그 구성 요소 간의 의존 관계가 복잡해져 개발자 입장에서는 그 의존 관계를 파악하기가 점점 어려워진다. Nx는 이를 시각화하여 프로젝트 구성 요소 간의 관계를 파악하기 쉽도록 하는 Project Graph를 제공한다.</p>\n\n<pre><code>npx nx graph  \n</code></pre>\n\n<p>위의 명령을 실행하여 현재 workspace의 전체 Project Graph를 확인할 수 있고, Nx가 제공하는 인터페이스를 통해 다양한 필터링도 가능하다. 아래는 위에서 진행한 예시 workspace의 Project Graph이다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa60537a3c8e.png\" alt=\"\" /></p>\n\n<h4 id=\"2computationcaching\">2. Computation Caching</h4>\n\n<p>Nx는 Nx CLI를 통해 내부적으로 Computation Caching을 제공한다. 이를 확인해보기 위해 <code>nx build [appName]</code> 명령을 실행해 보겠다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa609e2d3c9c.png\" alt=\"\" /></p>\n\n<p>빌드가 완료된 후, 위와 동일한 명령을 한 번 더 실행해 보았다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa60f1c13ca6.png\" alt=\"\" /></p>\n\n<p>이번에는 빌드가 바로 완료됨(21ms)을 볼 수 있고, 맨 아래 텍스트에서 볼 수 있는 것처럼 Nx는 로컬 캐시에\n해당 Artifact가 존재하는 경우 가져다 쓰는 걸 알 수 있다. 단, 캐싱은 Nx CLI에서만 동작하기 때문에, Angular CLI를 사용하는 경우엔 Computation Caching이 적용되지 않는다.</p>\n\n<blockquote>\n  <p><a href=\"https://nx.dev/using-nx/caching\">Computation Caching 더 알아보기</a></p>\n</blockquote>\n\n<h4 id=\"3affected\">3. Affected</h4>\n\n<p>다음은 Affected 스크립트이다.</p>\n\n<pre><code>npx nx affected  \n</code></pre>\n\n<p>Nx는 코드를 수정했을 때 workspace의 어떤 부분이 영향을 받는지 알려주는 명령을 제공한다. Affected 스크립트는 필요에 따라 다음과 같이 다양하게 사용할 수 있다.</p>\n\n<ul>\n<li><code>npx nx affected:apps</code>: 수정한 부분이 어떤 애플리케이션에 영향을 주었는지 표시한다.</li>\n<li><code>npx nx affected:libs</code>: 수정한 부분이 어떤 라이브러리에 영향을 주었는지 표시한다.</li>\n<li><code>npx nx affected:test</code>: 코드 수정에 의해 영향을 받은 부분에 대해서만 테스트를 실행한다.</li>\n</ul>\n\n<p>다음은 UI 라이브러리를 수정한 뒤 위 명령을 실행한 모습이다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa614fa13cf6.png\" alt=\"\" /></p>\n\n<h4 id=\"4vscodenxconsole\">4. VS Code용 Nx Console</h4>\n\n<p>마지막으로 Nx Console이다. Nx Console은 VS Code에서 Nx를 쉽게 사용하기 위한 GUI 도구다. Nx Command로 하는 모든 작업을 Nx Console로도 할 수 있도록 구성되어 있다. VS Code를 사용 중이라면 Nx Console을 사용하는 것을 추천한다.</p>\n\n<blockquote>\n  <p><a href=\"https://marketplace.visualstudio.com/items?itemName=nrwl.angular-console\">VS Code에 Nx Console 설치하기</a></p>\n</blockquote>\n\n<p>다음은 VS Code에 Nx Console을 설치한 모습이다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa61bac843a8.png\" alt=\"image-20220321-115005-809.png\" /></p>\n\n<p><a id=\"ch4\"></a></p>\n\n<h2 id=\"4turborepo\">4. Turborepo</h2>\n\n<p>Turborepo는 대규모 모노레포 프로젝트 관리에서 오는 피로감과 부수적인 툴링에 대한 부담을 줄이면서, Google이나 Facebook과 같은 큰 기업에서 사용하는 수준의 개발 경험을 주는 데 포커싱한, Vercel에서(<a href=\"https://vercel.com/blog/vercel-acquires-turborepo\">2021년 12월에 인수</a>) 개발 및 운영하고 있는 JavaScript/TypeScript를 위한 모노레포 빌드 시스템이다.</p>\n\n<p>Turborepo는 증분 빌드(incremental build), 원격 캐싱, 병렬 처리 기법을 통해 빌드 성능을 끌어올리고, <code>Pipeline</code>의 쉬운 설정과 profiling, trace 등 다양한 시각화 기능을 제공해 관리 편의성을 높인 것이 특징이다.</p>\n\n<p>그리고 기존의 모노레포 프로젝트에 점진적으로 Turborepo를 적용할 수 있으며, 쉽게 Turborepo로 구성된 새 모노레포 프로젝트를 생성할 수 있도록 스캐폴딩 기능을 제공한다. 또한 패키지 매니저로 <code>yarn</code>, <code>npm</code>, <code>pnpm</code>와 함께 잘 동작하므로 프로젝트 상황에 맞게 선택해 사용할 수 있다.</p>\n\n<p>Turborepo가 어떻게 구성되어 있는지 먼저 살펴보고, 앞서 언급한 특징을 설명하면서, 어떻게 사용하는지 설명하겠다.</p>\n\n<h3 id=\"createturbo\">create-turbo 구성 확인하기</h3>\n\n<p>아래의 명령어를 통해 새 모노레포 프로젝트를 생성해 보자.</p>\n\n<pre><code>$ npx create-turbo@latest &lt;PACKAGE_NAME&gt;\n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa6222a443d1.png\" alt=\"\" /></p>\n\n<p>위 그림과 같이 <code>/app</code> 하위에 <code>docs</code>, <code>web</code> 앱과 공통 패키지인 <code>/packages</code> 하위의 <code>ui</code>, <code>config</code> 패키지가 있는 프로젝트가 생성된다. 이 구조는 일반적인 모노레포 프로젝트 구조와 유사해 쉽게 Turborepo를 사용할 수 있도록 한다.</p>\n\n<p>Vercel사에서 운영하는 프로젝트답게 앱은 기본적으로 <code>Next.js(react)</code>로 설정된다. 그외에 <code>Express</code>, <code>Remix</code>, <code>pnpm</code> 등 다양한 기술 스택으로 이루어진 <a href=\"https://github.com/vercel/turborepo/tree/main/examples\">예시</a>도 제공하고 있으므로 필요에 따라 참고할 수 있다.</p>\n\n<h3 id=\"\">캐싱</h3>\n\n<p>이미 계산한 것들은 다시는 계산하지 않는다는 핵심 컨셉 아래 캐싱이 이루어지고 있다. 이전에 실행한 파일 및 로그를 캐싱해, 만약 현재 실행 태스크에 이미 완료한 작업이 있다면 이것을 건너뛰기 때문에 작업 실행 시간을 효과적으로 줄일 수 있다.</p>\n\n<p>앞서 만든 프로젝트에서 빌드를 진행해 보자.</p>\n\n<pre><code class=\"language-sh\">$ yarn turbo run build\n</code></pre>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa628ae343e6.png\" alt=\"\" /></p>\n\n<p>그 다음 위 명령어로 다시 빌드를 하면 다음과 같이 시간이 대폭 줄어든 것을 확인할 수 있다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa62cccd43f2.png\" alt=\"\" /></p>\n\n<p>그렇다면 이 캐시들은 어떻게 저장되고 있을까?</p>\n\n<p>빌드를 하면 <code>/app</code> 하위 패키지들의 <code>.turbo</code> 디렉터리에 각각 로그 파일이 생기고 이 로그에는 해당 빌드에 대한 hash가 저장된다.(Turborepo는 빌드해야 할 항목을 파악하기 위해 타임스탬프를 확인하고 활용하는 대신 파일의 내용에 따른 hash 정책을 사용한다.) 이 hash 값들은 아래 이미지와 같이 <code>node_modules/.cache/turbo</code> 하위에 hash로 구분된 스냅샷 폴더와 매칭된다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa633331443c.png\" alt=\"\" />\n<img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa6373234447.png\" alt=\"\" /></p>\n\n<p>이렇게 모든 작업에 대한 캐싱을 진행하기 때문에 변화된 부분만 재빌드하고 나머지는 캐싱한 것을 사용하면서 Turborepo는 작업 속도를 높일 수 있다.</p>\n\n<h3 id=\"\">원격 캐싱</h3>\n\n<p>위에서 설명한 캐시는 로컬 환경에서만 유효하다는 한계가 있다. 그러나 Turborepo는 이 한계를 극복하는 <strong>원격 캐싱</strong>이라는 강력한 기능을 제공한다.</p>\n\n<p>더 빠른 빌드를 위해 빌드 캐시를 클라우드에 올려서 팀원 및 CI/CD시스템이 공유해 사용할 수 있어 대규모 프로젝트에서 다수의 팀이 협업하는 환경에서 개발 효율성을 높일 수 있다.</p>\n\n<p>실제로 원격 캐싱을 한 상태에서 빌드를 실행하면 \"Remote computation caching enable\" 문구와 함께 빌드 시간이 9초에서 3초로 비약적으로 감소하는 것을 확인해볼 수 있다.</p>\n\n<ul>\n<li>로컬 캐시가 없는 상태에서의 빌드 시간</li>\n</ul>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa63c2224451.png\" alt=\"\" /></p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa6401b8448b.png\" alt=\"\" /></p>\n\n<ul>\n<li>로컬 캐시는 없고 원격 캐시가 있는 상태에서의 빌드 시간</li>\n</ul>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa6442a6449a.png\" alt=\"\" /></p>\n\n<p>다만 이 기능은 현재 experimental(beta) 상태이며 Vercel 클라우드를 활용하기 때문에 Vercel의 계정이 필요하다.</p>\n\n<blockquote>\n  <p><a href=\"https://turborepo.org/docs/features/remote-caching\">공식 문서</a>를 참고해 원격 캐싱 방법을 참고해 볼 수 있다.</p>\n</blockquote>\n\n<h3 id=\"pipelinepackagetask\">Pipeline Package Task</h3>\n\n<p>Pipeline은 각 패키지의 package.json 스크립트(태스크) 간 작업 관계를 정의한다. 이를 통해 새로 들어온 개발자도 작업 관계를 쉽게 이해할 수 있다.</p>\n\n<p>Pipeline 설정은 Turborepo turbo.json에서 확인할 수 있다.(package.json에도 설정 가능하나 turbo.json에 설정하도록 권장하고 있다.)</p>\n\n<pre><code class=\"language-json\">{\n  \"$schema\": \"https://turborepo.org/schema.json\",\n  \"pipeline\": {\n    \"build\": {\n      \"dependsOn\": [\"^build\"]\n    },\n    \"test\": {\n      \"dependsOn\": [\"^build\"]\n    },\n    \"deploy\": {\n      \"dependsOn\": [\"build\", \"test\", \"lint\"]\n    },\n    \"lint\": {}\n  }\n}\n</code></pre>\n\n<p>위 설정에서 <code>dependOn</code>은 <code>pipeline</code> key에 해당하는 작업이 의존하는 작업을 의미한다. 이 부분에 접두사 <code>^</code>가 붙으면 각 패키지에 있는 작업을 의미한다.</p>\n\n<p><code>lint</code>는 의존 관계와 상관없이 언제나 수행될 수 있으며, <code>deploy</code>는 Pipeline에서 <code>build</code>, <code>test</code>, <code>lint</code>가 선행되어야 수행됨을 의미한다.</p>\n\n<p>Pipeline으로 인해 Turborepo의 스케줄러는 기존의 모노레포에 비해 성능이 강력하다. 한 번에 한 테스크씩 수행되는 기존 방식과 다르게 의존성이 없는 작업은 유휴 CPU에서 실행되기 때문에 빌드 시간이 긴 경우에 작업 성능이 비약적으로 높아진다.</p>\n\n<p>다음 그림을 살펴보자.</p>\n\n<p><img src=\"/content/images/2022/04/227eaf62-bf35-4e48-a45a-aede9108a23f.png\" alt=\"\" /></p>\n\n<p>A, B, C 세 개의 패키지로 구성된 프로젝트가 있다. A와 C는 B에 의존한다.</p>\n\n<p><code>lint</code>, <code>build</code>, <code>test</code>, <code>deploy</code> 작업을 순차적으로 수행한다고 했을 때 Lerna의 경우에 A, C 패키지는 B의 <code>build</code>가 끝날 때까지 <code>build</code>를 수행할 수 없다.</p>\n\n<p>이에 반해 Turborepo는 <code>build</code>에 의존 관계가 없는 <code>test</code> 작업이 병렬적으로 수행된다.</p>\n\n<h3 id=\"profile\">Profile</h3>\n\n<p>위에서 언급한 멀티 스레드를 활용한 병렬 작업 처리가 실제로 어떻게 CPU 스레드를 사용해서 작업을 처리하는지 <code>--profile</code> 플래그를 통해 시각화해 확인할 수 있다.</p>\n\n<pre><code class=\"language- sh\">## 이미 작업을 진행한 경우 더 명확한 profiling을 위해 --force 플래그를 추가한다.\n$ yarn turbo run build lint --profile [--force]\n</code></pre>\n\n<p>위 명령을 실행하면 루트 디렉터리에 <code>****-profile.json</code> 파일이 생성된다. 이 파일을 Chrome 개발자 도구의 Performance 탭에 업로드해 스레드에서 작업이 어떤 순서로 얼마만큼의 시간이 걸리는지 확인할 수 있다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa64a13144a5-1.png\" alt=\"\" /></p>\n\n<p>이 밖에도 <code>--trace</code>,  <code>--heap</code>, <code>--cpuprofile</code> 등의 플래그를 사용해 다양한 부분에서 profiling이 가능하다. 자세한 사용 방법은 <a href=\"https://turborepo.org/docs/reference/command-line-reference#--trace\">공식 문서</a>에서 확인할 수 있다.</p>\n\n<h3 id=\"\">의존성 그래프 시각화</h3>\n\n<p>Nx와 마찬가지로 Turborepo도 프로젝트 내 패키지 간 작업 관계를 쉽게 파악할 수 있게 시각화하는 기능을 제공한다. 기본적으로 JPEG 형식의 이미지로 그래프가 그려지며 SVG, HTML, JSON, PDF 등 다양한 형식의 산출물을 지원한다.</p>\n\n<p>먼저 <a href=\"https://graphviz.org/download/\">graphviz</a>가 설치되어 있어야 한다.</p>\n\n<pre><code>$ turbo run build --graph\n$ turbo run build test lint --graph=my-graph.html\n</code></pre>\n\n<p>다음은 위 명령어를 각각 실행해 얻은, 패키지 간 작업 관계를 시각화한 이미지다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa650f84469d.png\" alt=\"\" /></p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa65565d46b5.png\" alt=\"\" /></p>\n\n<p>이 밖에도 CPU trace, heap trace, CPU profile에 대한 시각화 기능도 제공한다. 자세한 내용은 <a href=\"https://turborepo.org/docs/reference/command-line-reference#--trace\">CLI Reference</a>를 참고한다.</p>\n\n<h2 id=\"5\">5. 마치며</h2>\n\n<p>위에 소개한 Yarn, Lerna, Nx 그리고 Turborepo를 간단히 비교하면 다음 표와 같다.</p>\n\n<p><img src=\"/content/images/2022/04/0a710dbd-7f96-14ab-817f-aa65aea54d30.png\" alt=\"\" /></p>\n\n<p>표에서 보이는 것처럼 Yarn은 다른 모노레포 도구에 비해 지원하는 것들이 많지는 않지만, 모노레포 사용의 목적이 <strong>단순히 공통 요소를 공유</strong>하는 것이라면 Yarn으로 workspace을 구성해서 개발을 진행하는 것을 추천한다.</p>\n\n<p>하지만 단순한 코드의 공유 외에 <strong>패키지 간 의존성 관리 및 테스트, 배포</strong> 등의 작업에 대한 더 나은 무언가를 필요로 한다면 Lerna를 함께 사용해보는 것도 좋은 선택지가 될 것이다.</p>\n\n<p>그리고 프로젝트가 성장하면서 개발, 관리에 유용한 더 많은 기능이 필요하다면 Nx와 Turborepo를 고려해보면 좋을 것 같다. Nx와 Turborepo는 모두 <strong>캐싱</strong> 기능을 지원해서 빌드 측면에서 우수한 속도를 자랑하고, <strong>의존성 그래프 시각화</strong> 기능을 통해 프로젝트의 구성 요소들이 서로 어떤 의존관계를 갖고있는 지 한눈에 파악이 가능하도록 해준다.</p>\n\n<p>둘 중 좀더 가벼운 시작을 원한다면, <strong>Zero Config</strong>를 지향해 초기 설정이 상대적으로 쉬운 Turborepo를 시도하는 것도 좋을 것이다. 상대적으로 출시된 지 오래되어 관련 레퍼런스, 지원하는 IDE 플러그인 등의 <strong>풍부한 생태계</strong>가 형성되어 있는 Nx 또한 좋은 선택지가 될 수 있다.</p>\n\n<p>위의 네 가지 도구 모두 상황에 따라 좋은 선택지가 될 수 있으니, 현재 프로젝트 상황에 맞는 좋은 도구를 선택하여 즐겁게 개발하길 바란다.</p>","href":"this.company.rssUrl모던 프론트엔드 프로젝트 구성 기법 - 모노레포 도구 편"}